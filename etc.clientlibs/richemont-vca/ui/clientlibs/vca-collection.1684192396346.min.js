/**
 * @fileOverview Set up vca namespace
 */

/**
 * @namespace
 */
var vca = window.vca || {};

/**
 * @namespace
 */
vca.comp = vca.comp || {};

/**
 * @namespace
 */
vca.util = vca.util || {};

/* global vca */

/**
 * @fileOverview clean up 3rd party lib namespaces that pollute the global scope
 * e.g. Remove jQuery from the global scope so that two vesions of jQuery can coexist
 */
(function() {
    'use strict';
    // Namespace jQuery so it doesn't clash with other jquery versions
    vca.$ = base.$; // $.noConflict(true);

    // window.$ = window.jQuery = null;
})();

/*

  IMPORTANT - PLEASE READ:

  The library has been manually modified to apply custom CSS classes.
  The modifications can be found with a search for "vca" string.
*/

/*
     _ _      _       _
 ___| (_) ___| | __  (_)___
/ __| | |/ __| |/ /  | / __|
\__ \ | | (__|   < _ | \__ \
|___/_|_|\___|_|\_(_)/ |___/
                   |__/

 Version: 1.8.1
  Author: Ken Wheeler
 Website: http://kenwheeler.github.io
    Docs: http://kenwheeler.github.io/slick
    Repo: http://github.com/kenwheeler/slick
  Issues: http://github.com/kenwheeler/slick/issues

 */
/* global window, document, define, jQuery, setInterval, clearInterval */
;(function(factory) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
      define(['jquery'], factory);
  } else if (typeof exports !== 'undefined') {
      module.exports = factory(require('jquery'));
  } else {
      factory(vca.$);
  }

}(function($) {
  'use strict';
  var Slick = window.Slick || {};

  Slick = (function() {

      var instanceUid = 0;

      function Slick(element, settings) {

          var _ = this, dataSettings;

          _.defaults = {
              accessibility: true,
              adaptiveHeight: false,
              appendArrows: $(element),
              appendDots: $(element),
              arrows: true,
              asNavFor: null,
              prevArrow: '<button class="slick-prev vca-slick-arrow vca-slick-prev" aria-label="Previous" type="button"><span class="vca-accessible-text">Previous</span></button>',
              nextArrow: '<button class="slick-next vca-slick-arrow vca-slick-next" aria-label="Next" type="button"><span class="vca-accessible-text">Next</span></button>',
              autoplay: false,
              autoplaySpeed: 3000,
              centerMode: false,
              centerPadding: '50px',
              cssEase: 'ease',
              customPaging: function(slider, i) {
                  return $('<button type="button" class="vca-slick-button" />').text(i + 1);
              },
              dots: false,
              dotsClass: 'slick-dots vca-slick-dots',
              draggable: true,
              easing: 'linear',
              edgeFriction: 0.35,
              fade: false,
              focusOnSelect: false,
              focusOnChange: false,
              infinite: true,
              initialSlide: 0,
              lazyLoad: 'ondemand',
              mobileFirst: false,
              pauseOnHover: true,
              pauseOnFocus: true,
              pauseOnDotsHover: false,
              respondTo: 'window',
              responsive: null,
              rows: 1,
              rtl: false,
              slide: '',
              slidesPerRow: 1,
              slidesToShow: 1,
              slidesToScroll: 1,
              speed: 500,
              swipe: true,
              swipeToSlide: false,
              touchMove: true,
              touchThreshold: 5,
              useCSS: true,
              useTransform: true,
              variableWidth: false,
              vertical: false,
              verticalSwiping: false,
              waitForAnimate: true,
              zIndex: 1000
          };

          _.initials = {
              animating: false,
              dragging: false,
              autoPlayTimer: null,
              currentDirection: 0,
              currentLeft: null,
              currentSlide: 0,
              direction: 1,
              $dots: null,
              listWidth: null,
              listHeight: null,
              loadIndex: 0,
              $nextArrow: null,
              $prevArrow: null,
              scrolling: false,
              slideCount: null,
              slideWidth: null,
              $slideTrack: null,
              $slides: null,
              sliding: false,
              slideOffset: 0,
              swipeLeft: null,
              swiping: false,
              $list: null,
              touchObject: {},
              transformsEnabled: false,
              unslicked: false
          };

          $.extend(_, _.initials);

          _.activeBreakpoint = null;
          _.animType = null;
          _.animProp = null;
          _.breakpoints = [];
          _.breakpointSettings = [];
          _.cssTransitions = false;
          _.focussed = false;
          _.interrupted = false;
          _.hidden = 'hidden';
          _.paused = true;
          _.positionProp = null;
          _.respondTo = null;
          _.rowCount = 1;
          _.shouldClick = true;
          _.$slider = $(element);
          _.$slidesCache = null;
          _.transformType = null;
          _.transitionType = null;
          _.visibilityChange = 'visibilitychange';
          _.windowWidth = 0;
          _.windowTimer = null;

          dataSettings = $(element).data('slick') || {};

          _.options = $.extend({}, _.defaults, settings, dataSettings);

          _.currentSlide = _.options.initialSlide;

          _.originalSettings = _.options;

          if (typeof document.mozHidden !== 'undefined') {
              _.hidden = 'mozHidden';
              _.visibilityChange = 'mozvisibilitychange';
          } else if (typeof document.webkitHidden !== 'undefined') {
              _.hidden = 'webkitHidden';
              _.visibilityChange = 'webkitvisibilitychange';
          }

          _.autoPlay = $.proxy(_.autoPlay, _);
          _.autoPlayClear = $.proxy(_.autoPlayClear, _);
          _.autoPlayIterator = $.proxy(_.autoPlayIterator, _);
          _.changeSlide = $.proxy(_.changeSlide, _);
          _.clickHandler = $.proxy(_.clickHandler, _);
          _.selectHandler = $.proxy(_.selectHandler, _);
          _.setPosition = $.proxy(_.setPosition, _);
          _.swipeHandler = $.proxy(_.swipeHandler, _);
          _.dragHandler = $.proxy(_.dragHandler, _);
          _.keyHandler = $.proxy(_.keyHandler, _);

          _.instanceUid = instanceUid++;

          // A simple way to check for HTML strings
          // Strict HTML recognition (must start with <)
          // Extracted from jQuery v1.11 source
          _.htmlExpr = /^(?:\s*(<[\w\W]+>)[^>]*)$/;


          _.registerBreakpoints();
          _.init(true);

      }

      return Slick;

  }());

  Slick.prototype.activateADA = function() {
      var _ = this;

      _.$slideTrack.find('.slick-active.vca-slick-active').attr({
          'aria-hidden': 'false'
      }).find('a, input, button, select').attr({
          'tabindex': '0'
      });

  };

  Slick.prototype.addSlide = Slick.prototype.slickAdd = function(markup, index, addBefore) {

      var _ = this;

      if (typeof(index) === 'boolean') {
          addBefore = index;
          index = null;
      } else if (index < 0 || (index >= _.slideCount)) {
          return false;
      }

      _.unload();

      if (typeof(index) === 'number') {
          if (index === 0 && _.$slides.length === 0) {
              $(markup).appendTo(_.$slideTrack);
          } else if (addBefore) {
              $(markup).insertBefore(_.$slides.eq(index));
          } else {
              $(markup).insertAfter(_.$slides.eq(index));
          }
      } else {
          if (addBefore === true) {
              $(markup).prependTo(_.$slideTrack);
          } else {
              $(markup).appendTo(_.$slideTrack);
          }
      }

      _.$slides = _.$slideTrack.children(this.options.slide);

      _.$slideTrack.children(this.options.slide).detach();

      _.$slideTrack.append(_.$slides);

      _.$slides.each(function(index, element) {
          $(element).attr('data-slick-index', index);
      });

      _.$slidesCache = _.$slides;

      _.reinit();

  };

  Slick.prototype.animateHeight = function() {
      var _ = this;
      if (_.options.slidesToShow === 1 && _.options.adaptiveHeight === true && _.options.vertical === false) {
          var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(true);
          _.$list.animate({
              height: targetHeight
          }, _.options.speed);
      }
  };

  Slick.prototype.animateSlide = function(targetLeft, callback) {

      var animProps = {},
          _ = this;

      _.animateHeight();

      if (_.options.rtl === true && _.options.vertical === false) {
          targetLeft = -targetLeft;
      }
      if (_.transformsEnabled === false) {
          if (_.options.vertical === false) {
              _.$slideTrack.animate({
                  left: targetLeft
              }, _.options.speed, _.options.easing, callback);
          } else {
              _.$slideTrack.animate({
                  top: targetLeft
              }, _.options.speed, _.options.easing, callback);
          }

      } else {

          if (_.cssTransitions === false) {
              if (_.options.rtl === true) {
                  _.currentLeft = -(_.currentLeft);
              }
              $({
                  animStart: _.currentLeft
              }).animate({
                  animStart: targetLeft
              }, {
                  duration: _.options.speed,
                  easing: _.options.easing,
                  step: function(now) {
                      now = Math.ceil(now);
                      if (_.options.vertical === false) {
                          animProps[_.animType] = 'translate(' +
                              now + 'px, 0px)';
                          _.$slideTrack.css(animProps);
                      } else {
                          animProps[_.animType] = 'translate(0px,' +
                              now + 'px)';
                          _.$slideTrack.css(animProps);
                      }
                  },
                  complete: function() {
                      if (callback) {
                          callback.call();
                      }
                  }
              });

          } else {

              _.applyTransition();
              targetLeft = Math.ceil(targetLeft);

              if (_.options.vertical === false) {
                  animProps[_.animType] = 'translate3d(' + targetLeft + 'px, 0px, 0px)';
              } else {
                  animProps[_.animType] = 'translate3d(0px,' + targetLeft + 'px, 0px)';
              }
              _.$slideTrack.css(animProps);

              if (callback) {
                  setTimeout(function() {

                      _.disableTransition();

                      callback.call();
                  }, _.options.speed);
              }

          }

      }

  };

  Slick.prototype.getNavTarget = function() {

      var _ = this,
          asNavFor = _.options.asNavFor;

      if ( asNavFor && asNavFor !== null ) {
          asNavFor = $(asNavFor).not(_.$slider);
      }

      return asNavFor;

  };

  Slick.prototype.asNavFor = function(index) {

      var _ = this,
          asNavFor = _.getNavTarget();

      if ( asNavFor !== null && typeof asNavFor === 'object' ) {
          asNavFor.each(function() {
              var target = $(this).slick('getSlick');
              if(!target.unslicked) {
                  target.slideHandler(index, true);
              }
          });
      }

  };

  Slick.prototype.applyTransition = function(slide) {

      var _ = this,
          transition = {};

      if (_.options.fade === false) {
          transition[_.transitionType] = _.transformType + ' ' + _.options.speed + 'ms ' + _.options.cssEase;
      } else {
          transition[_.transitionType] = 'opacity ' + _.options.speed + 'ms ' + _.options.cssEase;
      }

      if (_.options.fade === false) {
          _.$slideTrack.css(transition);
      } else {
          _.$slides.eq(slide).css(transition);
      }

  };

  Slick.prototype.autoPlay = function() {

      var _ = this;

      _.autoPlayClear();

      if ( _.slideCount > _.options.slidesToShow ) {
          _.autoPlayTimer = setInterval( _.autoPlayIterator, _.options.autoplaySpeed );
      }

  };

  Slick.prototype.autoPlayClear = function() {

      var _ = this;

      if (_.autoPlayTimer) {
          clearInterval(_.autoPlayTimer);
      }

  };

  Slick.prototype.autoPlayIterator = function() {

      var _ = this,
          slideTo = _.currentSlide + _.options.slidesToScroll;

      if ( !_.paused && !_.interrupted && !_.focussed ) {

          if ( _.options.infinite === false ) {

              if ( _.direction === 1 && ( _.currentSlide + 1 ) === ( _.slideCount - 1 )) {
                  _.direction = 0;
              }

              else if ( _.direction === 0 ) {

                  slideTo = _.currentSlide - _.options.slidesToScroll;

                  if ( _.currentSlide - 1 === 0 ) {
                      _.direction = 1;
                  }

              }

          }

          _.slideHandler( slideTo );

      }

  };

  Slick.prototype.buildArrows = function() {

      var _ = this;

      if (_.options.arrows === true ) {

          _.$prevArrow = $(_.options.prevArrow).addClass('slick-arrow vca-carousel-control vca-icn-sleek_arrow_left vca-slick-arrow');
          _.$nextArrow = $(_.options.nextArrow).addClass('slick-arrow vca-carousel-control vca-icn-sleek_arrow_right vca-slick-arrow');

          if( _.slideCount > _.options.slidesToShow ) {

              _.$prevArrow.removeClass('slick-hidden').removeAttr('aria-hidden tabindex');
              _.$nextArrow.removeClass('slick-hidden').removeAttr('aria-hidden tabindex');

              if (_.htmlExpr.test(_.options.prevArrow)) {
                  _.$prevArrow.prependTo(_.options.appendArrows);
              }

              if (_.htmlExpr.test(_.options.nextArrow)) {
                  _.$nextArrow.appendTo(_.options.appendArrows);
              }

              if (_.options.infinite !== true) {
                  _.$prevArrow
                      .addClass('slick-disabled vca-slick-disabled')
                      .attr('aria-disabled', 'true');
              }

          } else {

              _.$prevArrow.add( _.$nextArrow )

                  .addClass('slick-hidden')
                  .attr({
                      'aria-disabled': 'true',
                      'tabindex': '-1'
                  });

          }

      }

  };

  Slick.prototype.buildDots = function() {

      var _ = this,
          i, dot;

      if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {

          _.$slider.addClass('slick-dotted');

          dot = $('<ul />').addClass(_.options.dotsClass);

          for (i = 0; i <= _.getDotCount(); i += 1) {
              dot.append($('<li class="vca-carousel-pagination-item" />').append(_.options.customPaging.call(this, _, i)));
          }

          _.$dots = dot.appendTo(_.options.appendDots);

          _.$dots.find('li').first().addClass('slick-active vca-slick-active');

      }

  };

  Slick.prototype.buildOut = function() {

      var _ = this;

      _.$slides =
          _.$slider
              .children( _.options.slide + ':not(.slick-cloned)')
              .addClass('slick-slide');

      _.slideCount = _.$slides.length;

      _.$slides.each(function(index, element) {
          $(element)
              .attr('data-slick-index', index)
              .data('originalStyling', $(element).attr('style') || '');
      });

      _.$slider.addClass('slick-slider');

      _.$slideTrack = (_.slideCount === 0) ?
          $('<div class="slick-track"/>').appendTo(_.$slider) :
          _.$slides.wrapAll('<div class="slick-track"/>').parent();

      _.$list = _.$slideTrack.wrap(
          '<div class="slick-list"/>').parent();
      _.$slideTrack.css('opacity', 0);

      if (_.options.centerMode === true || _.options.swipeToSlide === true) {
          _.options.slidesToScroll = 1;
      }

      $('img[data-lazy]', _.$slider).not('[src]').addClass('slick-loading');

      _.setupInfinite();

      _.buildArrows();

      _.buildDots();

      _.updateDots();


      _.setSlideClasses(typeof _.currentSlide === 'number' ? _.currentSlide : 0);

      if (_.options.draggable === true) {
          _.$list.addClass('draggable');
      }

  };

  Slick.prototype.buildRows = function() {

      var _ = this, a, b, c, newSlides, numOfSlides, originalSlides,slidesPerSection;

      newSlides = document.createDocumentFragment();
      originalSlides = _.$slider.children();

      if(_.options.rows > 0) {

          slidesPerSection = _.options.slidesPerRow * _.options.rows;
          numOfSlides = Math.ceil(
              originalSlides.length / slidesPerSection
          );

          for(a = 0; a < numOfSlides; a++){
              var slide = document.createElement('div');
              for(b = 0; b < _.options.rows; b++) {
                  var row = document.createElement('div');
                  for(c = 0; c < _.options.slidesPerRow; c++) {
                      var target = (a * slidesPerSection + ((b * _.options.slidesPerRow) + c));
                      if (originalSlides.get(target)) {
                          row.appendChild(originalSlides.get(target));
                      }
                  }
                  slide.appendChild(row);
              }
              newSlides.appendChild(slide);
          }

          _.$slider.empty().append(newSlides);
          _.$slider.children().children().children()
              .css({
                  'width':(100 / _.options.slidesPerRow) + '%',
                  'display': 'inline-block'
              });

      }

  };

  Slick.prototype.checkResponsive = function(initial, forceUpdate) {

      var _ = this,
          breakpoint, targetBreakpoint, respondToWidth, triggerBreakpoint = false;
      var sliderWidth = _.$slider.width();
      var windowWidth = window.innerWidth || $(window).width();

      if (_.respondTo === 'window') {
          respondToWidth = windowWidth;
      } else if (_.respondTo === 'slider') {
          respondToWidth = sliderWidth;
      } else if (_.respondTo === 'min') {
          respondToWidth = Math.min(windowWidth, sliderWidth);
      }

      if ( _.options.responsive &&
          _.options.responsive.length &&
          _.options.responsive !== null) {

          targetBreakpoint = null;

          for (breakpoint in _.breakpoints) {
              if (_.breakpoints.hasOwnProperty(breakpoint)) {
                  if (_.originalSettings.mobileFirst === false) {
                      if (respondToWidth < _.breakpoints[breakpoint]) {
                          targetBreakpoint = _.breakpoints[breakpoint];
                      }
                  } else {
                      if (respondToWidth > _.breakpoints[breakpoint]) {
                          targetBreakpoint = _.breakpoints[breakpoint];
                      }
                  }
              }
          }

          if (targetBreakpoint !== null) {
              if (_.activeBreakpoint !== null) {
                  if (targetBreakpoint !== _.activeBreakpoint || forceUpdate) {
                      _.activeBreakpoint =
                          targetBreakpoint;
                      if (_.breakpointSettings[targetBreakpoint] === 'unslick') {
                          _.unslick(targetBreakpoint);
                      } else {
                          _.options = $.extend({}, _.originalSettings,
                              _.breakpointSettings[
                                  targetBreakpoint]);
                          if (initial === true) {
                              _.currentSlide = _.options.initialSlide;
                          }
                          _.refresh(initial);
                      }
                      triggerBreakpoint = targetBreakpoint;
                  }
              } else {
                  _.activeBreakpoint = targetBreakpoint;
                  if (_.breakpointSettings[targetBreakpoint] === 'unslick') {
                      _.unslick(targetBreakpoint);
                  } else {
                      _.options = $.extend({}, _.originalSettings,
                          _.breakpointSettings[
                              targetBreakpoint]);
                      if (initial === true) {
                          _.currentSlide = _.options.initialSlide;
                      }
                      _.refresh(initial);
                  }
                  triggerBreakpoint = targetBreakpoint;
              }
          } else {
              if (_.activeBreakpoint !== null) {
                  _.activeBreakpoint = null;
                  _.options = _.originalSettings;
                  if (initial === true) {
                      _.currentSlide = _.options.initialSlide;
                  }
                  _.refresh(initial);
                  triggerBreakpoint = targetBreakpoint;
              }
          }

          // only trigger breakpoints during an actual break. not on initialize.
          if( !initial && triggerBreakpoint !== false ) {
              _.$slider.trigger('breakpoint', [_, triggerBreakpoint]);
          }
      }

  };

  Slick.prototype.changeSlide = function(event, dontAnimate) {

      var _ = this,
          $target = $(event.currentTarget),
          indexOffset, slideOffset, unevenOffset;

      // If target is a link, prevent default action.
      if($target.is('a')) {
          event.preventDefault();
      }

      // If target is not the <li> element (ie: a child), find the <li>.
      if(!$target.is('li')) {
          $target = $target.closest('li');
      }

      unevenOffset = (_.slideCount % _.options.slidesToScroll !== 0);
      indexOffset = unevenOffset ? 0 : (_.slideCount - _.currentSlide) % _.options.slidesToScroll;

      switch (event.data.message) {

          case 'previous':
              slideOffset = indexOffset === 0 ? _.options.slidesToScroll : _.options.slidesToShow - indexOffset;
              if (_.slideCount > _.options.slidesToShow) {
                  _.slideHandler(_.currentSlide - slideOffset, false, dontAnimate);
              }
              break;

          case 'next':
              slideOffset = indexOffset === 0 ? _.options.slidesToScroll : indexOffset;
              if (_.slideCount > _.options.slidesToShow) {
                  _.slideHandler(_.currentSlide + slideOffset, false, dontAnimate);
              }
              break;

          case 'index':
              var index = event.data.index === 0 ? 0 :
                  event.data.index || $target.index() * _.options.slidesToScroll;

              _.slideHandler(_.checkNavigable(index), false, dontAnimate);
              $target.children().trigger('focus');
              break;

          default:
              return;
      }

  };

  Slick.prototype.checkNavigable = function(index) {

      var _ = this,
          navigables, prevNavigable;

      navigables = _.getNavigableIndexes();
      prevNavigable = 0;
      if (index > navigables[navigables.length - 1]) {
          index = navigables[navigables.length - 1];
      } else {
          for (var n in navigables) {
              if (index < navigables[n]) {
                  index = prevNavigable;
                  break;
              }
              prevNavigable = navigables[n];
          }
      }

      return index;
  };

  Slick.prototype.cleanUpEvents = function() {

      var _ = this;

      if (_.options.dots && _.$dots !== null) {

          $('li', _.$dots)
              .off('click.slick', _.changeSlide)
              .off('mouseenter.slick', $.proxy(_.interrupt, _, true))
              .off('mouseleave.slick', $.proxy(_.interrupt, _, false));

          if (_.options.accessibility === true) {
              _.$dots.off('keydown.slick', _.keyHandler);
          }
      }

      _.$slider.off('focus.slick blur.slick');

      if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
          _.$prevArrow && _.$prevArrow.off('click.slick', _.changeSlide);
          _.$nextArrow && _.$nextArrow.off('click.slick', _.changeSlide);

          if (_.options.accessibility === true) {
              _.$prevArrow && _.$prevArrow.off('keydown.slick', _.keyHandler);
              _.$nextArrow && _.$nextArrow.off('keydown.slick', _.keyHandler);
          }
      }

      _.$list.off('touchstart.slick mousedown.slick', _.swipeHandler);
      _.$list.off('touchmove.slick mousemove.slick', _.swipeHandler);
      _.$list.off('touchend.slick mouseup.slick', _.swipeHandler);
      _.$list.off('touchcancel.slick mouseleave.slick', _.swipeHandler);

      _.$list.off('click.slick', _.clickHandler);

      $(document).off(_.visibilityChange, _.visibility);

      _.cleanUpSlideEvents();

      if (_.options.accessibility === true) {
          _.$list.off('keydown.slick', _.keyHandler);
      }

      if (_.options.focusOnSelect === true) {
          $(_.$slideTrack).children().off('click.slick', _.selectHandler);
      }

      $(window).off('orientationchange.slick.slick-' + _.instanceUid, _.orientationChange);

      $(window).off('resize.slick.slick-' + _.instanceUid, _.resize);

      $('[draggable!=true]', _.$slideTrack).off('dragstart', _.preventDefault);

      $(window).off('load.slick.slick-' + _.instanceUid, _.setPosition);

  };

  Slick.prototype.cleanUpSlideEvents = function() {

      var _ = this;

      _.$list.off('mouseenter.slick', $.proxy(_.interrupt, _, true));
      _.$list.off('mouseleave.slick', $.proxy(_.interrupt, _, false));

  };

  Slick.prototype.cleanUpRows = function() {

      var _ = this, originalSlides;

      if(_.options.rows > 0) {
          originalSlides = _.$slides.children().children();
          originalSlides.removeAttr('style');
          _.$slider.empty().append(originalSlides);
      }

  };

  Slick.prototype.clickHandler = function(event) {

      var _ = this;

      if (_.shouldClick === false) {
          event.stopImmediatePropagation();
          event.stopPropagation();
          event.preventDefault();
      }

  };

  Slick.prototype.destroy = function(refresh) {

      var _ = this;

      _.autoPlayClear();

      _.touchObject = {};

      _.cleanUpEvents();

      $('.slick-cloned', _.$slider).detach();

      if (_.$dots) {
          _.$dots.remove();
      }

      if ( _.$prevArrow && _.$prevArrow.length ) {

          _.$prevArrow
              .removeClass('slick-disabled slick-arrow slick-hidden vca-slick-disabled vca-slick-arrow')
              .removeAttr('aria-hidden aria-disabled tabindex')
              .css('display','');

          if ( _.htmlExpr.test( _.options.prevArrow )) {
              _.$prevArrow.remove();
          }
      }

      if ( _.$nextArrow && _.$nextArrow.length ) {

          _.$nextArrow
              .removeClass('slick-disabled slick-arrow slick-hidden vca-slick-disabled vca-slick-arrow')
              .removeAttr('aria-hidden aria-disabled tabindex')
              .css('display','');

          if ( _.htmlExpr.test( _.options.nextArrow )) {
              _.$nextArrow.remove();
          }
      }


      if (_.$slides) {

          _.$slides
              .removeClass('slick-slide slick-active slick-center slick-visible slick-current vca-slick-active')
              .removeAttr('aria-hidden')
              .removeAttr('data-slick-index')
              .each(function(){
                  $(this).attr('style', $(this).data('originalStyling'));
              });

          _.$slideTrack.children(this.options.slide).detach();

          _.$slideTrack.detach();

          _.$list.detach();

          _.$slider.append(_.$slides);
      }

      _.cleanUpRows();

      _.$slider.removeClass('slick-slider');
      _.$slider.removeClass('slick-initialized');
      _.$slider.removeClass('slick-dotted');

      _.unslicked = true;

      if(!refresh) {
          _.$slider.trigger('destroy', [_]);
      }

  };

  Slick.prototype.disableTransition = function(slide) {

      var _ = this,
          transition = {};

      transition[_.transitionType] = '';

      if (_.options.fade === false) {
          _.$slideTrack.css(transition);
      } else {
          _.$slides.eq(slide).css(transition);
      }

  };

  Slick.prototype.fadeSlide = function(slideIndex, callback) {

      var _ = this;

      if (_.cssTransitions === false) {

          _.$slides.eq(slideIndex).css({
              zIndex: _.options.zIndex
          });

          _.$slides.eq(slideIndex).animate({
              opacity: 1
          }, _.options.speed, _.options.easing, callback);

      } else {

          _.applyTransition(slideIndex);

          _.$slides.eq(slideIndex).css({
              opacity: 1,
              zIndex: _.options.zIndex
          });

          if (callback) {
              setTimeout(function() {

                  _.disableTransition(slideIndex);

                  callback.call();
              }, _.options.speed);
          }

      }

  };

  Slick.prototype.fadeSlideOut = function(slideIndex) {

      var _ = this;

      if (_.cssTransitions === false) {

          _.$slides.eq(slideIndex).animate({
              opacity: 0,
              zIndex: _.options.zIndex - 2
          }, _.options.speed, _.options.easing);

      } else {

          _.applyTransition(slideIndex);

          _.$slides.eq(slideIndex).css({
              opacity: 0,
              zIndex: _.options.zIndex - 2
          });

      }

  };

  Slick.prototype.filterSlides = Slick.prototype.slickFilter = function(filter) {

      var _ = this;

      if (filter !== null) {

          _.$slidesCache = _.$slides;

          _.unload();

          _.$slideTrack.children(this.options.slide).detach();

          _.$slidesCache.filter(filter).appendTo(_.$slideTrack);

          _.reinit();

      }

  };

  Slick.prototype.focusHandler = function() {

      var _ = this;

      // If any child element receives focus within the slider we need to pause the autoplay
      _.$slider
          .off('focus.slick blur.slick')
          .on(
              'focus.slick',
              '*',
              function(event) {
                  var $sf = $(this);

                  setTimeout(function() {
                      if( _.options.pauseOnFocus ) {
                          if ($sf.is(':focus')) {
                              _.focussed = true;
                              _.autoPlay();
                          }
                      }
                  }, 0);
              }
          ).on(
              'blur.slick',
              '*',
              function(event) {
                  var $sf = $(this);

                  // When a blur occurs on any elements within the slider we become unfocused
                  if( _.options.pauseOnFocus ) {
                      _.focussed = false;
                      _.autoPlay();
                  }
              }
          );
  };

  Slick.prototype.getCurrent = Slick.prototype.slickCurrentSlide = function() {

      var _ = this;
      return _.currentSlide;

  };

  Slick.prototype.getDotCount = function() {

      var _ = this;

      var breakPoint = 0;
      var counter = 0;
      var pagerQty = 0;

      if (_.options.infinite === true) {
          if (_.slideCount <= _.options.slidesToShow) {
               ++pagerQty;
          } else {
              while (breakPoint < _.slideCount) {
                  ++pagerQty;
                  breakPoint = counter + _.options.slidesToScroll;
                  counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
              }
          }
      } else if (_.options.centerMode === true) {
          pagerQty = _.slideCount;
      } else if(!_.options.asNavFor) {
          pagerQty = 1 + Math.ceil((_.slideCount - _.options.slidesToShow) / _.options.slidesToScroll);
      }else {
          while (breakPoint < _.slideCount) {
              ++pagerQty;
              breakPoint = counter + _.options.slidesToScroll;
              counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
          }
      }

      return pagerQty - 1;

  };

  Slick.prototype.getLeft = function(slideIndex) {

      var _ = this,
          targetLeft,
          verticalHeight,
          verticalOffset = 0,
          targetSlide,
          coef;

      _.slideOffset = 0;
      verticalHeight = _.$slides.first().outerHeight(true);

      if (_.options.infinite === true) {
          if (_.slideCount > _.options.slidesToShow) {
              _.slideOffset = (_.slideWidth * _.options.slidesToShow) * -1;
              coef = -1

              if (_.options.vertical === true && _.options.centerMode === true) {
                  if (_.options.slidesToShow === 2) {
                      coef = -1.5;
                  } else if (_.options.slidesToShow === 1) {
                      coef = -2
                  }
              }
              verticalOffset = (verticalHeight * _.options.slidesToShow) * coef;
          }
          if (_.slideCount % _.options.slidesToScroll !== 0) {
              if (slideIndex + _.options.slidesToScroll > _.slideCount && _.slideCount > _.options.slidesToShow) {
                  if (slideIndex > _.slideCount) {
                      _.slideOffset = ((_.options.slidesToShow - (slideIndex - _.slideCount)) * _.slideWidth) * -1;
                      verticalOffset = ((_.options.slidesToShow - (slideIndex - _.slideCount)) * verticalHeight) * -1;
                  } else {
                      _.slideOffset = ((_.slideCount % _.options.slidesToScroll) * _.slideWidth) * -1;
                      verticalOffset = ((_.slideCount % _.options.slidesToScroll) * verticalHeight) * -1;
                  }
              }
          }
      } else {
          if (slideIndex + _.options.slidesToShow > _.slideCount) {
              _.slideOffset = ((slideIndex + _.options.slidesToShow) - _.slideCount) * _.slideWidth;
              verticalOffset = ((slideIndex + _.options.slidesToShow) - _.slideCount) * verticalHeight;
          }
      }

      if (_.slideCount <= _.options.slidesToShow) {
          _.slideOffset = 0;
          verticalOffset = 0;
      }

      if (_.options.centerMode === true && _.slideCount <= _.options.slidesToShow) {
          _.slideOffset = ((_.slideWidth * Math.floor(_.options.slidesToShow)) / 2) - ((_.slideWidth * _.slideCount) / 2);
      } else if (_.options.centerMode === true && _.options.infinite === true) {
          _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2) - _.slideWidth;
      } else if (_.options.centerMode === true) {
          _.slideOffset = 0;
          _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2);
      }

      if (_.options.vertical === false) {
          targetLeft = ((slideIndex * _.slideWidth) * -1) + _.slideOffset;
      } else {
          targetLeft = ((slideIndex * verticalHeight) * -1) + verticalOffset;
      }

      if (_.options.variableWidth === true) {

          if (_.slideCount <= _.options.slidesToShow || _.options.infinite === false) {
              targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex);
          } else {
              targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex + _.options.slidesToShow);
          }

          if (_.options.rtl === true) {
              if (targetSlide[0]) {
                  targetLeft = (_.$slideTrack.width() - targetSlide[0].offsetLeft - targetSlide.width()) * -1;
              } else {
                  targetLeft =  0;
              }
          } else {
              targetLeft = targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;
          }

          if (_.options.centerMode === true) {
              if (_.slideCount <= _.options.slidesToShow || _.options.infinite === false) {
                  targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex);
              } else {
                  targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex + _.options.slidesToShow + 1);
              }

              if (_.options.rtl === true) {
                  if (targetSlide[0]) {
                      targetLeft = (_.$slideTrack.width() - targetSlide[0].offsetLeft - targetSlide.width()) * -1;
                  } else {
                      targetLeft =  0;
                  }
              } else {
                  targetLeft = targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;
              }

              targetLeft += (_.$list.width() - targetSlide.outerWidth()) / 2;
          }
      }

      return targetLeft;

  };

  Slick.prototype.getOption = Slick.prototype.slickGetOption = function(option) {

      var _ = this;

      return _.options[option];

  };

  Slick.prototype.getNavigableIndexes = function() {

      var _ = this,
          breakPoint = 0,
          counter = 0,
          indexes = [],
          max;

      if (_.options.infinite === false) {
          max = _.slideCount;
      } else {
          breakPoint = _.options.slidesToScroll * -1;
          counter = _.options.slidesToScroll * -1;
          max = _.slideCount * 2;
      }

      while (breakPoint < max) {
          indexes.push(breakPoint);
          breakPoint = counter + _.options.slidesToScroll;
          counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
      }

      return indexes;

  };

  Slick.prototype.getSlick = function() {

      return this;

  };

  Slick.prototype.getSlideCount = function() {

      var _ = this,
          slidesTraversed, swipedSlide, swipeTarget, centerOffset;

      centerOffset = _.options.centerMode === true ? Math.floor(_.$list.width() / 2) : 0;
      swipeTarget = (_.swipeLeft * -1) + centerOffset;

      if (_.options.swipeToSlide === true) {

          _.$slideTrack.find('.slick-slide').each(function(index, slide) {

              var slideOuterWidth, slideOffset, slideRightBoundary;
              slideOuterWidth = $(slide).outerWidth();
              slideOffset = slide.offsetLeft;
              if (_.options.centerMode !== true) {
                  slideOffset += (slideOuterWidth / 2);
              }

              slideRightBoundary = slideOffset + (slideOuterWidth);

              if (swipeTarget < slideRightBoundary) {
                  swipedSlide = slide;
                  return false;
              }
          });

          slidesTraversed = Math.abs($(swipedSlide).attr('data-slick-index') - _.currentSlide) || 1;

          return slidesTraversed;

      } else {
          return _.options.slidesToScroll;
      }

  };

  Slick.prototype.goTo = Slick.prototype.slickGoTo = function(slide, dontAnimate) {

      var _ = this;

      _.changeSlide({
          data: {
              message: 'index',
              index: parseInt(slide)
          }
      }, dontAnimate);

  };

  Slick.prototype.init = function(creation) {

      var _ = this;

      if (!$(_.$slider).hasClass('slick-initialized')) {

          $(_.$slider).addClass('slick-initialized');

          _.buildRows();
          _.buildOut();
          _.setProps();
          _.startLoad();
          _.loadSlider();
          _.initializeEvents();
          _.updateArrows();
          _.updateDots();
          _.checkResponsive(true);
          _.focusHandler();

      }

      if (creation) {
          _.$slider.trigger('init', [_]);
      }

      if (_.options.accessibility === true) {
          _.initADA();
      }

      if ( _.options.autoplay ) {

          _.paused = false;
          _.autoPlay();

      }

  };

  Slick.prototype.initADA = function() {
      var _ = this,
              numDotGroups = Math.ceil(_.slideCount / _.options.slidesToShow),
              tabControlIndexes = _.getNavigableIndexes().filter(function(val) {
                  return (val >= 0) && (val < _.slideCount);
              });

      _.$slides.add(_.$slideTrack.find('.slick-cloned')).attr({
          'aria-hidden': 'true',
          'tabindex': '-1'
      }).find('a, input, button, select').attr({
          'tabindex': '-1'
      });

      if (_.$dots !== null) {
          _.$slides.not(_.$slideTrack.find('.slick-cloned')).each(function(i) {
              var slideControlIndex = tabControlIndexes.indexOf(i);

              $(this).attr({
                  'role': 'tabpanel',
                  'id': 'slick-slide' + _.instanceUid + i,
                  'tabindex': -1
              });

              if (slideControlIndex !== -1) {
                 var ariaButtonControl = 'slick-slide-control' + _.instanceUid + slideControlIndex
                 if ($('#' + ariaButtonControl).length) {
                   $(this).attr({
                       'aria-describedby': ariaButtonControl
                   });
                 }
              }
          });

          _.$dots.attr('role', 'tablist').find('li').each(function(i) {
              var mappedSlideIndex = tabControlIndexes[i];

              $(this).attr({
                  'role': 'presentation'
              });

              $(this).find('button').first().attr({
                  'role': 'tab',
                  'id': 'slick-slide-control' + _.instanceUid + i,
                  'aria-controls': 'slick-slide' + _.instanceUid + mappedSlideIndex,
                  'aria-label': (i + 1) + ' of ' + numDotGroups,
                  'aria-selected': null,
                  'tabindex': '-1'
              });

          }).eq(_.currentSlide).find('button').attr({
              'aria-selected': 'true',
              'tabindex': '0'
          }).end();
      }

      for (var i=_.currentSlide, max=i+_.options.slidesToShow; i < max; i++) {
        if (_.options.focusOnChange) {
          _.$slides.eq(i).attr({'tabindex': '0'});
        } else {
          _.$slides.eq(i).removeAttr('tabindex');
        }
      }

      _.activateADA();

  };

  Slick.prototype.initArrowEvents = function() {

      var _ = this;

      if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
          _.$prevArrow
             .off('click.slick')
             .on('click.slick', {
                  message: 'previous'
             }, _.changeSlide);
          _.$nextArrow
             .off('click.slick')
             .on('click.slick', {
                  message: 'next'
             }, _.changeSlide);

          if (_.options.accessibility === true) {
              _.$prevArrow.on('keydown.slick', _.keyHandler);
              _.$nextArrow.on('keydown.slick', _.keyHandler);
          }
      }

  };

  Slick.prototype.initDotEvents = function() {

      var _ = this;

      if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {
          $('li', _.$dots).on('click.slick', {
              message: 'index'
          }, _.changeSlide);

          if (_.options.accessibility === true) {
              _.$dots.on('keydown.slick', _.keyHandler);
          }
      }

      if (_.options.dots === true && _.options.pauseOnDotsHover === true && _.slideCount > _.options.slidesToShow) {

          $('li', _.$dots)
              .on('mouseenter.slick', $.proxy(_.interrupt, _, true))
              .on('mouseleave.slick', $.proxy(_.interrupt, _, false));

      }

  };

  Slick.prototype.initSlideEvents = function() {

      var _ = this;

      if ( _.options.pauseOnHover ) {

          _.$list.on('mouseenter.slick', $.proxy(_.interrupt, _, true));
          _.$list.on('mouseleave.slick', $.proxy(_.interrupt, _, false));

      }

  };

  Slick.prototype.initializeEvents = function() {

      var _ = this;

      _.initArrowEvents();

      _.initDotEvents();
      _.initSlideEvents();

      _.$list.on('touchstart.slick mousedown.slick', {
          action: 'start'
      }, _.swipeHandler);
      _.$list.on('touchmove.slick mousemove.slick', {
          action: 'move'
      }, _.swipeHandler);
      _.$list.on('touchend.slick mouseup.slick', {
          action: 'end'
      }, _.swipeHandler);
      _.$list.on('touchcancel.slick mouseleave.slick', {
          action: 'end'
      }, _.swipeHandler);

      _.$list.on('click.slick', _.clickHandler);

      $(document).on(_.visibilityChange, $.proxy(_.visibility, _));

      if (_.options.accessibility === true) {
          _.$list.on('keydown.slick', _.keyHandler);
      }

      if (_.options.focusOnSelect === true) {
          $(_.$slideTrack).children().on('click.slick', _.selectHandler);
      }

      $(window).on('orientationchange.slick.slick-' + _.instanceUid, $.proxy(_.orientationChange, _));

      $(window).on('resize.slick.slick-' + _.instanceUid, $.proxy(_.resize, _));

      $('[draggable!=true]', _.$slideTrack).on('dragstart', _.preventDefault);

      $(window).on('load.slick.slick-' + _.instanceUid, _.setPosition);
      $(_.setPosition);

  };

  Slick.prototype.initUI = function() {

      var _ = this;

      if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {

          _.$prevArrow.show();
          _.$nextArrow.show();

      }

      if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {

          _.$dots.show();

      }

  };

  Slick.prototype.keyHandler = function(event) {

      var _ = this;
       //Dont slide if the cursor is inside the form fields and arrow keys are pressed
      if(!event.target.tagName.match('TEXTAREA|INPUT|SELECT')) {
          if (event.keyCode === 37 && _.options.accessibility === true) {
              _.changeSlide({
                  data: {
                      message: _.options.rtl === true ? 'next' :  'previous'
                  }
              });
          } else if (event.keyCode === 39 && _.options.accessibility === true) {
              _.changeSlide({
                  data: {
                      message: _.options.rtl === true ? 'previous' : 'next'
                  }
              });
          }
      }

  };

  Slick.prototype.lazyLoad = function() {

      var _ = this,
          loadRange, cloneRange, rangeStart, rangeEnd;

      function loadImages(imagesScope) {

          $('img[data-lazy]', imagesScope).each(function() {

              var image = $(this),
                  imageSource = $(this).attr('data-lazy'),
                  imageSrcSet = $(this).attr('data-srcset'),
                  imageSizes  = $(this).attr('data-sizes') || _.$slider.attr('data-sizes'),
                  imageToLoad = document.createElement('img');

              imageToLoad.onload = function() {

                  image
                      .animate({ opacity: 0 }, 100, function() {

                          if (imageSrcSet) {
                              image
                                  .attr('srcset', imageSrcSet );

                              if (imageSizes) {
                                  image
                                      .attr('sizes', imageSizes );
                              }
                          }

                          image
                              .attr('src', imageSource)
                              .animate({ opacity: 1 }, 200, function() {
                                  image
                                      .removeAttr('data-lazy data-srcset data-sizes')
                                      .removeClass('slick-loading');
                              });
                          _.$slider.trigger('lazyLoaded', [_, image, imageSource]);
                      });

              };

              imageToLoad.onerror = function() {

                  image
                      .removeAttr( 'data-lazy' )
                      .removeClass( 'slick-loading' )
                      .addClass( 'slick-lazyload-error' );

                  _.$slider.trigger('lazyLoadError', [ _, image, imageSource ]);

              };

              imageToLoad.src = imageSource;

          });

      }

      if (_.options.centerMode === true) {
          if (_.options.infinite === true) {
              rangeStart = _.currentSlide + (_.options.slidesToShow / 2 + 1);
              rangeEnd = rangeStart + _.options.slidesToShow + 2;
          } else {
              rangeStart = Math.max(0, _.currentSlide - (_.options.slidesToShow / 2 + 1));
              rangeEnd = 2 + (_.options.slidesToShow / 2 + 1) + _.currentSlide;
          }
      } else {
          rangeStart = _.options.infinite ? _.options.slidesToShow + _.currentSlide : _.currentSlide;
          rangeEnd = Math.ceil(rangeStart + _.options.slidesToShow);
          if (_.options.fade === true) {
              if (rangeStart > 0) rangeStart--;
              if (rangeEnd <= _.slideCount) rangeEnd++;
          }
      }

      loadRange = _.$slider.find('.slick-slide').slice(rangeStart, rangeEnd);

      if (_.options.lazyLoad === 'anticipated') {
          var prevSlide = rangeStart - 1,
              nextSlide = rangeEnd,
              $slides = _.$slider.find('.slick-slide');

          for (var i = 0; i < _.options.slidesToScroll; i++) {
              if (prevSlide < 0) prevSlide = _.slideCount - 1;
              loadRange = loadRange.add($slides.eq(prevSlide));
              loadRange = loadRange.add($slides.eq(nextSlide));
              prevSlide--;
              nextSlide++;
          }
      }

      loadImages(loadRange);

      if (_.slideCount <= _.options.slidesToShow) {
          cloneRange = _.$slider.find('.slick-slide');
          loadImages(cloneRange);
      } else
      if (_.currentSlide >= _.slideCount - _.options.slidesToShow) {
          cloneRange = _.$slider.find('.slick-cloned').slice(0, _.options.slidesToShow);
          loadImages(cloneRange);
      } else if (_.currentSlide === 0) {
          cloneRange = _.$slider.find('.slick-cloned').slice(_.options.slidesToShow * -1);
          loadImages(cloneRange);
      }

  };

  Slick.prototype.loadSlider = function() {

      var _ = this;

      _.setPosition();

      _.$slideTrack.css({
          opacity: 1
      });

      _.$slider.removeClass('slick-loading');

      _.initUI();

      if (_.options.lazyLoad === 'progressive') {
          _.progressiveLazyLoad();
      }

  };

  Slick.prototype.next = Slick.prototype.slickNext = function() {

      var _ = this;

      _.changeSlide({
          data: {
              message: 'next'
          }
      });

  };

  Slick.prototype.orientationChange = function() {

      var _ = this;

      _.checkResponsive();
      _.setPosition();

  };

  Slick.prototype.pause = Slick.prototype.slickPause = function() {

      var _ = this;

      _.autoPlayClear();
      _.paused = true;

  };

  Slick.prototype.play = Slick.prototype.slickPlay = function() {

      var _ = this;

      _.autoPlay();
      _.options.autoplay = true;
      _.paused = false;
      _.focussed = false;
      _.interrupted = false;

  };

  Slick.prototype.postSlide = function(index) {

      var _ = this;

      if( !_.unslicked ) {

          _.$slider.trigger('afterChange', [_, index]);

          _.animating = false;

          if (_.slideCount > _.options.slidesToShow) {
              _.setPosition();
          }

          _.swipeLeft = null;

          if ( _.options.autoplay ) {
              _.autoPlay();
          }

          if (_.options.accessibility === true) {
              _.initADA();

              if (_.options.focusOnChange) {
                  var $currentSlide = $(_.$slides.get(_.currentSlide));
                  $currentSlide.attr('tabindex', 0).focus();
              }
          }

      }

  };

  Slick.prototype.prev = Slick.prototype.slickPrev = function() {

      var _ = this;

      _.changeSlide({
          data: {
              message: 'previous'
          }
      });

  };

  Slick.prototype.preventDefault = function(event) {

      event.preventDefault();

  };

  Slick.prototype.progressiveLazyLoad = function( tryCount ) {

      tryCount = tryCount || 1;

      var _ = this,
          $imgsToLoad = $( 'img[data-lazy]', _.$slider ),
          image,
          imageSource,
          imageSrcSet,
          imageSizes,
          imageToLoad;

      if ( $imgsToLoad.length ) {

          image = $imgsToLoad.first();
          imageSource = image.attr('data-lazy');
          imageSrcSet = image.attr('data-srcset');
          imageSizes  = image.attr('data-sizes') || _.$slider.attr('data-sizes');
          imageToLoad = document.createElement('img');

          imageToLoad.onload = function() {

              if (imageSrcSet) {
                  image
                      .attr('srcset', imageSrcSet );

                  if (imageSizes) {
                      image
                          .attr('sizes', imageSizes );
                  }
              }

              image
                  .attr( 'src', imageSource )
                  .removeAttr('data-lazy data-srcset data-sizes')
                  .removeClass('slick-loading');

              if ( _.options.adaptiveHeight === true ) {
                  _.setPosition();
              }

              _.$slider.trigger('lazyLoaded', [ _, image, imageSource ]);
              _.progressiveLazyLoad();

          };

          imageToLoad.onerror = function() {

              if ( tryCount < 3 ) {

                  /**
                   * try to load the image 3 times,
                   * leave a slight delay so we don't get
                   * servers blocking the request.
                   */
                  setTimeout( function() {
                      _.progressiveLazyLoad( tryCount + 1 );
                  }, 500 );

              } else {

                  image
                      .removeAttr( 'data-lazy' )
                      .removeClass( 'slick-loading' )
                      .addClass( 'slick-lazyload-error' );

                  _.$slider.trigger('lazyLoadError', [ _, image, imageSource ]);

                  _.progressiveLazyLoad();

              }

          };

          imageToLoad.src = imageSource;

      } else {

          _.$slider.trigger('allImagesLoaded', [ _ ]);

      }

  };

  Slick.prototype.refresh = function( initializing ) {

      var _ = this, currentSlide, lastVisibleIndex;

      lastVisibleIndex = _.slideCount - _.options.slidesToShow;

      // in non-infinite sliders, we don't want to go past the
      // last visible index.
      if( !_.options.infinite && ( _.currentSlide > lastVisibleIndex )) {
          _.currentSlide = lastVisibleIndex;
      }

      // if less slides than to show, go to start.
      if ( _.slideCount <= _.options.slidesToShow ) {
          _.currentSlide = 0;

      }

      currentSlide = _.currentSlide;

      _.destroy(true);

      $.extend(_, _.initials, { currentSlide: currentSlide });

      _.init();

      if( !initializing ) {

          _.changeSlide({
              data: {
                  message: 'index',
                  index: currentSlide
              }
          }, false);

      }

  };

  Slick.prototype.registerBreakpoints = function() {

      var _ = this, breakpoint, currentBreakpoint, l,
          responsiveSettings = _.options.responsive || null;

      if ( $.type(responsiveSettings) === 'array' && responsiveSettings.length ) {

          _.respondTo = _.options.respondTo || 'window';

          for ( breakpoint in responsiveSettings ) {

              l = _.breakpoints.length-1;

              if (responsiveSettings.hasOwnProperty(breakpoint)) {
                  currentBreakpoint = responsiveSettings[breakpoint].breakpoint;

                  // loop through the breakpoints and cut out any existing
                  // ones with the same breakpoint number, we don't want dupes.
                  while( l >= 0 ) {
                      if( _.breakpoints[l] && _.breakpoints[l] === currentBreakpoint ) {
                          _.breakpoints.splice(l,1);
                      }
                      l--;
                  }

                  _.breakpoints.push(currentBreakpoint);
                  _.breakpointSettings[currentBreakpoint] = responsiveSettings[breakpoint].settings;

              }

          }

          _.breakpoints.sort(function(a, b) {
              return ( _.options.mobileFirst ) ? a-b : b-a;
          });

      }

  };

  Slick.prototype.reinit = function() {

      var _ = this;

      _.$slides =
          _.$slideTrack
              .children(_.options.slide)
              .addClass('slick-slide');

      _.slideCount = _.$slides.length;

      if (_.currentSlide >= _.slideCount && _.currentSlide !== 0) {
          _.currentSlide = _.currentSlide - _.options.slidesToScroll;
      }

      if (_.slideCount <= _.options.slidesToShow) {
          _.currentSlide = 0;
      }

      _.registerBreakpoints();

      _.setProps();
      _.setupInfinite();
      _.buildArrows();
      _.updateArrows();
      _.initArrowEvents();
      _.buildDots();
      _.updateDots();
      _.initDotEvents();
      _.cleanUpSlideEvents();
      _.initSlideEvents();

      _.checkResponsive(false, true);

      if (_.options.focusOnSelect === true) {
          $(_.$slideTrack).children().on('click.slick', _.selectHandler);
      }

      _.setSlideClasses(typeof _.currentSlide === 'number' ? _.currentSlide : 0);

      _.setPosition();
      _.focusHandler();

      _.paused = !_.options.autoplay;
      _.autoPlay();

      _.$slider.trigger('reInit', [_]);

  };

  Slick.prototype.resize = function() {

      var _ = this;

      if ($(window).width() !== _.windowWidth) {
          clearTimeout(_.windowDelay);
          _.windowDelay = window.setTimeout(function() {
              _.windowWidth = $(window).width();
              _.checkResponsive();
              if( !_.unslicked ) { _.setPosition(); }
          }, 50);
      }
  };

  Slick.prototype.removeSlide = Slick.prototype.slickRemove = function(index, removeBefore, removeAll) {

      var _ = this;

      if (typeof(index) === 'boolean') {
          removeBefore = index;
          index = removeBefore === true ? 0 : _.slideCount - 1;
      } else {
          index = removeBefore === true ? --index : index;
      }

      if (_.slideCount < 1 || index < 0 || index > _.slideCount - 1) {
          return false;
      }

      _.unload();

      if (removeAll === true) {
          _.$slideTrack.children().remove();
      } else {
          _.$slideTrack.children(this.options.slide).eq(index).remove();
      }

      _.$slides = _.$slideTrack.children(this.options.slide);

      _.$slideTrack.children(this.options.slide).detach();

      _.$slideTrack.append(_.$slides);

      _.$slidesCache = _.$slides;

      _.reinit();

  };

  Slick.prototype.setCSS = function(position) {

      var _ = this,
          positionProps = {},
          x, y;

      if (_.options.rtl === true) {
          position = -position;
      }
      x = _.positionProp == 'left' ? Math.ceil(position) + 'px' : '0px';
      y = _.positionProp == 'top' ? Math.ceil(position) + 'px' : '0px';

      positionProps[_.positionProp] = position;

      if (_.transformsEnabled === false) {
          _.$slideTrack.css(positionProps);
      } else {
          positionProps = {};
          if (_.cssTransitions === false) {
              positionProps[_.animType] = 'translate(' + x + ', ' + y + ')';
              _.$slideTrack.css(positionProps);
          } else {
              positionProps[_.animType] = 'translate3d(' + x + ', ' + y + ', 0px)';
              _.$slideTrack.css(positionProps);
          }
      }

  };

  Slick.prototype.setDimensions = function() {

      var _ = this;

      if (_.options.vertical === false) {
          if (_.options.centerMode === true) {
              _.$list.css({
                  padding: ('0px ' + _.options.centerPadding)
              });
          }
      } else {
          _.$list.height(_.$slides.first().outerHeight(true) * _.options.slidesToShow);
          if (_.options.centerMode === true) {
              _.$list.css({
                  padding: (_.options.centerPadding + ' 0px')
              });
          }
      }

      _.listWidth = _.$list.width();
      _.listHeight = _.$list.height();


      if (_.options.vertical === false && _.options.variableWidth === false) {
          _.slideWidth = Math.ceil(_.listWidth / _.options.slidesToShow);
          _.$slideTrack.width(Math.ceil((_.slideWidth * _.$slideTrack.children('.slick-slide').length)));

      } else if (_.options.variableWidth === true) {
          _.$slideTrack.width(5000 * _.slideCount);
      } else {
          _.slideWidth = Math.ceil(_.listWidth);
          _.$slideTrack.height(Math.ceil((_.$slides.first().outerHeight(true) * _.$slideTrack.children('.slick-slide').length)));
      }

      var offset = _.$slides.first().outerWidth(true) - _.$slides.first().width();
      if (_.options.variableWidth === false) _.$slideTrack.children('.slick-slide').width(_.slideWidth - offset);

  };

  Slick.prototype.setFade = function() {

      var _ = this,
          targetLeft;

      _.$slides.each(function(index, element) {
          targetLeft = (_.slideWidth * index) * -1;
          if (_.options.rtl === true) {
              $(element).css({
                  position: 'relative',
                  right: targetLeft,
                  top: 0,
                  zIndex: _.options.zIndex - 2,
                  opacity: 0
              });
          } else {
              $(element).css({
                  position: 'relative',
                  left: targetLeft,
                  top: 0,
                  zIndex: _.options.zIndex - 2,
                  opacity: 0
              });
          }
      });

      _.$slides.eq(_.currentSlide).css({
          zIndex: _.options.zIndex - 1,
          opacity: 1
      });

  };

  Slick.prototype.setHeight = function() {

      var _ = this;

      if (_.options.slidesToShow === 1 && _.options.adaptiveHeight === true && _.options.vertical === false) {
          var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(true);
          _.$list.css('height', targetHeight);
      }

  };

  Slick.prototype.setOption =
  Slick.prototype.slickSetOption = function() {

      /**
       * accepts arguments in format of:
       *
       *  - for changing a single option's value:
       *     .slick("setOption", option, value, refresh )
       *
       *  - for changing a set of responsive options:
       *     .slick("setOption", 'responsive', [{}, ...], refresh )
       *
       *  - for updating multiple values at once (not responsive)
       *     .slick("setOption", { 'option': value, ... }, refresh )
       */

      var _ = this, l, item, option, value, refresh = false, type;

      if( $.type( arguments[0] ) === 'object' ) {

          option =  arguments[0];
          refresh = arguments[1];
          type = 'multiple';

      } else if ( $.type( arguments[0] ) === 'string' ) {

          option =  arguments[0];
          value = arguments[1];
          refresh = arguments[2];

          if ( arguments[0] === 'responsive' && $.type( arguments[1] ) === 'array' ) {

              type = 'responsive';

          } else if ( typeof arguments[1] !== 'undefined' ) {

              type = 'single';

          }

      }

      if ( type === 'single' ) {

          _.options[option] = value;


      } else if ( type === 'multiple' ) {

          $.each( option , function( opt, val ) {

              _.options[opt] = val;

          });


      } else if ( type === 'responsive' ) {

          for ( item in value ) {

              if( $.type( _.options.responsive ) !== 'array' ) {

                  _.options.responsive = [ value[item] ];

              } else {

                  l = _.options.responsive.length-1;

                  // loop through the responsive object and splice out duplicates.
                  while( l >= 0 ) {

                      if( _.options.responsive[l].breakpoint === value[item].breakpoint ) {

                          _.options.responsive.splice(l,1);

                      }

                      l--;

                  }

                  _.options.responsive.push( value[item] );

              }

          }

      }

      if ( refresh ) {

          _.unload();
          _.reinit();

      }

  };

  Slick.prototype.setPosition = function() {

      var _ = this;

      _.setDimensions();

      _.setHeight();

      if (_.options.fade === false) {
          _.setCSS(_.getLeft(_.currentSlide));
      } else {
          _.setFade();
      }

      _.$slider.trigger('setPosition', [_]);

  };

  Slick.prototype.setProps = function() {

      var _ = this,
          bodyStyle = document.body.style;

      _.positionProp = _.options.vertical === true ? 'top' : 'left';

      if (_.positionProp === 'top') {
          _.$slider.addClass('slick-vertical');
      } else {
          _.$slider.removeClass('slick-vertical');
      }

      if (bodyStyle.WebkitTransition !== undefined ||
          bodyStyle.MozTransition !== undefined ||
          bodyStyle.msTransition !== undefined) {
          if (_.options.useCSS === true) {
              _.cssTransitions = true;
          }
      }

      if ( _.options.fade ) {
          if ( typeof _.options.zIndex === 'number' ) {
              if( _.options.zIndex < 3 ) {
                  _.options.zIndex = 3;
              }
          } else {
              _.options.zIndex = _.defaults.zIndex;
          }
      }

      if (bodyStyle.OTransform !== undefined) {
          _.animType = 'OTransform';
          _.transformType = '-o-transform';
          _.transitionType = 'OTransition';
          if (bodyStyle.perspectiveProperty === undefined && bodyStyle.webkitPerspective === undefined) _.animType = false;
      }
      if (bodyStyle.MozTransform !== undefined) {
          _.animType = 'MozTransform';
          _.transformType = '-moz-transform';
          _.transitionType = 'MozTransition';
          if (bodyStyle.perspectiveProperty === undefined && bodyStyle.MozPerspective === undefined) _.animType = false;
      }
      if (bodyStyle.webkitTransform !== undefined) {
          _.animType = 'webkitTransform';
          _.transformType = '-webkit-transform';
          _.transitionType = 'webkitTransition';
          if (bodyStyle.perspectiveProperty === undefined && bodyStyle.webkitPerspective === undefined) _.animType = false;
      }
      if (bodyStyle.msTransform !== undefined) {
          _.animType = 'msTransform';
          _.transformType = '-ms-transform';
          _.transitionType = 'msTransition';
          if (bodyStyle.msTransform === undefined) _.animType = false;
      }
      if (bodyStyle.transform !== undefined && _.animType !== false) {
          _.animType = 'transform';
          _.transformType = 'transform';
          _.transitionType = 'transition';
      }
      _.transformsEnabled = _.options.useTransform && (_.animType !== null && _.animType !== false);
  };


  Slick.prototype.setSlideClasses = function(index) {

      var _ = this,
          centerOffset, allSlides, indexOffset, remainder;

      allSlides = _.$slider
          .find('.slick-slide')
          .removeClass('slick-active slick-center slick-current vca-slick-active')
          .attr('aria-hidden', 'true');

      _.$slides
          .eq(index)
          .addClass('slick-current');

      if (_.options.centerMode === true) {

          var evenCoef = _.options.slidesToShow % 2 === 0 ? 1 : 0;

          centerOffset = Math.floor(_.options.slidesToShow / 2);

          if (_.options.infinite === true) {

              if (index >= centerOffset && index <= (_.slideCount - 1) - centerOffset) {
                  _.$slides
                      .slice(index - centerOffset + evenCoef, index + centerOffset + 1)
                      .addClass('slick-active vca-slick-active')
                      .attr('aria-hidden', 'false');

              } else {

                  indexOffset = _.options.slidesToShow + index;
                  allSlides
                      .slice(indexOffset - centerOffset + 1 + evenCoef, indexOffset + centerOffset + 2)
                      .addClass('slick-active vca-slick-active')
                      .attr('aria-hidden', 'false');

              }

              if (index === 0) {

                  allSlides
                      .eq( _.options.slidesToShow + _.slideCount + 1 )
                      .addClass('slick-center');

              } else if (index === _.slideCount - 1) {

                  allSlides
                      .eq(_.options.slidesToShow)
                      .addClass('slick-center');

              }

          }

          _.$slides
              .eq(index)
              .addClass('slick-center');

      } else {

          if (index >= 0 && index <= (_.slideCount - _.options.slidesToShow)) {

              _.$slides
                  .slice(index, index + _.options.slidesToShow)
                  .addClass('slick-active vca-slick-active')
                  .attr('aria-hidden', 'false');

          } else if (allSlides.length <= _.options.slidesToShow) {

              allSlides
                  .addClass('slick-active vca-slick-active')
                  .attr('aria-hidden', 'false');

          } else {

              remainder = _.slideCount % _.options.slidesToShow;
              indexOffset = _.options.infinite === true ? _.options.slidesToShow + index : index;

              if (_.options.slidesToShow == _.options.slidesToScroll && (_.slideCount - index) < _.options.slidesToShow) {

                  allSlides
                      .slice(indexOffset - (_.options.slidesToShow - remainder), indexOffset + remainder)
                      .addClass('slick-active vca-slick-active')
                      .attr('aria-hidden', 'false');

              } else {

                  allSlides
                      .slice(indexOffset, indexOffset + _.options.slidesToShow)
                      .addClass('slick-active vca-slick-active')
                      .attr('aria-hidden', 'false');

              }

          }

      }

      if (_.options.lazyLoad === 'ondemand' || _.options.lazyLoad === 'anticipated') {
          _.lazyLoad();
      }
  };

  Slick.prototype.setupInfinite = function() {

      var _ = this,
          i, slideIndex, infiniteCount;

      if (_.options.fade === true) {
          _.options.centerMode = false;
      }

      if (_.options.infinite === true && _.options.fade === false) {

          slideIndex = null;

          if (_.slideCount > _.options.slidesToShow) {

              if (_.options.centerMode === true) {
                  infiniteCount = _.options.slidesToShow + 1;
              } else {
                  infiniteCount = _.options.slidesToShow;
              }

              for (i = _.slideCount; i > (_.slideCount -
                      infiniteCount); i -= 1) {
                  slideIndex = i - 1;
                  $(_.$slides[slideIndex]).clone(true).attr('id', '')
                      .attr('data-slick-index', slideIndex - _.slideCount)
                      .prependTo(_.$slideTrack).addClass('slick-cloned');
              }
              for (i = 0; i < infiniteCount  + _.slideCount; i += 1) {
                  slideIndex = i;
                  $(_.$slides[slideIndex]).clone(true).attr('id', '')
                      .attr('data-slick-index', slideIndex + _.slideCount)
                      .appendTo(_.$slideTrack).addClass('slick-cloned');
              }
              _.$slideTrack.find('.slick-cloned').find('[id]').each(function() {
                  $(this).attr('id', '');
              });

          }

      }

  };

  Slick.prototype.interrupt = function( toggle ) {

      var _ = this;

      if( !toggle ) {
          _.autoPlay();
      }
      _.interrupted = toggle;

  };

  Slick.prototype.selectHandler = function(event) {

      var _ = this;

      var targetElement =
          $(event.target).is('.slick-slide') ?
              $(event.target) :
              $(event.target).parents('.slick-slide');

      var index = parseInt(targetElement.attr('data-slick-index'));

      if (!index) index = 0;

      if (_.slideCount <= _.options.slidesToShow) {

          _.slideHandler(index, false, true);
          return;

      }

      _.slideHandler(index);

  };

  Slick.prototype.slideHandler = function(index, sync, dontAnimate) {

      var targetSlide, animSlide, oldSlide, slideLeft, targetLeft = null,
          _ = this, navTarget;

      sync = sync || false;

      if (_.animating === true && _.options.waitForAnimate === true) {
          return;
      }

      if (_.options.fade === true && _.currentSlide === index) {
          return;
      }

      if (sync === false) {
          _.asNavFor(index);
      }

      targetSlide = index;
      targetLeft = _.getLeft(targetSlide);
      slideLeft = _.getLeft(_.currentSlide);

      _.currentLeft = _.swipeLeft === null ? slideLeft : _.swipeLeft;

      if (_.options.infinite === false && _.options.centerMode === false && (index < 0 || index > _.getDotCount() * _.options.slidesToScroll)) {
          if (_.options.fade === false) {
              targetSlide = _.currentSlide;
              if (dontAnimate !== true && _.slideCount > _.options.slidesToShow) {
                  _.animateSlide(slideLeft, function() {
                      _.postSlide(targetSlide);
                  });
              } else {
                  _.postSlide(targetSlide);
              }
          }
          return;
      } else if (_.options.infinite === false && _.options.centerMode === true && (index < 0 || index > (_.slideCount - _.options.slidesToScroll))) {
          if (_.options.fade === false) {
              targetSlide = _.currentSlide;
              if (dontAnimate !== true && _.slideCount > _.options.slidesToShow) {
                  _.animateSlide(slideLeft, function() {
                      _.postSlide(targetSlide);
                  });
              } else {
                  _.postSlide(targetSlide);
              }
          }
          return;
      }

      if ( _.options.autoplay ) {
          clearInterval(_.autoPlayTimer);
      }

      if (targetSlide < 0) {
          if (_.slideCount % _.options.slidesToScroll !== 0) {
              animSlide = _.slideCount - (_.slideCount % _.options.slidesToScroll);
          } else {
              animSlide = _.slideCount + targetSlide;
          }
      } else if (targetSlide >= _.slideCount) {
          if (_.slideCount % _.options.slidesToScroll !== 0) {
              animSlide = 0;
          } else {
              animSlide = targetSlide - _.slideCount;
          }
      } else {
          animSlide = targetSlide;
      }

      _.animating = true;

      _.$slider.trigger('beforeChange', [_, _.currentSlide, animSlide]);

      oldSlide = _.currentSlide;
      _.currentSlide = animSlide;

      _.setSlideClasses(_.currentSlide);

      if ( _.options.asNavFor ) {

          navTarget = _.getNavTarget();
          navTarget = navTarget.slick('getSlick');

          if ( navTarget.slideCount <= navTarget.options.slidesToShow ) {
              navTarget.setSlideClasses(_.currentSlide);
          }

      }

      _.updateDots();
      _.updateArrows();

      if (_.options.fade === true) {
          if (dontAnimate !== true) {

              _.fadeSlideOut(oldSlide);

              _.fadeSlide(animSlide, function() {
                  _.postSlide(animSlide);
              });

          } else {
              _.postSlide(animSlide);
          }
          _.animateHeight();
          return;
      }

      if (dontAnimate !== true && _.slideCount > _.options.slidesToShow) {
          _.animateSlide(targetLeft, function() {
              _.postSlide(animSlide);
          });
      } else {
          _.postSlide(animSlide);
      }

  };

  Slick.prototype.startLoad = function() {

      var _ = this;

      if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {

          _.$prevArrow.hide();
          _.$nextArrow.hide();

      }

      if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {

          _.$dots.hide();

      }

      _.$slider.addClass('slick-loading');

  };

  Slick.prototype.swipeDirection = function() {

      var xDist, yDist, r, swipeAngle, _ = this;

      xDist = _.touchObject.startX - _.touchObject.curX;
      yDist = _.touchObject.startY - _.touchObject.curY;
      r = Math.atan2(yDist, xDist);

      swipeAngle = Math.round(r * 180 / Math.PI);
      if (swipeAngle < 0) {
          swipeAngle = 360 - Math.abs(swipeAngle);
      }

      if ((swipeAngle <= 45) && (swipeAngle >= 0)) {
          return (_.options.rtl === false ? 'left' : 'right');
      }
      if ((swipeAngle <= 360) && (swipeAngle >= 315)) {
          return (_.options.rtl === false ? 'left' : 'right');
      }
      if ((swipeAngle >= 135) && (swipeAngle <= 225)) {
          return (_.options.rtl === false ? 'right' : 'left');
      }
      if (_.options.verticalSwiping === true) {
          if ((swipeAngle >= 35) && (swipeAngle <= 135)) {
              return 'down';
          } else {
              return 'up';
          }
      }

      return 'vertical';

  };

  Slick.prototype.swipeEnd = function(event) {

      var _ = this,
          slideCount,
          direction;

      _.dragging = false;
      _.swiping = false;

      if (_.scrolling) {
          _.scrolling = false;
          return false;
      }

      _.interrupted = false;
      _.shouldClick = ( _.touchObject.swipeLength > 10 ) ? false : true;

      if ( _.touchObject.curX === undefined ) {
          return false;
      }

      if ( _.touchObject.edgeHit === true ) {
          _.$slider.trigger('edge', [_, _.swipeDirection() ]);
      }

      if ( _.touchObject.swipeLength >= _.touchObject.minSwipe ) {

          direction = _.swipeDirection();

          switch ( direction ) {

              case 'left':
              case 'down':

                  slideCount =
                      _.options.swipeToSlide ?
                          _.checkNavigable( _.currentSlide + _.getSlideCount() ) :
                          _.currentSlide + _.getSlideCount();

                  _.currentDirection = 0;

                  break;

              case 'right':
              case 'up':

                  slideCount =
                      _.options.swipeToSlide ?
                          _.checkNavigable( _.currentSlide - _.getSlideCount() ) :
                          _.currentSlide - _.getSlideCount();

                  _.currentDirection = 1;

                  break;

              default:


          }

          if( direction != 'vertical' ) {

              _.slideHandler( slideCount );
              _.touchObject = {};
              _.$slider.trigger('swipe', [_, direction ]);

          }

      } else {

          if ( _.touchObject.startX !== _.touchObject.curX ) {

              _.slideHandler( _.currentSlide );
              _.touchObject = {};

          }

      }

  };

  Slick.prototype.swipeHandler = function(event) {

      var _ = this;

      if ((_.options.swipe === false) || ('ontouchend' in document && _.options.swipe === false)) {
          return;
      } else if (_.options.draggable === false && event.type.indexOf('mouse') !== -1) {
          return;
      }

      _.touchObject.fingerCount = event.originalEvent && event.originalEvent.touches !== undefined ?
          event.originalEvent.touches.length : 1;

      _.touchObject.minSwipe = _.listWidth / _.options
          .touchThreshold;

      if (_.options.verticalSwiping === true) {
          _.touchObject.minSwipe = _.listHeight / _.options
              .touchThreshold;
      }

      switch (event.data.action) {

          case 'start':
              _.swipeStart(event);
              break;

          case 'move':
              _.swipeMove(event);
              break;

          case 'end':
              _.swipeEnd(event);
              break;

      }

  };

  Slick.prototype.swipeMove = function(event) {

      var _ = this,
          edgeWasHit = false,
          curLeft, swipeDirection, swipeLength, positionOffset, touches, verticalSwipeLength;

      touches = event.originalEvent !== undefined ? event.originalEvent.touches : null;

      if (!_.dragging || _.scrolling || touches && touches.length !== 1) {
          return false;
      }

      curLeft = _.getLeft(_.currentSlide);

      _.touchObject.curX = touches !== undefined ? touches[0].pageX : event.clientX;
      _.touchObject.curY = touches !== undefined ? touches[0].pageY : event.clientY;

      _.touchObject.swipeLength = Math.round(Math.sqrt(
          Math.pow(_.touchObject.curX - _.touchObject.startX, 2)));

      verticalSwipeLength = Math.round(Math.sqrt(
          Math.pow(_.touchObject.curY - _.touchObject.startY, 2)));

      if (!_.options.verticalSwiping && !_.swiping && verticalSwipeLength > 4) {
          _.scrolling = true;
          return false;
      }

      if (_.options.verticalSwiping === true) {
          _.touchObject.swipeLength = verticalSwipeLength;
      }

      swipeDirection = _.swipeDirection();

      if (event.originalEvent !== undefined && _.touchObject.swipeLength > 4) {
          _.swiping = true;
          event.preventDefault();
      }

      positionOffset = (_.options.rtl === false ? 1 : -1) * (_.touchObject.curX > _.touchObject.startX ? 1 : -1);
      if (_.options.verticalSwiping === true) {
          positionOffset = _.touchObject.curY > _.touchObject.startY ? 1 : -1;
      }


      swipeLength = _.touchObject.swipeLength;

      _.touchObject.edgeHit = false;

      if (_.options.infinite === false) {
          if ((_.currentSlide === 0 && swipeDirection === 'right') || (_.currentSlide >= _.getDotCount() && swipeDirection === 'left')) {
              swipeLength = _.touchObject.swipeLength * _.options.edgeFriction;
              _.touchObject.edgeHit = true;
          }
      }

      if (_.options.vertical === false) {
          _.swipeLeft = curLeft + swipeLength * positionOffset;
      } else {
          _.swipeLeft = curLeft + (swipeLength * (_.$list.height() / _.listWidth)) * positionOffset;
      }
      if (_.options.verticalSwiping === true) {
          _.swipeLeft = curLeft + swipeLength * positionOffset;
      }

      if (_.options.fade === true || _.options.touchMove === false) {
          return false;
      }

      if (_.animating === true) {
          _.swipeLeft = null;
          return false;
      }

      _.setCSS(_.swipeLeft);

  };

  Slick.prototype.swipeStart = function(event) {

      var _ = this,
          touches;

      _.interrupted = true;

      if (_.touchObject.fingerCount !== 1 || _.slideCount <= _.options.slidesToShow) {
          _.touchObject = {};
          return false;
      }

      if (event.originalEvent !== undefined && event.originalEvent.touches !== undefined) {
          touches = event.originalEvent.touches[0];
      }

      _.touchObject.startX = _.touchObject.curX = touches !== undefined ? touches.pageX : event.clientX;
      _.touchObject.startY = _.touchObject.curY = touches !== undefined ? touches.pageY : event.clientY;

      _.dragging = true;

  };

  Slick.prototype.unfilterSlides = Slick.prototype.slickUnfilter = function() {

      var _ = this;

      if (_.$slidesCache !== null) {

          _.unload();

          _.$slideTrack.children(this.options.slide).detach();

          _.$slidesCache.appendTo(_.$slideTrack);

          _.reinit();

      }

  };

  Slick.prototype.unload = function() {

      var _ = this;

      $('.slick-cloned', _.$slider).remove();

      if (_.$dots) {
          _.$dots.remove();
      }

      if (_.$prevArrow && _.htmlExpr.test(_.options.prevArrow)) {
          _.$prevArrow.remove();
      }

      if (_.$nextArrow && _.htmlExpr.test(_.options.nextArrow)) {
          _.$nextArrow.remove();
      }

      _.$slides
          .removeClass('slick-slide slick-active slick-visible slick-current vca-slick-active')
          .attr('aria-hidden', 'true')
          .css('width', '');

  };

  Slick.prototype.unslick = function(fromBreakpoint) {

      var _ = this;
      _.$slider.trigger('unslick', [_, fromBreakpoint]);
      _.destroy();

  };

  Slick.prototype.updateArrows = function() {

      var _ = this,
          centerOffset;

      centerOffset = Math.floor(_.options.slidesToShow / 2);

      if ( _.options.arrows === true &&
          _.slideCount > _.options.slidesToShow &&
          !_.options.infinite ) {

          _.$prevArrow.removeClass('slick-disabled vca-slick-disabled').attr('aria-disabled', 'false');
          _.$nextArrow.removeClass('slick-disabled vca-slick-disabled').attr('aria-disabled', 'false');

          if (_.currentSlide === 0) {

              _.$prevArrow.addClass('slick-disabled vca-slick-disabled').attr('aria-disabled', 'true');
              _.$nextArrow.removeClass('slick-disabled vca-slick-disabled').attr('aria-disabled', 'false');

          } else if (_.currentSlide >= _.slideCount - _.options.slidesToShow && _.options.centerMode === false) {

              _.$nextArrow.addClass('slick-disabled vca-slick-disabled').attr('aria-disabled', 'true');
              _.$prevArrow.removeClass('slick-disabled vca-slick-disabled').attr('aria-disabled', 'false');

          } else if (_.currentSlide >= _.slideCount - 1 && _.options.centerMode === true) {

              _.$nextArrow.addClass('slick-disabled vca-slick-disabled').attr('aria-disabled', 'true');
              _.$prevArrow.removeClass('slick-disabled vca-slick-disabled').attr('aria-disabled', 'false');

          }

      }

  };

  Slick.prototype.updateDots = function() {

      var _ = this;

      if (_.$dots !== null) {

          _.$dots
              .find('li')
                  .removeClass('slick-active vca-slick-active')
                  .end();

          _.$dots
              .find('li')
              .eq(Math.floor(_.currentSlide / _.options.slidesToScroll))
              .addClass('slick-active vca-slick-active');

      }

  };

  Slick.prototype.visibility = function() {

      var _ = this;

      if ( _.options.autoplay ) {

          if ( document[_.hidden] ) {

              _.interrupted = true;

          } else {

              _.interrupted = false;

          }

      }

  };

  $.fn.slick = function() {
      var _ = this,
          opt = arguments[0],
          args = Array.prototype.slice.call(arguments, 1),
          l = _.length,
          i,
          ret;
      for (i = 0; i < l; i++) {
          if (typeof opt == 'object' || typeof opt == 'undefined')
              _[i].slick = new Slick(_[i], opt);
          else
              ret = _[i].slick[opt].apply(_[i].slick, args);
          if (typeof ret != 'undefined') return ret;
      }
      return _;
  };

}));
!function(a,b){var c=b(a,a.document);a.lazySizes=c,"object"==typeof module&&module.exports&&(module.exports=c)}("undefined"!=typeof window?window:{},function(a,b){"use strict";var c,d;if(function(){var b,c={lazyClass:"lazyload",loadedClass:"lazyloaded",loadingClass:"lazyloading",preloadClass:"lazypreload",errorClass:"lazyerror",autosizesClass:"lazyautosizes",srcAttr:"data-src",srcsetAttr:"data-srcset",sizesAttr:"data-sizes",minSize:40,customMedia:{},init:!0,expFactor:1.5,hFac:.8,loadMode:2,loadHidden:!0,ricTimeout:0,throttleDelay:125};d=a.lazySizesConfig||a.lazysizesConfig||{};for(b in c)b in d||(d[b]=c[b])}(),!b||!b.getElementsByClassName)return{init:function(){},cfg:d,noSupport:!0};var e=b.documentElement,f=a.Date,g=a.HTMLPictureElement,h="addEventListener",i="getAttribute",j=a[h],k=a.setTimeout,l=a.requestAnimationFrame||k,m=a.requestIdleCallback,n=/^picture$/i,o=["load","error","lazyincluded","_lazyloaded"],p={},q=Array.prototype.forEach,r=function(a,b){return p[b]||(p[b]=new RegExp("(\\s|^)"+b+"(\\s|$)")),p[b].test(a[i]("class")||"")&&p[b]},s=function(a,b){r(a,b)||a.setAttribute("class",(a[i]("class")||"").trim()+" "+b)},t=function(a,b){var c;(c=r(a,b))&&a.setAttribute("class",(a[i]("class")||"").replace(c," "))},u=function(a,b,c){var d=c?h:"removeEventListener";c&&u(a,b),o.forEach(function(c){a[d](c,b)})},v=function(a,d,e,f,g){var h=b.createEvent("Event");return e||(e={}),e.instance=c,h.initEvent(d,!f,!g),h.detail=e,a.dispatchEvent(h),h},w=function(b,c){var e;!g&&(e=a.picturefill||d.pf)?(c&&c.src&&!b[i]("srcset")&&b.setAttribute("srcset",c.src),e({reevaluate:!0,elements:[b]})):c&&c.src&&(b.src=c.src)},x=function(a,b){return(getComputedStyle(a,null)||{})[b]},y=function(a,b,c){for(c=c||a.offsetWidth;c<d.minSize&&b&&!a._lazysizesWidth;)c=b.offsetWidth,b=b.parentNode;return c},z=function(){var a,c,d=[],e=[],f=d,g=function(){var b=f;for(f=d.length?e:d,a=!0,c=!1;b.length;)b.shift()();a=!1},h=function(d,e){a&&!e?d.apply(this,arguments):(f.push(d),c||(c=!0,(b.hidden?k:l)(g)))};return h._lsFlush=g,h}(),A=function(a,b){return b?function(){z(a)}:function(){var b=this,c=arguments;z(function(){a.apply(b,c)})}},B=function(a){var b,c=0,e=d.throttleDelay,g=d.ricTimeout,h=function(){b=!1,c=f.now(),a()},i=m&&g>49?function(){m(h,{timeout:g}),g!==d.ricTimeout&&(g=d.ricTimeout)}:A(function(){k(h)},!0);return function(a){var d;(a=!0===a)&&(g=33),b||(b=!0,d=e-(f.now()-c),d<0&&(d=0),a||d<9?i():k(i,d))}},C=function(a){var b,c,d=99,e=function(){b=null,a()},g=function(){var a=f.now()-c;a<d?k(g,d-a):(m||e)(e)};return function(){c=f.now(),b||(b=k(g,d))}},D=function(){var g,l,m,o,p,y,D,F,G,H,I,J,K=/^img$/i,L=/^iframe$/i,M="onscroll"in a&&!/(gle|ing)bot/.test(navigator.userAgent),N=0,O=0,P=0,Q=-1,R=function(a){P--,(!a||P<0||!a.target)&&(P=0)},S=function(a){return null==J&&(J="hidden"==x(b.body,"visibility")),J||"hidden"!=x(a.parentNode,"visibility")&&"hidden"!=x(a,"visibility")},T=function(a,c){var d,f=a,g=S(a);for(F-=c,I+=c,G-=c,H+=c;g&&(f=f.offsetParent)&&f!=b.body&&f!=e;)(g=(x(f,"opacity")||1)>0)&&"visible"!=x(f,"overflow")&&(d=f.getBoundingClientRect(),g=H>d.left&&G<d.right&&I>d.top-1&&F<d.bottom+1);return g},U=function(){var a,f,h,j,k,m,n,p,q,r,s,t,u=c.elements;if((o=d.loadMode)&&P<8&&(a=u.length)){for(f=0,Q++;f<a;f++)if(u[f]&&!u[f]._lazyRace)if(!M||c.prematureUnveil&&c.prematureUnveil(u[f]))aa(u[f]);else if((p=u[f][i]("data-expand"))&&(m=1*p)||(m=O),r||(r=!d.expand||d.expand<1?e.clientHeight>500&&e.clientWidth>500?500:370:d.expand,c._defEx=r,s=r*d.expFactor,t=d.hFac,J=null,O<s&&P<1&&Q>2&&o>2&&!b.hidden?(O=s,Q=0):O=o>1&&Q>1&&P<6?r:N),q!==m&&(y=innerWidth+m*t,D=innerHeight+m,n=-1*m,q=m),h=u[f].getBoundingClientRect(),(I=h.bottom)>=n&&(F=h.top)<=D&&(H=h.right)>=n*t&&(G=h.left)<=y&&(I||H||G||F)&&(d.loadHidden||S(u[f]))&&(l&&P<3&&!p&&(o<3||Q<4)||T(u[f],m))){if(aa(u[f]),k=!0,P>9)break}else!k&&l&&!j&&P<4&&Q<4&&o>2&&(g[0]||d.preloadAfterLoad)&&(g[0]||!p&&(I||H||G||F||"auto"!=u[f][i](d.sizesAttr)))&&(j=g[0]||u[f]);j&&!k&&aa(j)}},V=B(U),W=function(a){var b=a.target;if(b._lazyCache)return void delete b._lazyCache;R(a),s(b,d.loadedClass),t(b,d.loadingClass),u(b,Y),v(b,"lazyloaded")},X=A(W),Y=function(a){X({target:a.target})},Z=function(a,b){try{a.contentWindow.location.replace(b)}catch(c){a.src=b}},$=function(a){var b,c=a[i](d.srcsetAttr);(b=d.customMedia[a[i]("data-media")||a[i]("media")])&&a.setAttribute("media",b),c&&a.setAttribute("srcset",c)},_=A(function(a,b,c,e,f){var g,h,j,l,o,p;(o=v(a,"lazybeforeunveil",b)).defaultPrevented||(e&&(c?s(a,d.autosizesClass):a.setAttribute("sizes",e)),h=a[i](d.srcsetAttr),g=a[i](d.srcAttr),f&&(j=a.parentNode,l=j&&n.test(j.nodeName||"")),p=b.firesLoad||"src"in a&&(h||g||l),o={target:a},s(a,d.loadingClass),p&&(clearTimeout(m),m=k(R,2500),u(a,Y,!0)),l&&q.call(j.getElementsByTagName("source"),$),h?a.setAttribute("srcset",h):g&&!l&&(L.test(a.nodeName)?Z(a,g):a.src=g),f&&(h||l)&&w(a,{src:g})),a._lazyRace&&delete a._lazyRace,t(a,d.lazyClass),z(function(){var b=a.complete&&a.naturalWidth>1;p&&!b||(b&&s(a,"ls-is-cached"),W(o),a._lazyCache=!0,k(function(){"_lazyCache"in a&&delete a._lazyCache},9)),"lazy"==a.loading&&P--},!0)}),aa=function(a){if(!a._lazyRace){var b,c=K.test(a.nodeName),e=c&&(a[i](d.sizesAttr)||a[i]("sizes")),f="auto"==e;(!f&&l||!c||!a[i]("src")&&!a.srcset||a.complete||r(a,d.errorClass)||!r(a,d.lazyClass))&&(b=v(a,"lazyunveilread").detail,f&&E.updateElem(a,!0,a.offsetWidth),a._lazyRace=!0,P++,_(a,b,f,e,c))}},ba=C(function(){d.loadMode=3,V()}),ca=function(){3==d.loadMode&&(d.loadMode=2),ba()},da=function(){if(!l){if(f.now()-p<999)return void k(da,999);l=!0,d.loadMode=3,V(),j("scroll",ca,!0)}};return{_:function(){p=f.now(),c.elements=b.getElementsByClassName(d.lazyClass),g=b.getElementsByClassName(d.lazyClass+" "+d.preloadClass),j("scroll",V,!0),j("resize",V,!0),a.MutationObserver?new MutationObserver(V).observe(e,{childList:!0,subtree:!0,attributes:!0}):(e[h]("DOMNodeInserted",V,!0),e[h]("DOMAttrModified",V,!0),setInterval(V,999)),j("hashchange",V,!0),["focus","mouseover","click","load","transitionend","animationend"].forEach(function(a){b[h](a,V,!0)}),/d$|^c/.test(b.readyState)?da():(j("load",da),b[h]("DOMContentLoaded",V),k(da,2e4)),c.elements.length?(U(),z._lsFlush()):V()},checkElems:V,unveil:aa,_aLSL:ca}}(),E=function(){var a,c=A(function(a,b,c,d){var e,f,g;if(a._lazysizesWidth=d,d+="px",a.setAttribute("sizes",d),n.test(b.nodeName||""))for(e=b.getElementsByTagName("source"),f=0,g=e.length;f<g;f++)e[f].setAttribute("sizes",d);c.detail.dataAttr||w(a,c.detail)}),e=function(a,b,d){var e,f=a.parentNode;f&&(d=y(a,f,d),e=v(a,"lazybeforesizes",{width:d,dataAttr:!!b}),e.defaultPrevented||(d=e.detail.width)&&d!==a._lazysizesWidth&&c(a,f,e,d))},f=function(){var b,c=a.length;if(c)for(b=0;b<c;b++)e(a[b])},g=C(f);return{_:function(){a=b.getElementsByClassName(d.autosizesClass),j("resize",g)},checkElems:g,updateElem:e}}(),F=function(){!F.i&&b.getElementsByClassName&&(F.i=!0,E._(),D._())};return k(function(){d.init&&F()}),c={cfg:d,autoSizer:E,loader:D,init:F,uP:w,aC:s,rC:t,hC:r,fire:v,gW:y,rAF:z}});

!function(a,b){var c=function(){b(a.lazySizes),a.removeEventListener("lazyunveilread",c,!0)};b=b.bind(null,a,a.document),"object"==typeof module&&module.exports?b(require("lazysizes")):a.lazySizes?c():a.addEventListener("lazyunveilread",c,!0)}(window,function(a,b,c){"use strict";function d(a,c){if(!g[a]){var d=b.createElement(c?"link":"script"),e=b.getElementsByTagName("script")[0];c?(d.rel="stylesheet",d.href=a):d.src=a,g[a]=!0,g[d.src||d.href]=!0,e.parentNode.insertBefore(d,e)}}var e,f,g={};b.addEventListener&&(f=/\(|\)|\s|'/,e=function(a,c){var d=b.createElement("img");d.onload=function(){d.onload=null,d.onerror=null,d=null,c()},d.onerror=d.onload,d.src=a,d&&d.complete&&d.onload&&d.onload()},addEventListener("lazybeforeunveil",function(a){if(a.detail.instance==c){var b,g,h,i;if(!a.defaultPrevented){var j=a.target;if("none"==j.preload&&(j.preload="auto"),null!=j.getAttribute("data-autoplay"))if(j.getAttribute("data-expand")&&!j.autoplay)try{j.play()}catch(a){}else requestAnimationFrame(function(){j.setAttribute("data-expand","-10"),c.aC(j,c.cfg.lazyClass)});b=j.getAttribute("data-link"),b&&d(b,!0),b=j.getAttribute("data-script"),b&&d(b),b=j.getAttribute("data-require"),b&&(c.cfg.requireJs?c.cfg.requireJs([b]):d(b)),h=j.getAttribute("data-bg"),h&&(a.detail.firesLoad=!0,g=function(){j.style.backgroundImage="url("+(f.test(h)?JSON.stringify(h):h)+")",a.detail.firesLoad=!1,c.fire(j,"_lazyloaded",{},!0,!0)},e(h,g)),i=j.getAttribute("data-poster"),i&&(a.detail.firesLoad=!0,g=function(){j.poster=i,a.detail.firesLoad=!1,c.fire(j,"_lazyloaded",{},!0,!0)},e(i,g))}}},!1))});

// Copyright 2014 Google Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
//     You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//     See the License for the specific language governing permissions and
// limitations under the License.

!function(){var a={},b={};!function(a,b){function c(a){if("number"==typeof a)return a;var b={};for(var c in a)b[c]=a[c];return b}function d(){this._delay=0,this._endDelay=0,this._fill="none",this._iterationStart=0,this._iterations=1,this._duration=0,this._playbackRate=1,this._direction="normal",this._easing="linear",this._easingFunction=x}function e(){return a.isDeprecated("Invalid timing inputs","2016-03-02","TypeError exceptions will be thrown instead.",!0)}function f(b,c,e){var f=new d;return c&&(f.fill="both",f.duration="auto"),"number"!=typeof b||isNaN(b)?void 0!==b&&Object.getOwnPropertyNames(b).forEach(function(c){if("auto"!=b[c]){if(("number"==typeof f[c]||"duration"==c)&&("number"!=typeof b[c]||isNaN(b[c])))return;if("fill"==c&&-1==v.indexOf(b[c]))return;if("direction"==c&&-1==w.indexOf(b[c]))return;if("playbackRate"==c&&1!==b[c]&&a.isDeprecated("AnimationEffectTiming.playbackRate","2014-11-28","Use Animation.playbackRate instead."))return;f[c]=b[c]}}):f.duration=b,f}function g(a){return"number"==typeof a&&(a=isNaN(a)?{duration:0}:{duration:a}),a}function h(b,c){return b=a.numericTimingToObject(b),f(b,c)}function i(a,b,c,d){return a<0||a>1||c<0||c>1?x:function(e){function f(a,b,c){return 3*a*(1-c)*(1-c)*c+3*b*(1-c)*c*c+c*c*c}if(e<=0){var g=0;return a>0?g=b/a:!b&&c>0&&(g=d/c),g*e}if(e>=1){var h=0;return c<1?h=(d-1)/(c-1):1==c&&a<1&&(h=(b-1)/(a-1)),1+h*(e-1)}for(var i=0,j=1;i<j;){var k=(i+j)/2,l=f(a,c,k);if(Math.abs(e-l)<1e-5)return f(b,d,k);l<e?i=k:j=k}return f(b,d,k)}}function j(a,b){return function(c){if(c>=1)return 1;var d=1/a;return(c+=b*d)-c%d}}function k(a){C||(C=document.createElement("div").style),C.animationTimingFunction="",C.animationTimingFunction=a;var b=C.animationTimingFunction;if(""==b&&e())throw new TypeError(a+" is not a valid value for easing");return b}function l(a){if("linear"==a)return x;var b=E.exec(a);if(b)return i.apply(this,b.slice(1).map(Number));var c=F.exec(a);if(c)return j(Number(c[1]),A);var d=G.exec(a);return d?j(Number(d[1]),{start:y,middle:z,end:A}[d[2]]):B[a]||x}function m(a){return Math.abs(n(a)/a.playbackRate)}function n(a){return 0===a.duration||0===a.iterations?0:a.duration*a.iterations}function o(a,b,c){if(null==b)return H;var d=c.delay+a+c.endDelay;return b<Math.min(c.delay,d)?I:b>=Math.min(c.delay+a,d)?J:K}function p(a,b,c,d,e){switch(d){case I:return"backwards"==b||"both"==b?0:null;case K:return c-e;case J:return"forwards"==b||"both"==b?a:null;case H:return null}}function q(a,b,c,d,e){var f=e;return 0===a?b!==I&&(f+=c):f+=d/a,f}function r(a,b,c,d,e,f){var g=a===1/0?b%1:a%1;return 0!==g||c!==J||0===d||0===e&&0!==f||(g=1),g}function s(a,b,c,d){return a===J&&b===1/0?1/0:1===c?Math.floor(d)-1:Math.floor(d)}function t(a,b,c){var d=a;if("normal"!==a&&"reverse"!==a){var e=b;"alternate-reverse"===a&&(e+=1),d="normal",e!==1/0&&e%2!=0&&(d="reverse")}return"normal"===d?c:1-c}function u(a,b,c){var d=o(a,b,c),e=p(a,c.fill,b,d,c.delay);if(null===e)return null;var f=q(c.duration,d,c.iterations,e,c.iterationStart),g=r(f,c.iterationStart,d,c.iterations,e,c.duration),h=s(d,c.iterations,g,f),i=t(c.direction,h,g);return c._easingFunction(i)}var v="backwards|forwards|both|none".split("|"),w="reverse|alternate|alternate-reverse".split("|"),x=function(a){return a};d.prototype={_setMember:function(b,c){this["_"+b]=c,this._effect&&(this._effect._timingInput[b]=c,this._effect._timing=a.normalizeTimingInput(this._effect._timingInput),this._effect.activeDuration=a.calculateActiveDuration(this._effect._timing),this._effect._animation&&this._effect._animation._rebuildUnderlyingAnimation())},get playbackRate(){return this._playbackRate},set delay(a){this._setMember("delay",a)},get delay(){return this._delay},set endDelay(a){this._setMember("endDelay",a)},get endDelay(){return this._endDelay},set fill(a){this._setMember("fill",a)},get fill(){return this._fill},set iterationStart(a){if((isNaN(a)||a<0)&&e())throw new TypeError("iterationStart must be a non-negative number, received: "+a);this._setMember("iterationStart",a)},get iterationStart(){return this._iterationStart},set duration(a){if("auto"!=a&&(isNaN(a)||a<0)&&e())throw new TypeError("duration must be non-negative or auto, received: "+a);this._setMember("duration",a)},get duration(){return this._duration},set direction(a){this._setMember("direction",a)},get direction(){return this._direction},set easing(a){this._easingFunction=l(k(a)),this._setMember("easing",a)},get easing(){return this._easing},set iterations(a){if((isNaN(a)||a<0)&&e())throw new TypeError("iterations must be non-negative, received: "+a);this._setMember("iterations",a)},get iterations(){return this._iterations}};var y=1,z=.5,A=0,B={ease:i(.25,.1,.25,1),"ease-in":i(.42,0,1,1),"ease-out":i(0,0,.58,1),"ease-in-out":i(.42,0,.58,1),"step-start":j(1,y),"step-middle":j(1,z),"step-end":j(1,A)},C=null,D="\\s*(-?\\d+\\.?\\d*|-?\\.\\d+)\\s*",E=new RegExp("cubic-bezier\\("+D+","+D+","+D+","+D+"\\)"),F=/steps\(\s*(\d+)\s*\)/,G=/steps\(\s*(\d+)\s*,\s*(start|middle|end)\s*\)/,H=0,I=1,J=2,K=3;a.cloneTimingInput=c,a.makeTiming=f,a.numericTimingToObject=g,a.normalizeTimingInput=h,a.calculateActiveDuration=m,a.calculateIterationProgress=u,a.calculatePhase=o,a.normalizeEasing=k,a.parseEasingFunction=l}(a),function(a,b){function c(a,b){return a in k?k[a][b]||b:b}function d(a){return"display"===a||0===a.lastIndexOf("animation",0)||0===a.lastIndexOf("transition",0)}function e(a,b,e){if(!d(a)){var f=h[a];if(f){i.style[a]=b;for(var g in f){var j=f[g],k=i.style[j];e[j]=c(j,k)}}else e[a]=c(a,b)}}function f(a){var b=[];for(var c in a)if(!(c in["easing","offset","composite"])){var d=a[c];Array.isArray(d)||(d=[d]);for(var e,f=d.length,g=0;g<f;g++)e={},e.offset="offset"in a?a.offset:1==f?1:g/(f-1),"easing"in a&&(e.easing=a.easing),"composite"in a&&(e.composite=a.composite),e[c]=d[g],b.push(e)}return b.sort(function(a,b){return a.offset-b.offset}),b}function g(b){function c(){var a=d.length;null==d[a-1].offset&&(d[a-1].offset=1),a>1&&null==d[0].offset&&(d[0].offset=0);for(var b=0,c=d[0].offset,e=1;e<a;e++){var f=d[e].offset;if(null!=f){for(var g=1;g<e-b;g++)d[b+g].offset=c+(f-c)*g/(e-b);b=e,c=f}}}if(null==b)return[];window.Symbol&&Symbol.iterator&&Array.prototype.from&&b[Symbol.iterator]&&(b=Array.from(b)),Array.isArray(b)||(b=f(b));for(var d=b.map(function(b){var c={};for(var d in b){var f=b[d];if("offset"==d){if(null!=f){if(f=Number(f),!isFinite(f))throw new TypeError("Keyframe offsets must be numbers.");if(f<0||f>1)throw new TypeError("Keyframe offsets must be between 0 and 1.")}}else if("composite"==d){if("add"==f||"accumulate"==f)throw{type:DOMException.NOT_SUPPORTED_ERR,name:"NotSupportedError",message:"add compositing is not supported"};if("replace"!=f)throw new TypeError("Invalid composite mode "+f+".")}else f="easing"==d?a.normalizeEasing(f):""+f;e(d,f,c)}return void 0==c.offset&&(c.offset=null),void 0==c.easing&&(c.easing="linear"),c}),g=!0,h=-1/0,i=0;i<d.length;i++){var j=d[i].offset;if(null!=j){if(j<h)throw new TypeError("Keyframes are not loosely sorted by offset. Sort or specify offsets.");h=j}else g=!1}return d=d.filter(function(a){return a.offset>=0&&a.offset<=1}),g||c(),d}var h={background:["backgroundImage","backgroundPosition","backgroundSize","backgroundRepeat","backgroundAttachment","backgroundOrigin","backgroundClip","backgroundColor"],border:["borderTopColor","borderTopStyle","borderTopWidth","borderRightColor","borderRightStyle","borderRightWidth","borderBottomColor","borderBottomStyle","borderBottomWidth","borderLeftColor","borderLeftStyle","borderLeftWidth"],borderBottom:["borderBottomWidth","borderBottomStyle","borderBottomColor"],borderColor:["borderTopColor","borderRightColor","borderBottomColor","borderLeftColor"],borderLeft:["borderLeftWidth","borderLeftStyle","borderLeftColor"],borderRadius:["borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius"],borderRight:["borderRightWidth","borderRightStyle","borderRightColor"],borderTop:["borderTopWidth","borderTopStyle","borderTopColor"],borderWidth:["borderTopWidth","borderRightWidth","borderBottomWidth","borderLeftWidth"],flex:["flexGrow","flexShrink","flexBasis"],font:["fontFamily","fontSize","fontStyle","fontVariant","fontWeight","lineHeight"],margin:["marginTop","marginRight","marginBottom","marginLeft"],outline:["outlineColor","outlineStyle","outlineWidth"],padding:["paddingTop","paddingRight","paddingBottom","paddingLeft"]},i=document.createElementNS("http://www.w3.org/1999/xhtml","div"),j={thin:"1px",medium:"3px",thick:"5px"},k={borderBottomWidth:j,borderLeftWidth:j,borderRightWidth:j,borderTopWidth:j,fontSize:{"xx-small":"60%","x-small":"75%",small:"89%",medium:"100%",large:"120%","x-large":"150%","xx-large":"200%"},fontWeight:{normal:"400",bold:"700"},outlineWidth:j,textShadow:{none:"0px 0px 0px transparent"},boxShadow:{none:"0px 0px 0px 0px transparent"}};a.convertToArrayForm=f,a.normalizeKeyframes=g}(a),function(a){var b={};a.isDeprecated=function(a,c,d,e){var f=e?"are":"is",g=new Date,h=new Date(c);return h.setMonth(h.getMonth()+3),!(g<h&&(a in b||console.warn("Web Animations: "+a+" "+f+" deprecated and will stop working on "+h.toDateString()+". "+d),b[a]=!0,1))},a.deprecated=function(b,c,d,e){var f=e?"are":"is";if(a.isDeprecated(b,c,d,e))throw new Error(b+" "+f+" no longer supported. "+d)}}(a),function(){if(document.documentElement.animate){var c=document.documentElement.animate([],0),d=!0;if(c&&(d=!1,"play|currentTime|pause|reverse|playbackRate|cancel|finish|startTime|playState".split("|").forEach(function(a){void 0===c[a]&&(d=!0)})),!d)return}!function(a,b,c){function d(a){for(var b={},c=0;c<a.length;c++)for(var d in a[c])if("offset"!=d&&"easing"!=d&&"composite"!=d){var e={offset:a[c].offset,easing:a[c].easing,value:a[c][d]};b[d]=b[d]||[],b[d].push(e)}for(var f in b){var g=b[f];if(0!=g[0].offset||1!=g[g.length-1].offset)throw{type:DOMException.NOT_SUPPORTED_ERR,name:"NotSupportedError",message:"Partial keyframes are not supported"}}return b}function e(c){var d=[];for(var e in c)for(var f=c[e],g=0;g<f.length-1;g++){var h=g,i=g+1,j=f[h].offset,k=f[i].offset,l=j,m=k;0==g&&(l=-1/0,0==k&&(i=h)),g==f.length-2&&(m=1/0,1==j&&(h=i)),d.push({applyFrom:l,applyTo:m,startOffset:f[h].offset,endOffset:f[i].offset,easingFunction:a.parseEasingFunction(f[h].easing),property:e,interpolation:b.propertyInterpolation(e,f[h].value,f[i].value)})}return d.sort(function(a,b){return a.startOffset-b.startOffset}),d}b.convertEffectInput=function(c){var f=a.normalizeKeyframes(c),g=d(f),h=e(g);return function(a,c){if(null!=c)h.filter(function(a){return c>=a.applyFrom&&c<a.applyTo}).forEach(function(d){var e=c-d.startOffset,f=d.endOffset-d.startOffset,g=0==f?0:d.easingFunction(e/f);b.apply(a,d.property,d.interpolation(g))});else for(var d in g)"offset"!=d&&"easing"!=d&&"composite"!=d&&b.clear(a,d)}}}(a,b),function(a,b,c){function d(a){return a.replace(/-(.)/g,function(a,b){return b.toUpperCase()})}function e(a,b,c){h[c]=h[c]||[],h[c].push([a,b])}function f(a,b,c){for(var f=0;f<c.length;f++){e(a,b,d(c[f]))}}function g(c,e,f){var g=c;/-/.test(c)&&!a.isDeprecated("Hyphenated property names","2016-03-22","Use camelCase instead.",!0)&&(g=d(c)),"initial"!=e&&"initial"!=f||("initial"==e&&(e=i[g]),"initial"==f&&(f=i[g]));for(var j=e==f?[]:h[g],k=0;j&&k<j.length;k++){var l=j[k][0](e),m=j[k][0](f);if(void 0!==l&&void 0!==m){var n=j[k][1](l,m);if(n){var o=b.Interpolation.apply(null,n);return function(a){return 0==a?e:1==a?f:o(a)}}}}return b.Interpolation(!1,!0,function(a){return a?f:e})}var h={};b.addPropertiesHandler=f;var i={backgroundColor:"transparent",backgroundPosition:"0% 0%",borderBottomColor:"currentColor",borderBottomLeftRadius:"0px",borderBottomRightRadius:"0px",borderBottomWidth:"3px",borderLeftColor:"currentColor",borderLeftWidth:"3px",borderRightColor:"currentColor",borderRightWidth:"3px",borderSpacing:"2px",borderTopColor:"currentColor",borderTopLeftRadius:"0px",borderTopRightRadius:"0px",borderTopWidth:"3px",bottom:"auto",clip:"rect(0px, 0px, 0px, 0px)",color:"black",fontSize:"100%",fontWeight:"400",height:"auto",left:"auto",letterSpacing:"normal",lineHeight:"120%",marginBottom:"0px",marginLeft:"0px",marginRight:"0px",marginTop:"0px",maxHeight:"none",maxWidth:"none",minHeight:"0px",minWidth:"0px",opacity:"1.0",outlineColor:"invert",outlineOffset:"0px",outlineWidth:"3px",paddingBottom:"0px",paddingLeft:"0px",paddingRight:"0px",paddingTop:"0px",right:"auto",strokeDasharray:"none",strokeDashoffset:"0px",textIndent:"0px",textShadow:"0px 0px 0px transparent",top:"auto",transform:"",verticalAlign:"0px",visibility:"visible",width:"auto",wordSpacing:"normal",zIndex:"auto"};b.propertyInterpolation=g}(a,b),function(a,b,c){function d(b){var c=a.calculateActiveDuration(b),d=function(d){return a.calculateIterationProgress(c,d,b)};return d._totalDuration=b.delay+c+b.endDelay,d}b.KeyframeEffect=function(c,e,f,g){var h,i=d(a.normalizeTimingInput(f)),j=b.convertEffectInput(e),k=function(){j(c,h)};return k._update=function(a){return null!==(h=i(a))},k._clear=function(){j(c,null)},k._hasSameTarget=function(a){return c===a},k._target=c,k._totalDuration=i._totalDuration,k._id=g,k}}(a,b),function(a,b){function c(a,b){return!(!b.namespaceURI||-1==b.namespaceURI.indexOf("/svg"))&&(g in a||(a[g]=/Trident|MSIE|IEMobile|Edge|Android 4/i.test(a.navigator.userAgent)),a[g])}function d(a,b,c){c.enumerable=!0,c.configurable=!0,Object.defineProperty(a,b,c)}function e(a){this._element=a,this._surrogateStyle=document.createElementNS("http://www.w3.org/1999/xhtml","div").style,this._style=a.style,this._length=0,this._isAnimatedProperty={},this._updateSvgTransformAttr=c(window,a),this._savedTransformAttr=null;for(var b=0;b<this._style.length;b++){var d=this._style[b];this._surrogateStyle[d]=this._style[d]}this._updateIndices()}function f(a){if(!a._webAnimationsPatchedStyle){var b=new e(a);try{d(a,"style",{get:function(){return b}})}catch(b){a.style._set=function(b,c){a.style[b]=c},a.style._clear=function(b){a.style[b]=""}}a._webAnimationsPatchedStyle=a.style}}var g="_webAnimationsUpdateSvgTransformAttr",h={cssText:1,length:1,parentRule:1},i={getPropertyCSSValue:1,getPropertyPriority:1,getPropertyValue:1,item:1,removeProperty:1,setProperty:1},j={removeProperty:1,setProperty:1};e.prototype={get cssText(){return this._surrogateStyle.cssText},set cssText(a){for(var b={},c=0;c<this._surrogateStyle.length;c++)b[this._surrogateStyle[c]]=!0;this._surrogateStyle.cssText=a,this._updateIndices();for(var c=0;c<this._surrogateStyle.length;c++)b[this._surrogateStyle[c]]=!0;for(var d in b)this._isAnimatedProperty[d]||this._style.setProperty(d,this._surrogateStyle.getPropertyValue(d))},get length(){return this._surrogateStyle.length},get parentRule(){return this._style.parentRule},_updateIndices:function(){for(;this._length<this._surrogateStyle.length;)Object.defineProperty(this,this._length,{configurable:!0,enumerable:!1,get:function(a){return function(){return this._surrogateStyle[a]}}(this._length)}),this._length++;for(;this._length>this._surrogateStyle.length;)this._length--,Object.defineProperty(this,this._length,{configurable:!0,enumerable:!1,value:void 0})},_set:function(b,c){this._style[b]=c,this._isAnimatedProperty[b]=!0,this._updateSvgTransformAttr&&"transform"==a.unprefixedPropertyName(b)&&(null==this._savedTransformAttr&&(this._savedTransformAttr=this._element.getAttribute("transform")),this._element.setAttribute("transform",a.transformToSvgMatrix(c)))},_clear:function(b){this._style[b]=this._surrogateStyle[b],this._updateSvgTransformAttr&&"transform"==a.unprefixedPropertyName(b)&&(this._savedTransformAttr?this._element.setAttribute("transform",this._savedTransformAttr):this._element.removeAttribute("transform"),this._savedTransformAttr=null),delete this._isAnimatedProperty[b]}};for(var k in i)e.prototype[k]=function(a,b){return function(){var c=this._surrogateStyle[a].apply(this._surrogateStyle,arguments);return b&&(this._isAnimatedProperty[arguments[0]]||this._style[a].apply(this._style,arguments),this._updateIndices()),c}}(k,k in j);for(var l in document.documentElement.style)l in h||l in i||function(a){d(e.prototype,a,{get:function(){return this._surrogateStyle[a]},set:function(b){this._surrogateStyle[a]=b,this._updateIndices(),this._isAnimatedProperty[a]||(this._style[a]=b)}})}(l);a.apply=function(b,c,d){f(b),b.style._set(a.propertyName(c),d)},a.clear=function(b,c){b._webAnimationsPatchedStyle&&b.style._clear(a.propertyName(c))}}(b),function(a){window.Element.prototype.animate=function(b,c){var d="";return c&&c.id&&(d=c.id),a.timeline._play(a.KeyframeEffect(this,b,c,d))}}(b),function(a,b){function c(a,b,d){if("number"==typeof a&&"number"==typeof b)return a*(1-d)+b*d;if("boolean"==typeof a&&"boolean"==typeof b)return d<.5?a:b;if(a.length==b.length){for(var e=[],f=0;f<a.length;f++)e.push(c(a[f],b[f],d));return e}throw"Mismatched interpolation arguments "+a+":"+b}a.Interpolation=function(a,b,d){return function(e){return d(c(a,b,e))}}}(b),function(a,b){function c(a,b,c){return Math.max(Math.min(a,c),b)}function d(b,d,e){var f=a.dot(b,d);f=c(f,-1,1);var g=[];if(1===f)g=b;else for(var h=Math.acos(f),i=1*Math.sin(e*h)/Math.sqrt(1-f*f),j=0;j<4;j++)g.push(b[j]*(Math.cos(e*h)-f*i)+d[j]*i);return g}var e=function(){function a(a,b){for(var c=[[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]],d=0;d<4;d++)for(var e=0;e<4;e++)for(var f=0;f<4;f++)c[d][e]+=b[d][f]*a[f][e];return c}function b(a){return 0==a[0][2]&&0==a[0][3]&&0==a[1][2]&&0==a[1][3]&&0==a[2][0]&&0==a[2][1]&&1==a[2][2]&&0==a[2][3]&&0==a[3][2]&&1==a[3][3]}function c(c,d,e,f,g){for(var h=[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]],i=0;i<4;i++)h[i][3]=g[i];for(var i=0;i<3;i++)for(var j=0;j<3;j++)h[3][i]+=c[j]*h[j][i];var k=f[0],l=f[1],m=f[2],n=f[3],o=[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]];o[0][0]=1-2*(l*l+m*m),o[0][1]=2*(k*l-m*n),o[0][2]=2*(k*m+l*n),o[1][0]=2*(k*l+m*n),o[1][1]=1-2*(k*k+m*m),o[1][2]=2*(l*m-k*n),o[2][0]=2*(k*m-l*n),o[2][1]=2*(l*m+k*n),o[2][2]=1-2*(k*k+l*l),h=a(h,o);var p=[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]];e[2]&&(p[2][1]=e[2],h=a(h,p)),e[1]&&(p[2][1]=0,p[2][0]=e[0],h=a(h,p)),e[0]&&(p[2][0]=0,p[1][0]=e[0],h=a(h,p));for(var i=0;i<3;i++)for(var j=0;j<3;j++)h[i][j]*=d[i];return b(h)?[h[0][0],h[0][1],h[1][0],h[1][1],h[3][0],h[3][1]]:h[0].concat(h[1],h[2],h[3])}return c}();a.composeMatrix=e,a.quat=d}(b),function(a,b,c){a.sequenceNumber=0;var d=function(a,b,c){this.target=a,this.currentTime=b,this.timelineTime=c,this.type="finish",this.bubbles=!1,this.cancelable=!1,this.currentTarget=a,this.defaultPrevented=!1,this.eventPhase=Event.AT_TARGET,this.timeStamp=Date.now()};b.Animation=function(b){this.id="",b&&b._id&&(this.id=b._id),this._sequenceNumber=a.sequenceNumber++,this._currentTime=0,this._startTime=null,this._paused=!1,this._playbackRate=1,this._inTimeline=!0,this._finishedFlag=!0,this.onfinish=null,this._finishHandlers=[],this._effect=b,this._inEffect=this._effect._update(0),this._idle=!0,this._currentTimePending=!1},b.Animation.prototype={_ensureAlive:function(){this.playbackRate<0&&0===this.currentTime?this._inEffect=this._effect._update(-1):this._inEffect=this._effect._update(this.currentTime),this._inTimeline||!this._inEffect&&this._finishedFlag||(this._inTimeline=!0,b.timeline._animations.push(this))},_tickCurrentTime:function(a,b){a!=this._currentTime&&(this._currentTime=a,this._isFinished&&!b&&(this._currentTime=this._playbackRate>0?this._totalDuration:0),this._ensureAlive())},get currentTime(){return this._idle||this._currentTimePending?null:this._currentTime},set currentTime(a){a=+a,isNaN(a)||(b.restart(),this._paused||null==this._startTime||(this._startTime=this._timeline.currentTime-a/this._playbackRate),this._currentTimePending=!1,this._currentTime!=a&&(this._idle&&(this._idle=!1,this._paused=!0),this._tickCurrentTime(a,!0),b.applyDirtiedAnimation(this)))},get startTime(){return this._startTime},set startTime(a){a=+a,isNaN(a)||this._paused||this._idle||(this._startTime=a,this._tickCurrentTime((this._timeline.currentTime-this._startTime)*this.playbackRate),b.applyDirtiedAnimation(this))},get playbackRate(){return this._playbackRate},set playbackRate(a){if(a!=this._playbackRate){var c=this.currentTime;this._playbackRate=a,this._startTime=null,"paused"!=this.playState&&"idle"!=this.playState&&(this._finishedFlag=!1,this._idle=!1,this._ensureAlive(),b.applyDirtiedAnimation(this)),null!=c&&(this.currentTime=c)}},get _isFinished(){return!this._idle&&(this._playbackRate>0&&this._currentTime>=this._totalDuration||this._playbackRate<0&&this._currentTime<=0)},get _totalDuration(){return this._effect._totalDuration},get playState(){return this._idle?"idle":null==this._startTime&&!this._paused&&0!=this.playbackRate||this._currentTimePending?"pending":this._paused?"paused":this._isFinished?"finished":"running"},_rewind:function(){if(this._playbackRate>=0)this._currentTime=0;else{if(!(this._totalDuration<1/0))throw new DOMException("Unable to rewind negative playback rate animation with infinite duration","InvalidStateError");this._currentTime=this._totalDuration}},play:function(){this._paused=!1,(this._isFinished||this._idle)&&(this._rewind(),this._startTime=null),this._finishedFlag=!1,this._idle=!1,this._ensureAlive(),b.applyDirtiedAnimation(this)},pause:function(){this._isFinished||this._paused||this._idle?this._idle&&(this._rewind(),this._idle=!1):this._currentTimePending=!0,this._startTime=null,this._paused=!0},finish:function(){this._idle||(this.currentTime=this._playbackRate>0?this._totalDuration:0,this._startTime=this._totalDuration-this.currentTime,this._currentTimePending=!1,b.applyDirtiedAnimation(this))},cancel:function(){this._inEffect&&(this._inEffect=!1,this._idle=!0,this._paused=!1,this._finishedFlag=!0,this._currentTime=0,this._startTime=null,this._effect._update(null),b.applyDirtiedAnimation(this))},reverse:function(){this.playbackRate*=-1,this.play()},addEventListener:function(a,b){"function"==typeof b&&"finish"==a&&this._finishHandlers.push(b)},removeEventListener:function(a,b){if("finish"==a){var c=this._finishHandlers.indexOf(b);c>=0&&this._finishHandlers.splice(c,1)}},_fireEvents:function(a){if(this._isFinished){if(!this._finishedFlag){var b=new d(this,this._currentTime,a),c=this._finishHandlers.concat(this.onfinish?[this.onfinish]:[]);setTimeout(function(){c.forEach(function(a){a.call(b.target,b)})},0),this._finishedFlag=!0}}else this._finishedFlag=!1},_tick:function(a,b){this._idle||this._paused||(null==this._startTime?b&&(this.startTime=a-this._currentTime/this.playbackRate):this._isFinished||this._tickCurrentTime((a-this._startTime)*this.playbackRate)),b&&(this._currentTimePending=!1,this._fireEvents(a))},get _needsTick(){return this.playState in{pending:1,running:1}||!this._finishedFlag},_targetAnimations:function(){var a=this._effect._target;return a._activeAnimations||(a._activeAnimations=[]),a._activeAnimations},_markTarget:function(){var a=this._targetAnimations();-1===a.indexOf(this)&&a.push(this)},_unmarkTarget:function(){var a=this._targetAnimations(),b=a.indexOf(this);-1!==b&&a.splice(b,1)}}}(a,b),function(a,b,c){function d(a){var b=j;j=[],a<q.currentTime&&(a=q.currentTime),q._animations.sort(e),q._animations=h(a,!0,q._animations)[0],b.forEach(function(b){b[1](a)}),g(),l=void 0}function e(a,b){return a._sequenceNumber-b._sequenceNumber}function f(){this._animations=[],this.currentTime=window.performance&&performance.now?performance.now():0}function g(){o.forEach(function(a){a()}),o.length=0}function h(a,c,d){p=!0,n=!1,b.timeline.currentTime=a,m=!1;var e=[],f=[],g=[],h=[];return d.forEach(function(b){b._tick(a,c),b._inEffect?(f.push(b._effect),b._markTarget()):(e.push(b._effect),b._unmarkTarget()),b._needsTick&&(m=!0);var d=b._inEffect||b._needsTick;b._inTimeline=d,d?g.push(b):h.push(b)}),o.push.apply(o,e),o.push.apply(o,f),m&&requestAnimationFrame(function(){}),p=!1,[g,h]}var i=window.requestAnimationFrame,j=[],k=0;window.requestAnimationFrame=function(a){var b=k++;return 0==j.length&&i(d),j.push([b,a]),b},window.cancelAnimationFrame=function(a){j.forEach(function(b){b[0]==a&&(b[1]=function(){})})},f.prototype={_play:function(c){c._timing=a.normalizeTimingInput(c.timing);var d=new b.Animation(c);return d._idle=!1,d._timeline=this,this._animations.push(d),b.restart(),b.applyDirtiedAnimation(d),d}};var l=void 0,m=!1,n=!1;b.restart=function(){return m||(m=!0,requestAnimationFrame(function(){}),n=!0),n},b.applyDirtiedAnimation=function(a){if(!p){a._markTarget();var c=a._targetAnimations();c.sort(e),h(b.timeline.currentTime,!1,c.slice())[1].forEach(function(a){var b=q._animations.indexOf(a);-1!==b&&q._animations.splice(b,1)}),g()}};var o=[],p=!1,q=new f;b.timeline=q}(a,b),function(a,b){function c(a,b){for(var c=0,d=0;d<a.length;d++)c+=a[d]*b[d];return c}function d(a,b){return[a[0]*b[0]+a[4]*b[1]+a[8]*b[2]+a[12]*b[3],a[1]*b[0]+a[5]*b[1]+a[9]*b[2]+a[13]*b[3],a[2]*b[0]+a[6]*b[1]+a[10]*b[2]+a[14]*b[3],a[3]*b[0]+a[7]*b[1]+a[11]*b[2]+a[15]*b[3],a[0]*b[4]+a[4]*b[5]+a[8]*b[6]+a[12]*b[7],a[1]*b[4]+a[5]*b[5]+a[9]*b[6]+a[13]*b[7],a[2]*b[4]+a[6]*b[5]+a[10]*b[6]+a[14]*b[7],a[3]*b[4]+a[7]*b[5]+a[11]*b[6]+a[15]*b[7],a[0]*b[8]+a[4]*b[9]+a[8]*b[10]+a[12]*b[11],a[1]*b[8]+a[5]*b[9]+a[9]*b[10]+a[13]*b[11],a[2]*b[8]+a[6]*b[9]+a[10]*b[10]+a[14]*b[11],a[3]*b[8]+a[7]*b[9]+a[11]*b[10]+a[15]*b[11],a[0]*b[12]+a[4]*b[13]+a[8]*b[14]+a[12]*b[15],a[1]*b[12]+a[5]*b[13]+a[9]*b[14]+a[13]*b[15],a[2]*b[12]+a[6]*b[13]+a[10]*b[14]+a[14]*b[15],a[3]*b[12]+a[7]*b[13]+a[11]*b[14]+a[15]*b[15]]}function e(a){var b=a.rad||0;return((a.deg||0)/360+(a.grad||0)/400+(a.turn||0))*(2*Math.PI)+b}function f(a){switch(a.t){case"rotatex":var b=e(a.d[0]);return[1,0,0,0,0,Math.cos(b),Math.sin(b),0,0,-Math.sin(b),Math.cos(b),0,0,0,0,1];case"rotatey":var b=e(a.d[0]);return[Math.cos(b),0,-Math.sin(b),0,0,1,0,0,Math.sin(b),0,Math.cos(b),0,0,0,0,1];case"rotate":case"rotatez":var b=e(a.d[0]);return[Math.cos(b),Math.sin(b),0,0,-Math.sin(b),Math.cos(b),0,0,0,0,1,0,0,0,0,1];case"rotate3d":var c=a.d[0],d=a.d[1],f=a.d[2],b=e(a.d[3]),g=c*c+d*d+f*f;if(0===g)c=1,d=0,f=0;else if(1!==g){var h=Math.sqrt(g);c/=h,d/=h,f/=h}var i=Math.sin(b/2),j=i*Math.cos(b/2),k=i*i;return[1-2*(d*d+f*f)*k,2*(c*d*k+f*j),2*(c*f*k-d*j),0,2*(c*d*k-f*j),1-2*(c*c+f*f)*k,2*(d*f*k+c*j),0,2*(c*f*k+d*j),2*(d*f*k-c*j),1-2*(c*c+d*d)*k,0,0,0,0,1];case"scale":return[a.d[0],0,0,0,0,a.d[1],0,0,0,0,1,0,0,0,0,1];case"scalex":return[a.d[0],0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];case"scaley":return[1,0,0,0,0,a.d[0],0,0,0,0,1,0,0,0,0,1];case"scalez":return[1,0,0,0,0,1,0,0,0,0,a.d[0],0,0,0,0,1];case"scale3d":return[a.d[0],0,0,0,0,a.d[1],0,0,0,0,a.d[2],0,0,0,0,1];case"skew":var l=e(a.d[0]),m=e(a.d[1]);return[1,Math.tan(m),0,0,Math.tan(l),1,0,0,0,0,1,0,0,0,0,1];case"skewx":var b=e(a.d[0]);return[1,0,0,0,Math.tan(b),1,0,0,0,0,1,0,0,0,0,1];case"skewy":var b=e(a.d[0]);return[1,Math.tan(b),0,0,0,1,0,0,0,0,1,0,0,0,0,1];case"translate":var c=a.d[0].px||0,d=a.d[1].px||0;return[1,0,0,0,0,1,0,0,0,0,1,0,c,d,0,1];case"translatex":var c=a.d[0].px||0;return[1,0,0,0,0,1,0,0,0,0,1,0,c,0,0,1];case"translatey":var d=a.d[0].px||0;return[1,0,0,0,0,1,0,0,0,0,1,0,0,d,0,1];case"translatez":var f=a.d[0].px||0;return[1,0,0,0,0,1,0,0,0,0,1,0,0,0,f,1];case"translate3d":var c=a.d[0].px||0,d=a.d[1].px||0,f=a.d[2].px||0;return[1,0,0,0,0,1,0,0,0,0,1,0,c,d,f,1];case"perspective":return[1,0,0,0,0,1,0,0,0,0,1,a.d[0].px?-1/a.d[0].px:0,0,0,0,1];case"matrix":return[a.d[0],a.d[1],0,0,a.d[2],a.d[3],0,0,0,0,1,0,a.d[4],a.d[5],0,1];case"matrix3d":return a.d}}function g(a){return 0===a.length?[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]:a.map(f).reduce(d)}function h(a){return[i(g(a))]}var i=function(){function a(a){return a[0][0]*a[1][1]*a[2][2]+a[1][0]*a[2][1]*a[0][2]+a[2][0]*a[0][1]*a[1][2]-a[0][2]*a[1][1]*a[2][0]-a[1][2]*a[2][1]*a[0][0]-a[2][2]*a[0][1]*a[1][0]}function b(b){for(var c=1/a(b),d=b[0][0],e=b[0][1],f=b[0][2],g=b[1][0],h=b[1][1],i=b[1][2],j=b[2][0],k=b[2][1],l=b[2][2],m=[[(h*l-i*k)*c,(f*k-e*l)*c,(e*i-f*h)*c,0],[(i*j-g*l)*c,(d*l-f*j)*c,(f*g-d*i)*c,0],[(g*k-h*j)*c,(j*e-d*k)*c,(d*h-e*g)*c,0]],n=[],o=0;o<3;o++){for(var p=0,q=0;q<3;q++)p+=b[3][q]*m[q][o];n.push(p)}return n.push(1),m.push(n),m}function d(a){return[[a[0][0],a[1][0],a[2][0],a[3][0]],[a[0][1],a[1][1],a[2][1],a[3][1]],[a[0][2],a[1][2],a[2][2],a[3][2]],[a[0][3],a[1][3],a[2][3],a[3][3]]]}function e(a,b){for(var c=[],d=0;d<4;d++){for(var e=0,f=0;f<4;f++)e+=a[f]*b[f][d];c.push(e)}return c}function f(a){var b=g(a);return[a[0]/b,a[1]/b,a[2]/b]}function g(a){return Math.sqrt(a[0]*a[0]+a[1]*a[1]+a[2]*a[2])}function h(a,b,c,d){return[c*a[0]+d*b[0],c*a[1]+d*b[1],c*a[2]+d*b[2]]}function i(a,b){return[a[1]*b[2]-a[2]*b[1],a[2]*b[0]-a[0]*b[2],a[0]*b[1]-a[1]*b[0]]}function j(j){var k=[j.slice(0,4),j.slice(4,8),j.slice(8,12),j.slice(12,16)];if(1!==k[3][3])return null;for(var l=[],m=0;m<4;m++)l.push(k[m].slice());for(var m=0;m<3;m++)l[m][3]=0;if(0===a(l))return null;var n,o=[];k[0][3]||k[1][3]||k[2][3]?(o.push(k[0][3]),o.push(k[1][3]),o.push(k[2][3]),o.push(k[3][3]),n=e(o,d(b(l)))):n=[0,0,0,1];var p=k[3].slice(0,3),q=[];q.push(k[0].slice(0,3));var r=[];r.push(g(q[0])),q[0]=f(q[0]);var s=[];q.push(k[1].slice(0,3)),s.push(c(q[0],q[1])),q[1]=h(q[1],q[0],1,-s[0]),r.push(g(q[1])),q[1]=f(q[1]),s[0]/=r[1],q.push(k[2].slice(0,3)),s.push(c(q[0],q[2])),q[2]=h(q[2],q[0],1,-s[1]),s.push(c(q[1],q[2])),q[2]=h(q[2],q[1],1,-s[2]),r.push(g(q[2])),q[2]=f(q[2]),s[1]/=r[2],s[2]/=r[2];var t=i(q[1],q[2]);if(c(q[0],t)<0)for(var m=0;m<3;m++)r[m]*=-1,q[m][0]*=-1,q[m][1]*=-1,q[m][2]*=-1;var u,v,w=q[0][0]+q[1][1]+q[2][2]+1;return w>1e-4?(u=.5/Math.sqrt(w),v=[(q[2][1]-q[1][2])*u,(q[0][2]-q[2][0])*u,(q[1][0]-q[0][1])*u,.25/u]):q[0][0]>q[1][1]&&q[0][0]>q[2][2]?(u=2*Math.sqrt(1+q[0][0]-q[1][1]-q[2][2]),v=[.25*u,(q[0][1]+q[1][0])/u,(q[0][2]+q[2][0])/u,(q[2][1]-q[1][2])/u]):q[1][1]>q[2][2]?(u=2*Math.sqrt(1+q[1][1]-q[0][0]-q[2][2]),v=[(q[0][1]+q[1][0])/u,.25*u,(q[1][2]+q[2][1])/u,(q[0][2]-q[2][0])/u]):(u=2*Math.sqrt(1+q[2][2]-q[0][0]-q[1][1]),v=[(q[0][2]+q[2][0])/u,(q[1][2]+q[2][1])/u,.25*u,(q[1][0]-q[0][1])/u]),[p,r,s,v,n]}return j}();a.dot=c,a.makeMatrixDecomposition=h,a.transformListToMatrix=g}(b),function(a){function b(a,b){var c=a.exec(b);if(c)return c=a.ignoreCase?c[0].toLowerCase():c[0],[c,b.substr(c.length)]}function c(a,b){b=b.replace(/^\s*/,"");var c=a(b);if(c)return[c[0],c[1].replace(/^\s*/,"")]}function d(a,d,e){a=c.bind(null,a);for(var f=[];;){var g=a(e);if(!g)return[f,e];if(f.push(g[0]),e=g[1],!(g=b(d,e))||""==g[1])return[f,e];e=g[1]}}function e(a,b){for(var c=0,d=0;d<b.length&&(!/\s|,/.test(b[d])||0!=c);d++)if("("==b[d])c++;else if(")"==b[d]&&(c--,0==c&&d++,c<=0))break;var e=a(b.substr(0,d));return void 0==e?void 0:[e,b.substr(d)]}function f(a,b){for(var c=a,d=b;c&&d;)c>d?c%=d:d%=c;return c=a*b/(c+d)}function g(a){return function(b){var c=a(b);return c&&(c[0]=void 0),c}}function h(a,b){return function(c){return a(c)||[b,c]}}function i(b,c){for(var d=[],e=0;e<b.length;e++){var f=a.consumeTrimmed(b[e],c);if(!f||""==f[0])return;void 0!==f[0]&&d.push(f[0]),c=f[1]}if(""==c)return d}function j(a,b,c,d,e){for(var g=[],h=[],i=[],j=f(d.length,e.length),k=0;k<j;k++){var l=b(d[k%d.length],e[k%e.length]);if(!l)return;g.push(l[0]),h.push(l[1]),i.push(l[2])}return[g,h,function(b){var d=b.map(function(a,b){return i[b](a)}).join(c);return a?a(d):d}]}function k(a,b,c){for(var d=[],e=[],f=[],g=0,h=0;h<c.length;h++)if("function"==typeof c[h]){var i=c[h](a[g],b[g++]);d.push(i[0]),e.push(i[1]),f.push(i[2])}else!function(a){d.push(!1),e.push(!1),f.push(function(){return c[a]})}(h);return[d,e,function(a){for(var b="",c=0;c<a.length;c++)b+=f[c](a[c]);return b}]}a.consumeToken=b,a.consumeTrimmed=c,a.consumeRepeated=d,a.consumeParenthesised=e,a.ignore=g,a.optional=h,a.consumeList=i,a.mergeNestedRepeated=j.bind(null,null),a.mergeWrappedNestedRepeated=j,a.mergeList=k}(b),function(a){function b(b){function c(b){var c=a.consumeToken(/^inset/i,b);return c?(d.inset=!0,c):(c=a.consumeLengthOrPercent(b))?(d.lengths.push(c[0]),c):(c=a.consumeColor(b),c?(d.color=c[0],c):void 0)}var d={inset:!1,lengths:[],color:null},e=a.consumeRepeated(c,/^/,b);if(e&&e[0].length)return[d,e[1]]}function c(c){var d=a.consumeRepeated(b,/^,/,c);if(d&&""==d[1])return d[0]}function d(b,c){for(;b.lengths.length<Math.max(b.lengths.length,c.lengths.length);)b.lengths.push({px:0});for(;c.lengths.length<Math.max(b.lengths.length,c.lengths.length);)c.lengths.push({px:0});if(b.inset==c.inset&&!!b.color==!!c.color){for(var d,e=[],f=[[],0],g=[[],0],h=0;h<b.lengths.length;h++){var i=a.mergeDimensions(b.lengths[h],c.lengths[h],2==h);f[0].push(i[0]),g[0].push(i[1]),e.push(i[2])}if(b.color&&c.color){var j=a.mergeColors(b.color,c.color);f[1]=j[0],g[1]=j[1],d=j[2]}return[f,g,function(a){for(var c=b.inset?"inset ":" ",f=0;f<e.length;f++)c+=e[f](a[0][f])+" ";return d&&(c+=d(a[1])),c}]}}function e(b,c,d,e){function f(a){return{inset:a,color:[0,0,0,0],lengths:[{px:0},{px:0},{px:0},{px:0}]}}for(var g=[],h=[],i=0;i<d.length||i<e.length;i++){var j=d[i]||f(e[i].inset),k=e[i]||f(d[i].inset);g.push(j),h.push(k)}return a.mergeNestedRepeated(b,c,g,h)}var f=e.bind(null,d,", ");a.addPropertiesHandler(c,f,["box-shadow","text-shadow"])}(b),function(a,b){function c(a){return a.toFixed(3).replace(/0+$/,"").replace(/\.$/,"")}function d(a,b,c){return Math.min(b,Math.max(a,c))}function e(a){if(/^\s*[-+]?(\d*\.)?\d+\s*$/.test(a))return Number(a)}function f(a,b){return[a,b,c]}function g(a,b){if(0!=a)return i(0,1/0)(a,b)}function h(a,b){return[a,b,function(a){return Math.round(d(1,1/0,a))}]}function i(a,b){return function(e,f){return[e,f,function(e){return c(d(a,b,e))}]}}function j(a){var b=a.trim().split(/\s*[\s,]\s*/);if(0!==b.length){for(var c=[],d=0;d<b.length;d++){var f=e(b[d]);if(void 0===f)return;c.push(f)}return c}}function k(a,b){if(a.length==b.length)return[a,b,function(a){return a.map(c).join(" ")}]}function l(a,b){return[a,b,Math.round]}a.clamp=d,a.addPropertiesHandler(j,k,["stroke-dasharray"]),a.addPropertiesHandler(e,i(0,1/0),["border-image-width","line-height"]),a.addPropertiesHandler(e,i(0,1),["opacity","shape-image-threshold"]),a.addPropertiesHandler(e,g,["flex-grow","flex-shrink"]),a.addPropertiesHandler(e,h,["orphans","widows"]),a.addPropertiesHandler(e,l,["z-index"]),a.parseNumber=e,a.parseNumberList=j,a.mergeNumbers=f,a.numberToString=c}(b),function(a,b){function c(a,b){if("visible"==a||"visible"==b)return[0,1,function(c){return c<=0?a:c>=1?b:"visible"}]}a.addPropertiesHandler(String,c,["visibility"])}(b),function(a,b){function c(a){a=a.trim(),f.fillStyle="#000",f.fillStyle=a;var b=f.fillStyle;if(f.fillStyle="#fff",f.fillStyle=a,b==f.fillStyle){f.fillRect(0,0,1,1);var c=f.getImageData(0,0,1,1).data;f.clearRect(0,0,1,1);var d=c[3]/255;return[c[0]*d,c[1]*d,c[2]*d,d]}}function d(b,c){return[b,c,function(b){function c(a){return Math.max(0,Math.min(255,a))}if(b[3])for(var d=0;d<3;d++)b[d]=Math.round(c(b[d]/b[3]));return b[3]=a.numberToString(a.clamp(0,1,b[3])),"rgba("+b.join(",")+")"}]}var e=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");e.width=e.height=1;var f=e.getContext("2d");a.addPropertiesHandler(c,d,["background-color","border-bottom-color","border-left-color","border-right-color","border-top-color","color","fill","flood-color","lighting-color","outline-color","stop-color","stroke","text-decoration-color"]),a.consumeColor=a.consumeParenthesised.bind(null,c),a.mergeColors=d}(b),function(a,b){function c(a){function b(){var b=h.exec(a);g=b?b[0]:void 0}function c(){var a=Number(g);return b(),a}function d(){if("("!==g)return c();b();var a=f();return")"!==g?NaN:(b(),a)}function e(){for(var a=d();"*"===g||"/"===g;){var c=g;b();var e=d();"*"===c?a*=e:a/=e}return a}function f(){for(var a=e();"+"===g||"-"===g;){var c=g;b();var d=e();"+"===c?a+=d:a-=d}return a}var g,h=/([\+\-\w\.]+|[\(\)\*\/])/g;return b(),f()}function d(a,b){if("0"==(b=b.trim().toLowerCase())&&"px".search(a)>=0)return{px:0};if(/^[^(]*$|^calc/.test(b)){b=b.replace(/calc\(/g,"(");var d={};b=b.replace(a,function(a){return d[a]=null,"U"+a});for(var e="U("+a.source+")",f=b.replace(/[-+]?(\d*\.)?\d+([Ee][-+]?\d+)?/g,"N").replace(new RegExp("N"+e,"g"),"D").replace(/\s[+-]\s/g,"O").replace(/\s/g,""),g=[/N\*(D)/g,/(N|D)[*\/]N/g,/(N|D)O\1/g,/\((N|D)\)/g],h=0;h<g.length;)g[h].test(f)?(f=f.replace(g[h],"$1"),h=0):h++;if("D"==f){for(var i in d){var j=c(b.replace(new RegExp("U"+i,"g"),"").replace(new RegExp(e,"g"),"*0"));if(!isFinite(j))return;d[i]=j}return d}}}function e(a,b){return f(a,b,!0)}function f(b,c,d){var e,f=[];for(e in b)f.push(e);for(e in c)f.indexOf(e)<0&&f.push(e);return b=f.map(function(a){return b[a]||0}),c=f.map(function(a){return c[a]||0}),[b,c,function(b){var c=b.map(function(c,e){return 1==b.length&&d&&(c=Math.max(c,0)),a.numberToString(c)+f[e]}).join(" + ");return b.length>1?"calc("+c+")":c}]}var g="px|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc",h=d.bind(null,new RegExp(g,"g")),i=d.bind(null,new RegExp(g+"|%","g")),j=d.bind(null,/deg|rad|grad|turn/g);a.parseLength=h,a.parseLengthOrPercent=i,a.consumeLengthOrPercent=a.consumeParenthesised.bind(null,i),a.parseAngle=j,a.mergeDimensions=f;var k=a.consumeParenthesised.bind(null,h),l=a.consumeRepeated.bind(void 0,k,/^/),m=a.consumeRepeated.bind(void 0,l,/^,/);a.consumeSizePairList=m;var n=function(a){var b=m(a);if(b&&""==b[1])return b[0]},o=a.mergeNestedRepeated.bind(void 0,e," "),p=a.mergeNestedRepeated.bind(void 0,o,",");a.mergeNonNegativeSizePair=o,a.addPropertiesHandler(n,p,["background-size"]),a.addPropertiesHandler(i,e,["border-bottom-width","border-image-width","border-left-width","border-right-width","border-top-width","flex-basis","font-size","height","line-height","max-height","max-width","outline-width","width"]),a.addPropertiesHandler(i,f,["border-bottom-left-radius","border-bottom-right-radius","border-top-left-radius","border-top-right-radius","bottom","left","letter-spacing","margin-bottom","margin-left","margin-right","margin-top","min-height","min-width","outline-offset","padding-bottom","padding-left","padding-right","padding-top","perspective","right","shape-margin","stroke-dashoffset","text-indent","top","vertical-align","word-spacing"])}(b),function(a,b){function c(b){return a.consumeLengthOrPercent(b)||a.consumeToken(/^auto/,b)}function d(b){var d=a.consumeList([a.ignore(a.consumeToken.bind(null,/^rect/)),a.ignore(a.consumeToken.bind(null,/^\(/)),a.consumeRepeated.bind(null,c,/^,/),a.ignore(a.consumeToken.bind(null,/^\)/))],b);if(d&&4==d[0].length)return d[0]}function e(b,c){return"auto"==b||"auto"==c?[!0,!1,function(d){var e=d?b:c;if("auto"==e)return"auto";var f=a.mergeDimensions(e,e);return f[2](f[0])}]:a.mergeDimensions(b,c)}function f(a){return"rect("+a+")"}var g=a.mergeWrappedNestedRepeated.bind(null,f,e,", ");a.parseBox=d,a.mergeBoxes=g,a.addPropertiesHandler(d,g,["clip"])}(b),function(a,b){function c(a){return function(b){var c=0;return a.map(function(a){return a===k?b[c++]:a})}}function d(a){return a}function e(b){if("none"==(b=b.toLowerCase().trim()))return[];for(var c,d=/\s*(\w+)\(([^)]*)\)/g,e=[],f=0;c=d.exec(b);){if(c.index!=f)return;f=c.index+c[0].length;var g=c[1],h=n[g];if(!h)return;var i=c[2].split(","),j=h[0];if(j.length<i.length)return;for(var k=[],o=0;o<j.length;o++){var p,q=i[o],r=j[o];if(void 0===(p=q?{A:function(b){return"0"==b.trim()?m:a.parseAngle(b)},N:a.parseNumber,T:a.parseLengthOrPercent,L:a.parseLength}[r.toUpperCase()](q):{a:m,n:k[0],t:l||0}[r]))return;k.push(p)}if(e.push({t:g,d:k}),d.lastIndex==b.length)return e}}function f(a){return a.toFixed(6).replace(".000000","")}function g(b,c){if(b.decompositionPair!==c){b.decompositionPair=c;var d=a.makeMatrixDecomposition(b)}if(c.decompositionPair!==b){c.decompositionPair=b;var e=a.makeMatrixDecomposition(c)}return null==d[0]||null==e[0]?[[!1],[!0],function(a){return a?c[0].d:b[0].d}]:(d[0].push(0),e[0].push(1),[d,e,function(b){var c=a.quat(d[0][3],e[0][3],b[5]);return a.composeMatrix(b[0],b[1],b[2],c,b[4]).map(f).join(",")}])}function h(a){return a.replace(/[xy]/,"")}function i(a){return a.replace(/(x|y|z|3d)?$/,"3d")}function j(b,c){var d=a.makeMatrixDecomposition&&!0,e=!1;if(!b.length||!c.length){b.length||(e=!0,b=c,c=[]);for(var f=0;f<b.length;f++){var j=b[f].t,k=b[f].d,l="scale"==j.substr(0,5)?1:0;c.push({t:j,d:k.map(function(a){if("number"==typeof a)return l;var b={};for(var c in a)b[c]=l;return b})})}}var m=function(a,b){return"perspective"==a&&"perspective"==b||("matrix"==a||"matrix3d"==a)&&("matrix"==b||"matrix3d"==b)},o=[],p=[],q=[];if(b.length!=c.length){if(!d)return;var r=g(b,c);o=[r[0]],p=[r[1]],q=[["matrix",[r[2]]]]}else for(var f=0;f<b.length;f++){var j,s=b[f].t,t=c[f].t,u=b[f].d,v=c[f].d,w=n[s],x=n[t];if(m(s,t)){if(!d)return;var r=g([b[f]],[c[f]]);o.push(r[0]),p.push(r[1]),q.push(["matrix",[r[2]]])}else{if(s==t)j=s;else if(w[2]&&x[2]&&h(s)==h(t))j=h(s),u=w[2](u),v=x[2](v);else{if(!w[1]||!x[1]||i(s)!=i(t)){if(!d)return;var r=g(b,c);o=[r[0]],p=[r[1]],q=[["matrix",[r[2]]]];break}j=i(s),u=w[1](u),v=x[1](v)}for(var y=[],z=[],A=[],B=0;B<u.length;B++){var C="number"==typeof u[B]?a.mergeNumbers:a.mergeDimensions,r=C(u[B],v[B]);y[B]=r[0],z[B]=r[1],A.push(r[2])}o.push(y),p.push(z),q.push([j,A])}}if(e){var D=o;o=p,p=D}return[o,p,function(a){return a.map(function(a,b){var c=a.map(function(a,c){return q[b][1][c](a)}).join(",");return"matrix"==q[b][0]&&16==c.split(",").length&&(q[b][0]="matrix3d"),q[b][0]+"("+c+")"}).join(" ")}]}var k=null,l={px:0},m={deg:0},n={matrix:["NNNNNN",[k,k,0,0,k,k,0,0,0,0,1,0,k,k,0,1],d],matrix3d:["NNNNNNNNNNNNNNNN",d],rotate:["A"],rotatex:["A"],rotatey:["A"],rotatez:["A"],rotate3d:["NNNA"],perspective:["L"],scale:["Nn",c([k,k,1]),d],scalex:["N",c([k,1,1]),c([k,1])],scaley:["N",c([1,k,1]),c([1,k])],scalez:["N",c([1,1,k])],scale3d:["NNN",d],skew:["Aa",null,d],skewx:["A",null,c([k,m])],skewy:["A",null,c([m,k])],translate:["Tt",c([k,k,l]),d],translatex:["T",c([k,l,l]),c([k,l])],translatey:["T",c([l,k,l]),c([l,k])],translatez:["L",c([l,l,k])],translate3d:["TTL",d]};a.addPropertiesHandler(e,j,["transform"]),a.transformToSvgMatrix=function(b){var c=a.transformListToMatrix(e(b));return"matrix("+f(c[0])+" "+f(c[1])+" "+f(c[4])+" "+f(c[5])+" "+f(c[12])+" "+f(c[13])+")"}}(b),function(a){function b(a){var b=Number(a);if(!(isNaN(b)||b<100||b>900||b%100!=0))return b}function c(b){return b=100*Math.round(b/100),b=a.clamp(100,900,b),400===b?"normal":700===b?"bold":String(b)}function d(a,b){return[a,b,c]}a.addPropertiesHandler(b,d,["font-weight"])}(b),function(a){function b(a){var b={};for(var c in a)b[c]=-a[c];return b}function c(b){return a.consumeToken(/^(left|center|right|top|bottom)\b/i,b)||a.consumeLengthOrPercent(b)}function d(b,d){var e=a.consumeRepeated(c,/^/,d);if(e&&""==e[1]){var f=e[0];if(f[0]=f[0]||"center",f[1]=f[1]||"center",3==b&&(f[2]=f[2]||{px:0}),f.length==b){if(/top|bottom/.test(f[0])||/left|right/.test(f[1])){var h=f[0];f[0]=f[1],f[1]=h}if(/left|right|center|Object/.test(f[0])&&/top|bottom|center|Object/.test(f[1]))return f.map(function(a){return"object"==typeof a?a:g[a]})}}}function e(d){var e=a.consumeRepeated(c,/^/,d);if(e){for(var f=e[0],h=[{"%":50},{"%":50}],i=0,j=!1,k=0;k<f.length;k++){var l=f[k];"string"==typeof l?(j=/bottom|right/.test(l),i={left:0,right:0,center:i,top:1,bottom:1}[l],h[i]=g[l],"center"==l&&i++):(j&&(l=b(l),l["%"]=(l["%"]||0)+100),h[i]=l,i++,j=!1)}return[h,e[1]]}}function f(b){var c=a.consumeRepeated(e,/^,/,b);if(c&&""==c[1])return c[0]}var g={left:{"%":0},center:{"%":50},right:{"%":100},top:{"%":0},bottom:{"%":100}},h=a.mergeNestedRepeated.bind(null,a.mergeDimensions," ");a.addPropertiesHandler(d.bind(null,3),h,["transform-origin"]),a.addPropertiesHandler(d.bind(null,2),h,["perspective-origin"]),a.consumePosition=e,a.mergeOffsetList=h;var i=a.mergeNestedRepeated.bind(null,h,", ");a.addPropertiesHandler(f,i,["background-position","object-position"])}(b),function(a){function b(b){var c=a.consumeToken(/^circle/,b);if(c&&c[0])return["circle"].concat(a.consumeList([a.ignore(a.consumeToken.bind(void 0,/^\(/)),d,a.ignore(a.consumeToken.bind(void 0,/^at/)),a.consumePosition,a.ignore(a.consumeToken.bind(void 0,/^\)/))],c[1]));var f=a.consumeToken(/^ellipse/,b);if(f&&f[0])return["ellipse"].concat(a.consumeList([a.ignore(a.consumeToken.bind(void 0,/^\(/)),e,a.ignore(a.consumeToken.bind(void 0,/^at/)),a.consumePosition,a.ignore(a.consumeToken.bind(void 0,/^\)/))],f[1]));var g=a.consumeToken(/^polygon/,b);return g&&g[0]?["polygon"].concat(a.consumeList([a.ignore(a.consumeToken.bind(void 0,/^\(/)),a.optional(a.consumeToken.bind(void 0,/^nonzero\s*,|^evenodd\s*,/),"nonzero,"),a.consumeSizePairList,a.ignore(a.consumeToken.bind(void 0,/^\)/))],g[1])):void 0}function c(b,c){if(b[0]===c[0])return"circle"==b[0]?a.mergeList(b.slice(1),c.slice(1),["circle(",a.mergeDimensions," at ",a.mergeOffsetList,")"]):"ellipse"==b[0]?a.mergeList(b.slice(1),c.slice(1),["ellipse(",a.mergeNonNegativeSizePair," at ",a.mergeOffsetList,")"]):"polygon"==b[0]&&b[1]==c[1]?a.mergeList(b.slice(2),c.slice(2),["polygon(",b[1],g,")"]):void 0}var d=a.consumeParenthesised.bind(null,a.parseLengthOrPercent),e=a.consumeRepeated.bind(void 0,d,/^/),f=a.mergeNestedRepeated.bind(void 0,a.mergeDimensions," "),g=a.mergeNestedRepeated.bind(void 0,f,",");a.addPropertiesHandler(b,c,["shape-outside"])}(b),function(a,b){function c(a,b){b.concat([a]).forEach(function(b){b in document.documentElement.style&&(d[a]=b),e[b]=a})}var d={},e={};c("transform",["webkitTransform","msTransform"]),c("transformOrigin",["webkitTransformOrigin"]),c("perspective",["webkitPerspective"]),c("perspectiveOrigin",["webkitPerspectiveOrigin"]),a.propertyName=function(a){return d[a]||a},a.unprefixedPropertyName=function(a){return e[a]||a}}(b)}(),function(){if(void 0===document.createElement("div").animate([]).oncancel){var a;if(window.performance&&performance.now)var a=function(){return performance.now()};else var a=function(){return Date.now()};var b=function(a,b,c){this.target=a,this.currentTime=b,this.timelineTime=c,this.type="cancel",this.bubbles=!1,this.cancelable=!1,this.currentTarget=a,this.defaultPrevented=!1,this.eventPhase=Event.AT_TARGET,this.timeStamp=Date.now()},c=window.Element.prototype.animate;window.Element.prototype.animate=function(d,e){var f=c.call(this,d,e);f._cancelHandlers=[],f.oncancel=null;var g=f.cancel;f.cancel=function(){g.call(this);var c=new b(this,null,a()),d=this._cancelHandlers.concat(this.oncancel?[this.oncancel]:[]);setTimeout(function(){d.forEach(function(a){a.call(c.target,c)})},0)};var h=f.addEventListener;f.addEventListener=function(a,b){"function"==typeof b&&"cancel"==a?this._cancelHandlers.push(b):h.call(this,a,b)};var i=f.removeEventListener;return f.removeEventListener=function(a,b){if("cancel"==a){var c=this._cancelHandlers.indexOf(b);c>=0&&this._cancelHandlers.splice(c,1)}else i.call(this,a,b)},f}}}(),function(a){var b=document.documentElement,c=null,d=!1;try{var e=getComputedStyle(b).getPropertyValue("opacity"),f="0"==e?"1":"0";c=b.animate({opacity:[f,f]},{duration:1}),c.currentTime=0,d=getComputedStyle(b).getPropertyValue("opacity")==f}catch(a){}finally{c&&c.cancel()}if(!d){var g=window.Element.prototype.animate;window.Element.prototype.animate=function(b,c){return window.Symbol&&Symbol.iterator&&Array.prototype.from&&b[Symbol.iterator]&&(b=Array.from(b)),Array.isArray(b)||null===b||(b=a.convertToArrayForm(b)),g.call(this,b,c)}}}(a)}();
//# sourceMappingURL=web-animations.min.js.map
/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the W3C SOFTWARE AND DOCUMENT NOTICE AND LICENSE.
 *
 *  https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 *
 * Source:
 * https://github.com/w3c/IntersectionObserver/edit/master/polyfill/intersection-observer.js
 *
 * Description:
 * Polyfill for intersection observer - used to detect elements in view port
 *
 */
(function() {
    'use strict';

    // Exit early if we're not running in a browser.
    if (typeof window !== 'object') {
        return;
    }

    // Exit early if all IntersectionObserver and IntersectionObserverEntry
    // features are natively supported.
    if (
        'IntersectionObserver' in window &&
        'IntersectionObserverEntry' in window &&
        'intersectionRatio' in window.IntersectionObserverEntry.prototype
    ) {
        // Minimal polyfill for Edge 15's lack of `isIntersecting`
        // See: https://github.com/w3c/IntersectionObserver/issues/211
        if (!('isIntersecting' in window.IntersectionObserverEntry.prototype)) {
            Object.defineProperty(
                window.IntersectionObserverEntry.prototype,
                'isIntersecting',
                {
                    get: function() {
                        return this.intersectionRatio > 0;
                    }
                }
            );
        }
        return;
    }

    /**
     * A local reference to the document.
     */
    var document = window.document;

    /**
     * An IntersectionObserver registry. This registry exists to hold a strong
     * reference to IntersectionObserver instances currently observing a target
     * element. Without this registry, instances without another reference may be
     * garbage collected.
     */
    var registry = [];

    /**
     * Creates the global IntersectionObserverEntry constructor.
     * https://w3c.github.io/IntersectionObserver/#intersection-observer-entry
     * @param {Object} entry A dictionary of instance properties.
     * @constructor
     */
    function IntersectionObserverEntry(entry) {
        this.time = entry.time;
        this.target = entry.target;
        this.rootBounds = entry.rootBounds;
        this.boundingClientRect = entry.boundingClientRect;
        this.intersectionRect = entry.intersectionRect || getEmptyRect();
        this.isIntersecting = !!entry.intersectionRect;

        // Calculates the intersection ratio.
        var targetRect = this.boundingClientRect;
        var targetArea = targetRect.width * targetRect.height;
        var intersectionRect = this.intersectionRect;
        var intersectionArea = intersectionRect.width * intersectionRect.height;

        // Sets intersection ratio.
        if (targetArea) {
            // Round the intersection ratio to avoid floating point math issues:
            // https://github.com/w3c/IntersectionObserver/issues/324
            this.intersectionRatio = Number(
                (intersectionArea / targetArea).toFixed(4)
            );
        } else {
            // If area is zero and is intersecting, sets to 1, otherwise to 0
            this.intersectionRatio = this.isIntersecting ? 1 : 0;
        }
    }

    /**
     * Creates the global IntersectionObserver constructor.
     * https://w3c.github.io/IntersectionObserver/#intersection-observer-interface
     * @param {Function} callback The function to be invoked after intersection
     *     changes have queued. The function is not invoked if the queue has
     *     been emptied by calling the `takeRecords` method.
     * @param {Object=} opt_options Optional configuration options.
     * @constructor
     */
    function IntersectionObserver(callback, opt_options) {
        var options = opt_options || {};

        if (typeof callback != 'function') {
            throw new Error('callback must be a function');
        }

        if (options.root && options.root.nodeType != 1) {
            throw new Error('root must be an Element');
        }

        // Binds and throttles `this._checkForIntersections`.
        this._checkForIntersections = throttle(
            this._checkForIntersections.bind(this),
            this.THROTTLE_TIMEOUT
        );

        // Private properties.
        this._callback = callback;
        this._observationTargets = [];
        this._queuedEntries = [];
        this._rootMarginValues = this._parseRootMargin(options.rootMargin);

        // Public properties.
        this.thresholds = this._initThresholds(options.threshold);
        this.root = options.root || null;
        this.rootMargin = this._rootMarginValues
            .map(function(margin) {
                return margin.value + margin.unit;
            })
            .join(' ');
    }

    /**
     * The minimum interval within which the document will be checked for
     * intersection changes.
     */
    IntersectionObserver.prototype.THROTTLE_TIMEOUT = 100;

    /**
     * The frequency in which the polyfill polls for intersection changes.
     * this can be updated on a per instance basis and must be set prior to
     * calling `observe` on the first target.
     */
    IntersectionObserver.prototype.POLL_INTERVAL = null;

    /**
     * Use a mutation observer on the root element
     * to detect intersection changes.
     */
    IntersectionObserver.prototype.USE_MUTATION_OBSERVER = true;

    /**
     * Starts observing a target element for intersection changes based on
     * the thresholds values.
     * @param {Element} target The DOM element to observe.
     */
    IntersectionObserver.prototype.observe = function(target) {
        var isTargetAlreadyObserved = this._observationTargets.some(function(
            item
        ) {
            return item.element == target;
        });

        if (isTargetAlreadyObserved) {
            return;
        }

        if (!(target && target.nodeType == 1)) {
            throw new Error('target must be an Element');
        }

        this._registerInstance();
        this._observationTargets.push({ element: target, entry: null });
        this._monitorIntersections();
        this._checkForIntersections();
    };

    /**
     * Stops observing a target element for intersection changes.
     * @param {Element} target The DOM element to observe.
     */
    IntersectionObserver.prototype.unobserve = function(target) {
        this._observationTargets = this._observationTargets.filter(function(
            item
        ) {
            return item.element != target;
        });
        if (!this._observationTargets.length) {
            this._unmonitorIntersections();
            this._unregisterInstance();
        }
    };

    /**
     * Stops observing all target elements for intersection changes.
     */
    IntersectionObserver.prototype.disconnect = function() {
        this._observationTargets = [];
        this._unmonitorIntersections();
        this._unregisterInstance();
    };

    /**
     * Returns any queue entries that have not yet been reported to the
     * callback and clears the queue. This can be used in conjunction with the
     * callback to obtain the absolute most up-to-date intersection information.
     * @return {Array} The currently queued entries.
     */
    IntersectionObserver.prototype.takeRecords = function() {
        var records = this._queuedEntries.slice();
        this._queuedEntries = [];
        return records;
    };

    /**
     * Accepts the threshold value from the user configuration object and
     * returns a sorted array of unique threshold values. If a value is not
     * between 0 and 1 and error is thrown.
     * @private
     * @param {Array|number=} opt_threshold An optional threshold value or
     *     a list of threshold values, defaulting to [0].
     * @return {Array} A sorted list of unique and valid threshold values.
     */
    IntersectionObserver.prototype._initThresholds = function(opt_threshold) {
        var threshold = opt_threshold || [0];
        if (!Array.isArray(threshold)) threshold = [threshold];

        return threshold.sort().filter(function(t, i, a) {
            if (typeof t != 'number' || isNaN(t) || t < 0 || t > 1) {
                throw new Error(
                    'threshold must be a number between 0 and 1 inclusively'
                );
            }
            return t !== a[i - 1];
        });
    };

    /**
     * Accepts the rootMargin value from the user configuration object
     * and returns an array of the four margin values as an object containing
     * the value and unit properties. If any of the values are not properly
     * formatted or use a unit other than px or %, and error is thrown.
     * @private
     * @param {string=} opt_rootMargin An optional rootMargin value,
     *     defaulting to '0px'.
     * @return {Array<Object>} An array of margin objects with the keys
     *     value and unit.
     */
    IntersectionObserver.prototype._parseRootMargin = function(opt_rootMargin) {
        var marginString = opt_rootMargin || '0px';
        var margins = marginString.split(/\s+/).map(function(margin) {
            var parts = /^(-?\d*\.?\d+)(px|%)$/.exec(margin);
            if (!parts) {
                throw new Error(
                    'rootMargin must be specified in pixels or percent'
                );
            }
            return { value: parseFloat(parts[1]), unit: parts[2] };
        });

        // Handles shorthand.
        margins[1] = margins[1] || margins[0];
        margins[2] = margins[2] || margins[0];
        margins[3] = margins[3] || margins[1];

        return margins;
    };

    /**
     * Starts polling for intersection changes if the polling is not already
     * happening, and if the page's visibility state is visible.
     * @private
     */
    IntersectionObserver.prototype._monitorIntersections = function() {
        if (!this._monitoringIntersections) {
            this._monitoringIntersections = true;

            // If a poll interval is set, use polling instead of listening to
            // resize and scroll events or DOM mutations.
            if (this.POLL_INTERVAL) {
                this._monitoringInterval = setInterval(
                    this._checkForIntersections,
                    this.POLL_INTERVAL
                );
            } else {
                addEvent(window, 'resize', this._checkForIntersections, true);
                addEvent(document, 'scroll', this._checkForIntersections, true);

                if (
                    this.USE_MUTATION_OBSERVER &&
                    'MutationObserver' in window
                ) {
                    this._domObserver = new MutationObserver(
                        this._checkForIntersections
                    );
                    this._domObserver.observe(document, {
                        attributes: true,
                        childList: true,
                        characterData: true,
                        subtree: true
                    });
                }
            }
        }
    };

    /**
     * Stops polling for intersection changes.
     * @private
     */
    IntersectionObserver.prototype._unmonitorIntersections = function() {
        if (this._monitoringIntersections) {
            this._monitoringIntersections = false;

            clearInterval(this._monitoringInterval);
            this._monitoringInterval = null;

            removeEvent(window, 'resize', this._checkForIntersections, true);
            removeEvent(document, 'scroll', this._checkForIntersections, true);

            if (this._domObserver) {
                this._domObserver.disconnect();
                this._domObserver = null;
            }
        }
    };

    /**
     * Scans each observation target for intersection changes and adds them
     * to the internal entries queue. If new entries are found, it
     * schedules the callback to be invoked.
     * @private
     */
    IntersectionObserver.prototype._checkForIntersections = function() {
        var rootIsInDom = this._rootIsInDom();
        var rootRect = rootIsInDom ? this._getRootRect() : getEmptyRect();

        this._observationTargets.forEach(function(item) {
            var target = item.element;
            var targetRect = getBoundingClientRect(target);
            var rootContainsTarget = this._rootContainsTarget(target);
            var oldEntry = item.entry;
            var intersectionRect =
                rootIsInDom &&
                rootContainsTarget &&
                this._computeTargetAndRootIntersection(target, rootRect);

            var newEntry = (item.entry = new IntersectionObserverEntry({
                time: now(),
                target: target,
                boundingClientRect: targetRect,
                rootBounds: rootRect,
                intersectionRect: intersectionRect
            }));

            if (!oldEntry) {
                this._queuedEntries.push(newEntry);
            } else if (rootIsInDom && rootContainsTarget) {
                // If the new entry intersection ratio has crossed any of the
                // thresholds, add a new entry.
                if (this._hasCrossedThreshold(oldEntry, newEntry)) {
                    this._queuedEntries.push(newEntry);
                }
            } else {
                // If the root is not in the DOM or target is not contained within
                // root but the previous entry for this target had an intersection,
                // add a new record indicating removal.
                if (oldEntry && oldEntry.isIntersecting) {
                    this._queuedEntries.push(newEntry);
                }
            }
        }, this);

        if (this._queuedEntries.length) {
            this._callback(this.takeRecords(), this);
        }
    };

    /**
     * Accepts a target and root rect computes the intersection between then
     * following the algorithm in the spec.
     * TODO(philipwalton): at this time clip-path is not considered.
     * https://w3c.github.io/IntersectionObserver/#calculate-intersection-rect-algo
     * @param {Element} target The target DOM element
     * @param {Object} rootRect The bounding rect of the root after being
     *     expanded by the rootMargin value.
     * @return {?Object} The final intersection rect object or undefined if no
     *     intersection is found.
     * @private
     */
    IntersectionObserver.prototype._computeTargetAndRootIntersection = function(
        target,
        rootRect
    ) {
        // If the element isn't displayed, an intersection can't happen.
        if (window.getComputedStyle(target).display == 'none') return;

        var targetRect = getBoundingClientRect(target);
        var intersectionRect = targetRect;
        var parent = getParentNode(target);
        var atRoot = false;

        while (!atRoot) {
            var parentRect = null;
            var parentComputedStyle =
                parent.nodeType == 1 ? window.getComputedStyle(parent) : {};

            // If the parent isn't displayed, an intersection can't happen.
            if (parentComputedStyle.display == 'none') return;

            if (parent == this.root || parent == document) {
                atRoot = true;
                parentRect = rootRect;
            } else {
                // If the element has a non-visible overflow, and it's not the <body>
                // or <html> element, update the intersection rect.
                // Note: <body> and <html> cannot be clipped to a rect that's not also
                // the document rect, so no need to compute a new intersection.
                if (
                    parent != document.body &&
                    parent != document.documentElement &&
                    parentComputedStyle.overflow != 'visible'
                ) {
                    parentRect = getBoundingClientRect(parent);
                }
            }

            // If either of the above conditionals set a new parentRect,
            // calculate new intersection data.
            if (parentRect) {
                intersectionRect = computeRectIntersection(
                    parentRect,
                    intersectionRect
                );

                if (!intersectionRect) break;
            }
            parent = getParentNode(parent);
        }
        return intersectionRect;
    };

    /**
     * Returns the root rect after being expanded by the rootMargin value.
     * @return {Object} The expanded root rect.
     * @private
     */
    IntersectionObserver.prototype._getRootRect = function() {
        var rootRect;
        if (this.root) {
            rootRect = getBoundingClientRect(this.root);
        } else {
            // Use <html>/<body> instead of window since scroll bars affect size.
            var html = document.documentElement;
            var body = document.body;
            rootRect = {
                top: 0,
                left: 0,
                right: html.clientWidth || body.clientWidth,
                width: html.clientWidth || body.clientWidth,
                bottom: html.clientHeight || body.clientHeight,
                height: html.clientHeight || body.clientHeight
            };
        }
        return this._expandRectByRootMargin(rootRect);
    };

    /**
     * Accepts a rect and expands it by the rootMargin value.
     * @param {Object} rect The rect object to expand.
     * @return {Object} The expanded rect.
     * @private
     */
    IntersectionObserver.prototype._expandRectByRootMargin = function(rect) {
        var margins = this._rootMarginValues.map(function(margin, i) {
            return margin.unit == 'px'
                ? margin.value
                : (margin.value * (i % 2 ? rect.width : rect.height)) / 100;
        });
        var newRect = {
            top: rect.top - margins[0],
            right: rect.right + margins[1],
            bottom: rect.bottom + margins[2],
            left: rect.left - margins[3]
        };
        newRect.width = newRect.right - newRect.left;
        newRect.height = newRect.bottom - newRect.top;

        return newRect;
    };

    /**
     * Accepts an old and new entry and returns true if at least one of the
     * threshold values has been crossed.
     * @param {?IntersectionObserverEntry} oldEntry The previous entry for a
     *    particular target element or null if no previous entry exists.
     * @param {IntersectionObserverEntry} newEntry The current entry for a
     *    particular target element.
     * @return {boolean} Returns true if a any threshold has been crossed.
     * @private
     */
    IntersectionObserver.prototype._hasCrossedThreshold = function(
        oldEntry,
        newEntry
    ) {
        // To make comparing easier, an entry that has a ratio of 0
        // but does not actually intersect is given a value of -1
        var oldRatio =
            oldEntry && oldEntry.isIntersecting
                ? oldEntry.intersectionRatio || 0
                : -1;
        var newRatio = newEntry.isIntersecting
            ? newEntry.intersectionRatio || 0
            : -1;

        // Ignore unchanged ratios
        if (oldRatio === newRatio) return;

        for (var i = 0; i < this.thresholds.length; i++) {
            var threshold = this.thresholds[i];

            // Return true if an entry matches a threshold or if the new ratio
            // and the old ratio are on the opposite sides of a threshold.
            if (
                threshold == oldRatio ||
                threshold == newRatio ||
                threshold < oldRatio !== threshold < newRatio
            ) {
                return true;
            }
        }
    };

    /**
     * Returns whether or not the root element is an element and is in the DOM.
     * @return {boolean} True if the root element is an element and is in the DOM.
     * @private
     */
    IntersectionObserver.prototype._rootIsInDom = function() {
        return !this.root || containsDeep(document, this.root);
    };

    /**
     * Returns whether or not the target element is a child of root.
     * @param {Element} target The target element to check.
     * @return {boolean} True if the target element is a child of root.
     * @private
     */
    IntersectionObserver.prototype._rootContainsTarget = function(target) {
        return containsDeep(this.root || document, target);
    };

    /**
     * Adds the instance to the global IntersectionObserver registry if it isn't
     * already present.
     * @private
     */
    IntersectionObserver.prototype._registerInstance = function() {
        if (registry.indexOf(this) < 0) {
            registry.push(this);
        }
    };

    /**
     * Removes the instance from the global IntersectionObserver registry.
     * @private
     */
    IntersectionObserver.prototype._unregisterInstance = function() {
        var index = registry.indexOf(this);
        if (index != -1) registry.splice(index, 1);
    };

    /**
     * Returns the result of the performance.now() method or null in browsers
     * that don't support the API.
     * @return {number} The elapsed time since the page was requested.
     */
    function now() {
        return window.performance && performance.now && performance.now();
    }

    /**
     * Throttles a function and delays its execution, so it's only called at most
     * once within a given time period.
     * @param {Function} fn The function to throttle.
     * @param {number} timeout The amount of time that must pass before the
     *     function can be called again.
     * @return {Function} The throttled function.
     */
    function throttle(fn, timeout) {
        var timer = null;
        return function() {
            if (!timer) {
                timer = setTimeout(function() {
                    fn();
                    timer = null;
                }, timeout);
            }
        };
    }

    /**
     * Adds an event handler to a DOM node ensuring cross-browser compatibility.
     * @param {Node} node The DOM node to add the event handler to.
     * @param {string} event The event name.
     * @param {Function} fn The event handler to add.
     * @param {boolean} opt_useCapture Optionally adds the even to the capture
     *     phase. Note: this only works in modern browsers.
     */
    function addEvent(node, event, fn, opt_useCapture) {
        if (typeof node.addEventListener == 'function') {
            node.addEventListener(event, fn, opt_useCapture || false);
        } else if (typeof node.attachEvent == 'function') {
            node.attachEvent('on' + event, fn);
        }
    }

    /**
     * Removes a previously added event handler from a DOM node.
     * @param {Node} node The DOM node to remove the event handler from.
     * @param {string} event The event name.
     * @param {Function} fn The event handler to remove.
     * @param {boolean} opt_useCapture If the event handler was added with this
     *     flag set to true, it should be set to true here in order to remove it.
     */
    function removeEvent(node, event, fn, opt_useCapture) {
        if (typeof node.removeEventListener == 'function') {
            node.removeEventListener(event, fn, opt_useCapture || false);
        } else if (typeof node.detatchEvent == 'function') {
            node.detatchEvent('on' + event, fn);
        }
    }

    /**
     * Returns the intersection between two rect objects.
     * @param {Object} rect1 The first rect.
     * @param {Object} rect2 The second rect.
     * @return {?Object} The intersection rect or undefined if no intersection
     *     is found.
     */
    function computeRectIntersection(rect1, rect2) {
        var top = Math.max(rect1.top, rect2.top);
        var bottom = Math.min(rect1.bottom, rect2.bottom);
        var left = Math.max(rect1.left, rect2.left);
        var right = Math.min(rect1.right, rect2.right);
        var width = right - left;
        var height = bottom - top;

        return (
            width >= 0 &&
            height >= 0 && {
                top: top,
                bottom: bottom,
                left: left,
                right: right,
                width: width,
                height: height
            }
        );
    }

    /**
     * Shims the native getBoundingClientRect for compatibility with older IE.
     * @param {Element} el The element whose bounding rect to get.
     * @return {Object} The (possibly shimmed) rect of the element.
     */
    function getBoundingClientRect(el) {
        var rect;

        try {
            rect = el.getBoundingClientRect();
        } catch (err) {
            // Ignore Windows 7 IE11 "Unspecified error"
            // https://github.com/w3c/IntersectionObserver/pull/205
        }

        if (!rect) return getEmptyRect();

        // Older IE
        if (!(rect.width && rect.height)) {
            rect = {
                top: rect.top,
                right: rect.right,
                bottom: rect.bottom,
                left: rect.left,
                width: rect.right - rect.left,
                height: rect.bottom - rect.top
            };
        }
        return rect;
    }

    /**
     * Returns an empty rect object. An empty rect is returned when an element
     * is not in the DOM.
     * @return {Object} The empty rect.
     */
    function getEmptyRect() {
        return {
            top: 0,
            bottom: 0,
            left: 0,
            right: 0,
            width: 0,
            height: 0
        };
    }

    /**
     * Checks to see if a parent element contains a child element (including inside
     * shadow DOM).
     * @param {Node} parent The parent element.
     * @param {Node} child The child element.
     * @return {boolean} True if the parent node contains the child node.
     */
    function containsDeep(parent, child) {
        var node = child;
        while (node) {
            if (node == parent) return true;

            node = getParentNode(node);
        }
        return false;
    }

    /**
     * Gets the parent node of an element or its host element if the parent node
     * is a shadow root.
     * @param {Node} node The node whose parent to get.
     * @return {Node|null} The parent node or null if no parent exists.
     */
    function getParentNode(node) {
        var parent = node.parentNode;

        if (parent && parent.nodeType == 11 && parent.host) {
            // If the parent is a shadow root, return the host element.
            return parent.host;
        }

        if (parent && parent.assignedSlot) {
            // If the parent is distributed in a <slot>, return the parent of a slot.
            return parent.assignedSlot.parentNode;
        }

        return parent;
    }

    // Exposes the constructors globally.
    window.IntersectionObserver = IntersectionObserver;
    window.IntersectionObserverEntry = IntersectionObserverEntry;
})();

/**
 * @fileOverview CustomEvent polyfill - IE9 >= support for CustomEvent
 */

(function() {
    'use strict';

    if (typeof window.CustomEvent === 'function') return false;

    function CustomEvent(event, params) {
        params = params || {
            bubbles: false,
            cancelable: false,
            detail: undefined
        };
        var evt = document.createEvent('CustomEvent');
        evt.initCustomEvent(
            event,
            params.bubbles,
            params.cancelable,
            params.detail
        );
        return evt;
    }

    CustomEvent.prototype = window.Event.prototype;

    window.CustomEvent = CustomEvent;
})();

/**
 * wcmmode.js
 * @fileOverview Provides functionality for the type of wcmmode
 */
(function(vca) {
    'use strict';

    var CONST = {
        COOKIE_NAME: {
            wcmmode: 'wcmmode'
        }
    };

    /**
     * @class WcmMode
     * @memberOf vca.util
     */
    function WcmMode() {
        // Refer:
        // https://github.com/davidegiannella/cq-misc/blob/master/EditMode.js
        // http://code.digitalatolson.com/aem-library/jsdoc/utilities.js.html

        /**
         * Returns the current mode
         * @memberOf vca.util.wcmmode.WcmMode#
         * @function getMode
         * @private
         * @return {string}
         */
        this.getMode = function() {
            var pair = document.cookie.match(
                new RegExp(CONST.COOKIE_NAME.wcmmode + '=([^;]+)')
            );
            return !!pair ? pair[1] : null;
        };

        /**
         * Returns true if mode is author
         * @memberOf vca.util.wcmmode.WcmMode#
         * @function isAuthor
         * @private
         * @return {boolean}
         */
        this.isAuthor = function() {
            return Boolean(window.parent.CQ && window.parent.CQ.WCM);
        };

        /**
         * Returns true if mode is publish
         * @memberOf vca.util.wcmmode.WcmMode#
         * @function isPublish
         * @private
         * @return {boolean}
         */
        this.isPublish = function() {
            return !this.isAuthor();
        };

        /**
         * Returns true if mode is edit
         * @memberOf vca.util.wcmmode.WcmMode#
         * @function isEditMode
         * @private
         * @return {boolean}
         */
        this.isEditMode = function() {
            var mode = this.getMode();
            return this.isAuthor() && (mode === 'edit' || mode === null);
        };

        /**
         * Returns true if mode is design
         * @memberOf vca.util.wcmmode.WcmMode#
         * @function isDesignMode
         * @private
         * @return {boolean}
         */
        this.isDesignMode = function() {
            return this.isAuthor() && this.getMode() === 'design';
        };

        /**
         * Returns true if mode is preview
         * @memberOf vca.util.wcmmode.WcmMode#
         * @function isPreviewMode
         * @private
         * @return {boolean}
         */
        this.isPreviewMode = function() {
            return this.isAuthor() && this.getMode() === 'preview';
        };
    }

    /**
     * Utility for wcmmode
     * @namespace wcmmode
     * @memberof vca.util
     */
    vca.util.wcmmode = (function() {
        var wcmmode = new WcmMode();

        return {
            mode: wcmmode.getMode(),
            isAuthor: wcmmode.isAuthor(),
            isPublish: wcmmode.isPublish(),
            isEditMode: wcmmode.isEditMode(),
            isDesignMode: wcmmode.isDesignMode(),
            isPreviewMode: wcmmode.isPreviewMode()
        };
    })();
})(window.vca);

/* global vca */

/**
 * attempt.js
 * @fileOverview Provides a utility to attempt for a given method in the namespace
 */
(function(win, util) {
    'use strict';

    /**
     * attempt to call a function but don't break entire site if
     * there happens to be an error finding function or in that function
     *
     * @namespace attempt
     * @memberof vca.util
     *
     * @param  {string} fnLoc The location of the function to call e.g. 'componentName.init'
     * @param  {Object} [ns] The namespace that contains the function to attempt to call
     * @return {Function} will attempt to call fnLoc with passed params
     */
    util.attempt = function(fnLoc, ns) {
        var fn;

        // fnLoc is required
        if (typeof fnLoc !== 'string') {
            return;
        }

        win.console = win.console || { error: function() {} };

        // splits each part of fnLoc and assigns method as value if
        // it exists or undefined if it doesn't
        fn = fnLoc.split('.').reduce(function(prev, next) {
            if (prev && prev[next]) {
                return prev[next];
            }
        }, ns || win);

        return function() {
            try {
                if (fn) {
                    fn.apply(this, arguments);
                }
            } catch (e) {
                win.console.error(fnLoc, e.stack || e.toString());
            }
        };
    };
})(window, vca.util);

/* global vca */

/**
 * customEvents.js
 * @fileOverview utility to provide getter in one place for all custom events
 */
(function(util) {
    'use strict';

    /**
     * Custom events util
     * @namespace customEvents
     * @memberof vca.util
     */
    util.customEvents = (function() {
        /**
         * Returns true, if a device supports click event
         * @function isClickSupported
         * @memberof vca.util.customEvents
         * @private
         *
         * The Cause:
         * In case of mobile devices both events (touchend & click ) were used to bind events, so as to support click for touch devices as well.
         *
         * The Impact:
         * Because of the above changes, an event handler was triggered twice, consequently some of the functionalities broke.
         *
         * The Possibilities: To choose among the following or a mix of them:
         *     ontouchstart = 'ontouchstart' in window
         *         true         : for mobile devices & TOUCH desktop in Chrome
         *         false        : for normal desktops
         *     onclick = 'onclick' in window
         *         true         : generally for all devices
         *     maxTouchPoints  = navigator.msMaxTouchPoints || navigator.maxTouchPoints
         *         undefined    : for iPad & iPhone
         *         0            : for normal desktops
         *         10           : for TOUCH desktops
         *     pointerEnabled  = navigator.msPointerEnabled || navigator.pointerEnabled
         *         undefined    : for mobile devices & all desktops
         *         true         : for IE
         *     matchMedia = window.matchMedia('(max-device-width: 768px)').matches
         *
         * The Solution:
         * So we banked upon checking if click is supported on the device.
         */
        function isClickSupported() {
            return 'onclick' in window ? true : false;
        }

        var events = {
            // generic events
            INTERACTION: isClickSupported() ? 'click' : 'touchend',
            TOUCHEND: 'touchend',
            KEYUP: 'keyup',
            KEYPRESS: 'keypress',
            KEYDOWN: 'keydown',
            FOCUS: 'focus',
            FOCUS_OUT: 'focusout',
            BLUR: 'blur',
            CHANGE: 'change',
            SUBMIT: 'submit',
            HOVER: 'hover',
            SEARCH: 'search',
            INPUT: 'input',
            RESIZE: 'resize',
            SCROLL: 'scroll',
            MOUSE_ENTER: 'mouseenter',
            MOUSE_LEAVE: 'mouseleave',
            BEFORE_UNLOAD: 'beforeunload',

            RESIZED: 'vca:resized',
            SCROLLED: 'vca:scrolled',

            // notification bar related
            NB_HIDDEN: 'vca:nb:hidden',

            // intersection observer related
            IO_IN: 'vca:in:viewport',
            IO_OUT: 'vca:out:viewport',
            IO_ELEM_IN: 'vca:element:in:viewport',
            IO_ELEM_OUT: 'vca:element:out:viewport',

            // custom select related
            CS_SELECTED: 'vca:cs:selected',

            // lightbox related
            LB_OPENED: 'vca:lightbox:opened',
            LB_CLOSED: 'vca:lightbox:close',

            // navigation related
            NAV_OPENED: 'vca:navigation:opened',
            NAV_CLOSED: 'vca:navigation:close',

            // Tabs related
            TAB_CLICKED: 'vca:tab:clicked',

            // Slick
            SLICK_INIT: 'vca:slick:init',

            //Search reloaded
            SR_WS_onStartLoading: 'WebSearch_onStartLoading',
            SR_WS_onEndLoading: 'WebSearch_onEndLoading',
            SR_WS_isReady: 'WebSearch_isReady',
            SR_WS_updateView: 'WebSearch_updateView',
            SR_WS_onUpdateResultCategory: 'WebSearch_onUpdateResultCategory',
            SR_WS_onLoadMore: 'WebSearch_onLoadMore',
            SR_WS_onStartResultsLoading: 'WebSearch_onStartResultsLoading',
            SR_WS_onEndResultsLoading: 'WebSearch_onEndResultsLoading',
            SR_WS_updateResults: 'WebSearch_updateResults',
            SR_WS_toogleFacets: 'WebSearch_toogleFacets',
            SR_WS_noResultsFound: 'WebSearch_noResultsFound',
            SR_WS_onSearchServerError: 'WebSearch_onSearchServerError',

            // Tabs related
            LOAD_EDITORIAL_HIGHLIGHT: 'vca:load:editorialHighlights',

            //Apviz events
            READY: 'ready',
            HASPROGRESSED: 'hasProgressed'
        };

        return events;
    })();
})(vca.util);

/* global vca */

/**
 * constants.js
 * @fileOverview utility to provide getter in one place for all constants (sans customEvents)
 */
(function(util) {
    'use strict';

    /**
     * constants util
     * @namespace constants
     * @memberof vca.util
     */
    util.constants = (function() {
        return {
            KeyCode: {
                BACKSPACE: 8,
                TAB: 9,
                RETURN: 13,
                ESC: 27,
                SPACE: 32,
                PAGE_UP: 33,
                PAGE_DOWN: 34,
                END: 35,
                HOME: 36,
                LEFT: 37,
                UP: 38,
                RIGHT: 39,
                DOWN: 40,
                DELETE: 46
            }
        };
    })();
})(vca.util);

/* global vca */

/**
 * initialize.js
 * @fileOverview Provides a utility function to initialise any component by calling the
 * components' returned init function.
 */
(function(vca, $, util) {
    'use strict';

    /**
     * Initialise DOM Element
     * @memberof vca.util
     */
    util.initialise = function(element) {
        // get all components
        var $element = $(element),
            $components = $element.find('.vca-component[data-component-name]');

        $.each($components, function(index, item) {
            var $item = $(item),
                name = $item.data('component-name');

            util.attempt(name + '.init', vca.comp)(item, document, $);
        });
    };
})(vca, vca.$, vca.util);

/*global vca*/
/**
 * @fileOverview Provides a utility function to teardown the events in the component by calling the
 * components' returned teardown function.
 */
(function(vca, $, util) {
    'use strict';

    /**
     * Initialise DOM Element
     * @memberof vca.util
     */
    util.teardown = function(element) {
        // get all components
        var $element = $(element),
            $components = $element.find('.vca-component[data-component-name]');

        $.each($components, function(index, item) {
            var $item = $(item),
                name = $item.data('component-name');

            util.attempt(name + '.teardown', vca.comp)(item, document, $);
        });
    };
})(vca, vca.$, vca.util);

/* global vca */

/**
 * matchmedia.js
 * @fileOverview Provides a utility function to check for the breakpoints.
 */
(function(vca, $, util) {
    'use strict';

    /**
     * Utility for checking media breakpoint
     * @memberof vca.util
     */
    util.matchmedia = (function() {
        var MEDIA_NARROW = '(max-width: 599px)',
            MEDIA_TABLET = '(max-width: 899px)',
            MEDIA_WIDE = '(max-width: 1199px)',
            MEDIA_SUPERWIDE = '(min-width: 1200px)';

        return {
            narrow: window.matchMedia(MEDIA_NARROW),
            tablet: window.matchMedia(MEDIA_TABLET),
            wide: window.matchMedia(MEDIA_WIDE),
            superWide: window.matchMedia(MEDIA_SUPERWIDE)
        };
    })();
})(vca, vca.$, vca.util);

/**
 * If browser back button was used, flush cache
 * This ensures that user will always see an accurate, up-to-date view based on their state
 * Safari cache the entire dom state before unload and on cback button so it exactly, which is causing issues.
 */
(function() {
    window.onpageshow = function(event) {
        const isSafari = /^((?!chrome|android).)*safari/i.test(
            navigator.userAgent
        );
        if (event.persisted && isSafari) {
            window.location.reload();
        }
    };
})();

/**
 * loader.js
 * functionality for the loader utility
 */
(function(vca) {
    'use strict';

    var CONST = {
        SELECTORS: {
            loader: '.vca-loader-container'
        },
        CLASSES: {
            hidden: 'base-hidden'
        }
    };

    /**
     * loader utility
     * @namespace loader
     * @memberof vca.util
     */
    vca.util.loader = (function($) {
        var $loader = null;

        /**
         * Activate/Enable/Show the loader on page
         * @function show
         * @memberOf vca.util.loader
         * @private
         * @returns {void}
         */
        function show() {
            $loader.removeClass(CONST.CLASSES.hidden);
        }

        /**
         * Deactivate/Disable/Hide the loader on page
         * @function hide
         * @memberOf vca.util.loader
         * @returns {void}
         */
        function hide() {
            if (!$loader.hasClass(CONST.CLASSES.hidden)) {
                $loader.addClass(CONST.CLASSES.hidden);
            }
        }

        /**
         * cache DOM variables being used.
         * @function cacheVars
         * @memberOf vca.util.loader
         * @private
         * @returns {void}
         */
        function cacheVars() {
            $loader = $(CONST.SELECTORS.loader);
        }

        /**
         * Initialize the utility
         * @function init
         * @memberOf vca.util.loader
         * @returns {void}
         */
        function init() {
            cacheVars();
        }

        return {
            init: init,
            show: show,
            hide: hide
        };
    })(vca.$);
})(window.vca);

/**
 * resized.js
 * @fileOverview Provides a utility to look for page resized event.
 */
(function(w, vca) {
    'use strict';

    vca.util.resize = (function($, util) {
        var resizeEvent = 'resize.vca-resize orientationchange.vca-resize',
            delayTimer = 250,
            timer,
            wWidth = $(w).width(),
            wHeight = $(w).height(),
            onResizeEvent = function() {
                if (timer !== undefined) {
                    w.clearTimeout(timer);
                }

                timer = w.setTimeout(function() {
                    //adding this checkas on some mobiles when scrolling it things that we resized screen
                    if ($(w).width() !== wWidth || $(w).height() !== wHeight) {
                        wWidth = $(w).width();
                        wHeight = $(w).height();

                        $.publish(util.customEvents.RESIZED);
                    }
                }, delayTimer);
            };

        $(w).on(resizeEvent, onResizeEvent);
    })(vca.$, vca.util);
})(window, window.vca);

/**
 * scrolled.js
 * @fileOverview Publish scrolled event for debouncing. i.e. executing just once 250ms after you finish scrolling (for longer than 250ms)
 */
(function(w, vca) {
    'use strict';

    /**
     * scrolled utility
     * @namespace scrolled
     * @memberof vca.util
     */
    vca.util.scrolled = (function($, util) {
        var scrollTimeout;

        /**
         * Throttle scroll event
         * @function throttleScrollEvent
         * @memberOf vca.util.scrolled
         * @private
         * @returns {void}
         */
        function throttleScrollEvent() {
            if (scrollTimeout) {
                clearTimeout(scrollTimeout);
                scrollTimeout = null;
            }

            scrollTimeout = setTimeout(scrollThrottleHandler, 250);
        }

        /**
         * Scroll throttle handler, this would be fired after scrolled
         * @function scrollThrottleHandler
         * @memberOf vca.util.scrolled
         * @private
         * @returns {void}
         */
        function scrollThrottleHandler() {
            $.publish(util.customEvents.SCROLLED);
        }

        $(w).on(util.customEvents.SCROLL, throttleScrollEvent);
    })(vca.$, vca.util);
})(window, window.vca);

/*global vca */

/**
 * scrollTo.js
 * @fileOverview Provides functionality for scrolling elements to points
 */
(function($, util) {
    'use strict';

    /**
     * Scroll to methods
     * @memberof vca.util
     */
    util.scrollTo = (function() {
        var startedOffset,
            currOffset = 0,
            $page;

        /**
         * Animates element scroll top position
         * @memberof vca.util.scrollTo
         * @private
         * @param {jQuery} $el The element you want to scroll
         * @param {number} top The position you want to scroll to
         * @param {Object} options The animation options
         */
        function animate($el, top, options) {
            return $el.stop().animate(
                {
                    scrollTop: top
                },
                options
            );
        }

        /**
         * Scroll to an element
         * @memberof vca.util.scrollTo
         * @public
         * @param {jQuery} $el The element you want to scroll to
         * @param {Object} options The animation options
         * @param {number} [offset] A pixel offset which will be
         *                          added to top of element you are
         *                          scrolling to
         * Ex:
         * util.scrollTo.element($item, { duration: 1000 }, 0);
         */
        function element($el, options, offset) {
            var step = options.step || $.noop,
                go = function() {
                    startedOffset = currOffset;
                    animate(
                        $page,
                        $el.offset().top - ((offset || 0) + currOffset),
                        options
                    );
                };

            $page = $page || $('html, body');
            options.step = function() {
                // in case a step function is passed to options
                // we still want to call it
                step();

                // change scrollTo position if offset changes mid scroll
                if (currOffset !== startedOffset) {
                    go();
                }
            };

            go();
        }

        /**
         * Scroll to position
         * @memberof vca.util.scrollTo
         * @public
         * @param {number} top The position you want to scroll to
         * @param {number} [time] The speed you want to scroll
         * @param {Function} [donecallback] Function to call when scrolling
         *                                  has finished
         * Ex:
         * util.scrollTo.position(0, 1000, function(){});
         */
        function position(top, time, doneCallback) {
            $page = $page || $('html, body');

            return animate($page, top, {
                duration: time,
                done: doneCallback
            });
        }

        return {
            element: element,
            position: position
        };
    })();
})(vca.$, vca.util);

/* globals vca */

/**
 * throttle.js
 * @fileOverview Provides functionality for executing a callback after a delay
 */
(function(window, util) {
    'use strict';
    let throttleTimer;
    /**
     * Throttle
     *
     * @param  {Function} callback  the callback to be executed
     * @param  {number}   delay     delay in miliseconds
     * @return {Function} function that fires callback
     */
    util.throttle = function(callback, delay) {
        var ticker,
            fn = delay ? 'setTimeout' : 'requestAnimationFrame';

        return function() {
            var context = this,
                args = arguments;

            if (!ticker) {
                // note that requestAnimationFrame is
                // polyfilled in requestanimationframe.js
                // also delay 2nd arg will just be ignored by requestAnimationFrame
                ticker = window[fn](function() {
                    callback.apply(context, args);
                    ticker = null;
                }, delay);
            }
        };
    };

    /**
     * throttleHandler
     * Provides functionality for executing a callback after an interval between events(eg scroll)
     * @param  {Function} callback  the callback to be executed
     * @param  {number}   time     interval/delay in miliseconds
     * @return {Function} function that fires callback
     */
    util.throttleHandler = function(callback, time) {
        if (throttleTimer) return;
        throttleTimer = true;
        setTimeout(() => {
            callback();
            throttleTimer = false;
        }, time);
    };
})(window, vca.util);

/* global vca */
/**
 * Carousel component js
 * Usage:
 * Add data-vca-carousel="optionalComponentName" attribute on the element to add a carousel on it
 * To override the default slick setting add data-carousel-options with the modified object
 * eg: data-carousel-options='{"dots":true}' for adding dots in default mode
 */

vca.util.carousel = (function($, util) {
    let $body = $('body.vca-body'),
        $carousel,
        defaults = {
            speed: 300,
            infinite: true,
            slidesToShow: 1,
            slidesToScroll: 1,
            centerMode: false,
            arrows: true,
            dots: false,
            rows: 0
        },
        leftCursor = '',
        rightCursor = '',
        $templateType = null;

    const CONST = {
        SELECTORS: {
            smartPhotoGalleryItem:
                '.vca-sp-gallery-item,.vca-pdp-sp-gallery-item',
            editorialHighlightWrapper: '.vca-editorial-highlight-wrapper',
            bemCarousel: '.vca-bem-carousel',
            transformImageTag: '.vca-transform-image-tag',
            nextArrow: '.vca-slick-next',
            slickSlide: '.slick-slide .vca-transform-picture-tag'
        },
        CSSCLASS: {
            slickInitialized: 'slick-initialized',
            hide: 'vca-hide'
        },
        DATA: {
            left: 'cursorLeftUrl',
            right: 'cursorRightUrl',
            productDetailTemplate: 'product-detail',
            vcaCarousel: '[data-vca-carousel]'
        },
        ATTRIBUTES: {
            mobileSrc: 'data-mobile-src',
            templateType: 'templateType'
        },
        possibleCustomCursorCarousels: ['vca-bem-carousel'],
        possibleCustomCursorCarouselSelectors: ['.vca-bem-carousel'],
        throttleTime: 1000
    };

    /**
     * Initialise slick carousel
     * @function initCarousel
     * @public
     * @param {HTMLElement} $carousels element
     * @memberof vca.util.carousel
     */
    var initCarousel = function($carousels) {
        // bind hover effect on image gallery carousel
        bindHoverEffects($carousels);
        $carousels.each(function() {
            const $carousel = $(this);

            if (
                $carousel.hasParent(CONST.SELECTORS.editorialHighlightWrapper)
            ) {
                return;
            }

            const options = $carousel.data('carouselOptions') || { dots: true };
            const slickSettings = $.extend({}, defaults, options);
            if (slickSettings.infinite) {
                $carousel.addClass('vca-carousel-infinite');
            }

            const galleryItems = $carousel.find(
                CONST.SELECTORS.smartPhotoGalleryItem
            );

            if (util.dataStore.getLangCode === 'ar') {
                slickSettings.rtl = true;
            }

            // initialize the carousel
            $carousel.slick(slickSettings);

            $carousel.on('breakpoint', function() {
                setCorrectTabindexes($carousel);
            });

            setCorrectTabindexes($carousel);

            if (galleryItems.length) {
                if ($templateType == CONST.DATA.productDetailTemplate) {
                    vca.comp.product.initializeGallery(galleryItems);
                } else {
                    vca.comp.smartPhoto.initializeGallery(galleryItems);
                }
            }

            if (!slickSettings.infinite) {
                $carousel.on('afterChange', function() {
                    let isLastSlideVisible,
                        slides = $carousel.find(CONST.SELECTORS.slickSlide),
                        nextArrow = $carousel.find(CONST.SELECTORS.nextArrow);

                    // Check if last slide is in the viewport?
                    $.each(slides, function(key, element) {
                        isLastSlideVisible = isInViewport(element);
                    });

                    if (isLastSlideVisible) {
                        nextArrow.addClass(CONST.CSSCLASS.hide);
                    } else {
                        nextArrow.removeClass(CONST.CSSCLASS.hide);
                    }
                });
            }
        });
    };

    /**
     * Method to check if an element is present in the current viewport
     * @function isInViewport
     * @memberOf vca.util.carousel
     * @private
     * @param {HTMLElement} element to check
     * @returns {Boolean} true or false
     */
    var isInViewport = function(element) {
        const rect = element.getBoundingClientRect();
        return (
            rect.left >= 0 &&
            rect.right <=
                (window.innerWidth || document.documentElement.clientWidth)
        );
    };

    /**
     * set tabindexes to 0 if carousel is not initialized
     * @function setCorrectTabindexes
     * @public
     * @param {HTMLElement} $carousel element
     * @memberof vca.util.carousel
     */
    var setCorrectTabindexes = function($carousel) {
        var isCarouselActive = $carousel.hasClass(
            CONST.CSSCLASS.slickInitialized
        );

        if (!isCarouselActive) {
            $carousel.find('a, input, button, select').attr({
                tabindex: '0'
            });
        }
    };

    /**
     * return current carousel based on all possible set of carousel
     * @function getCurrentCarousel
     * @public
     * @param {HTMLElement} targetElement element
     * @memberof vca.util.carousel
     */
    var getCurrentCarousel = function(targetElement) {
        let $carousel;
        for (
            var i = 0;
            i < CONST.possibleCustomCursorCarouselSelectors.length;
            i++
        ) {
            let val = CONST.possibleCustomCursorCarouselSelectors[i],
                $elem = $(targetElement).closest(val);
            if ($elem.length) {
                $carousel = $elem;
                break;
            }
        }
        return $carousel;
    };

    /**
     * slick carousel init event handler
     * @function initEventHandler
     * @public
     * @param {Object node} slick - slick object
     * @memberof vca.util.carousel
     */
    var initEventHandler = function(slick) {
        util.throttle(function() {
            $.publish(util.customEvents.SLICK_INIT, slick);
        }, CONST.throttleTime)();
    };

    /**
     * Set cursor value from data attribute to variables
     * @function setCursors
     * @public
     * @param {Object node} event - event captured
     * @memberof vca.util.carousel
     */
    var setCursors = function(event) {
        let bemCarousel = getCurrentCarousel(event.target);
        if (!leftCursor || !rightCursor) {
            leftCursor = bemCarousel.data(CONST.DATA.left);
            rightCursor = bemCarousel.data(CONST.DATA.right);
        }
    };

    /**
     * return style value of cursor based on the type of cursor passed
     * @function getCursor
     * @public
     * @param {String} type - left or right
     * @memberof vca.util.carousel
     */
    var getCursor = function(type) {
        return ['url(', type, '), move'].join('');
    };

    /**
     * Return boolen value if the cursor is on left half of screen or not.
     * @function isLeftHalf
     * @public
     * @param {Object node} event - event captured
     * @memberof vca.util.carousel
     */
    var isLeftHalf = function(event) {
        let leftSide = $(window).width() / 2;
        return event.pageX < leftSide;
    };

    /**
     * Update cursor type when moved over the image gallery carousel.
     * @function updateCursor
     * @public
     * @param {Object node} event - event captured
     * @memberof vca.util.carousel
     */
    var updateCursor = function(event) {
        let bemCarousel = getCurrentCarousel(event.target),
            finalCursor = isLeftHalf(event)
                ? getCursor(leftCursor)
                : getCursor(rightCursor);

        // Check if it's a bem carousel and the cursor does not have an empty path.
        if (bemCarousel && finalCursor !== 'url(), move') {
            bemCarousel.css('cursor', finalCursor);
        }
    };

    /**
     * Rest cursor type when moved out of the image gallery carousel.
     * @function resetCursor
     * @public
     * @param {Object node} event - event captured
     * @memberof vca.util.carousel
     */
    var resetCursor = function(event) {
        let bemCarousel = getCurrentCarousel(event.target);
        bemCarousel.css('cursor', 'default');
    };

    /**
     * Click event handler on image gallery carousel.
     * @function clickHandler
     * @public
     * @param {Object node} event - event captured
     * @memberof vca.util.carousel
     */
    var clickHandler = function(event) {
        let bemCarousel = getCurrentCarousel(event.target),
            finalCursor = isLeftHalf(event)
                ? getCursor(leftCursor)
                : getCursor(rightCursor);

        // Check if it's a bem carousel and the cursor does not have an empty path.
        if (bemCarousel && finalCursor !== 'url(), move') {
            isLeftHalf(event)
                ? $(this).slick('slickPrev')
                : $(this).slick('slickNext');
        }
    };

    /**
     * Bind events on image gallery carousel.
     * @function bindHoverEffects
     * @public
     * @param {HTMLElement} $carousel element
     * @memberof vca.util.carousel
     */
    var bindHoverEffects = function($carousel) {
        if ($carousel.length) {
            $carousel.each(function(index) {
                // only bind hover and click effect to those carousel which are specifically required.
                CONST.possibleCustomCursorCarousels.forEach(function(
                    className
                ) {
                    if ($carousel.eq(index).hasClass(className)) {
                        $carousel.eq(index).bind({
                            mouseenter: setCursors,
                            mousemove: updateCursor,
                            mouseleave: resetCursor,
                            click: clickHandler,
                            init: initEventHandler
                        });
                    }
                });
            });
        }
    };

    /**
     * execute callBack function
     * @function executeFunctionByName
     * @public
     * @param {Object} $obj
     * @memberof vca.util.carousel
     */

    var executeFunctionByName = function(functionName, context) {
        var namespaces = functionName.split('.');
        var func = namespaces.pop();
        for (var i = 0; i < namespaces.length; i++) {
            context = context[namespaces[i]];
        }
        return context[func].apply(context);
    };

    /**
     * bind after change carousel event
     * @function carouselCallback
     * @public
     * @param {Object} $obj
     * @param {String} callback
     * @memberof vca.util.carousel
     */
    var carouselCallback = function($obj, callback) {
        $carousel = $obj;
        $carousel.on('afterChange', function() {
            executeFunctionByName(callback, window);
        });
    };

    /**
     * Carousel Init Callback
     * @function carouselInitCallback
     * @public
     * @memberof vca.util.carousel
     */
    var carouselInitCallback = function($obj, callback) {
        $carousel = $obj;
        $carousel.on('init', function() {
            executeFunctionByName(callback, window);
        });
    };

    /**
     * Contextual init carousel
     * @function contextualInit
     * @public
     * @param {Object} $obj
     * @memberof vca.util.carousel
     */
    var contextualInit = function($obj) {
        $carousel = $obj;
        $carousel.map(function(index, elem) {
            if ($(elem).hasClass(CONST.CSSCLASS.slickInitialized)) {
                $(elem).slick('unslick');
            }
        });
        if ($carousel.length) {
            initCarousel($carousel);
        }
    };

    /**
     * Carousel Destroy
     * @function carouselDestroy
     * @public
     * @param {Object} $carousel
     * @memberof vca.util.carousel
     */
    var carouselDestroy = function($carousel) {
        if ($carousel.length) {
            $carousel.each(function(index) {
                $carousel.eq(index).slick('unslick');
            });
        }
    };

    /**
     * Cache variables being used.
     * @function cacheVars
     * @memberOf vca.comp.carousel
     * @private
     * @param {HTMLElement} elem The component element
     * @returns {void}
     */
    function cacheVars() {
        $templateType = $body.data(CONST.ATTRIBUTES.templateType);
    }

    /**
     * Init carousel
     * @function init
     * @public
     * @param {Object} $obj
     * @memberof vca.util.carousel
     */
    function init() {
        cacheVars();
        if (!util.wcmmode.isEditMode) {
            $carousel = $body.find(CONST.DATA.vcaCarousel);
            $galleryImages = $body.find(CONST.SELECTORS.smartPhotoGalleryItem);

            // Replace gallery image to mobile image if opened in mobile and data-mobile-src provided.
            if (vca.util.matchmedia.narrow.matches) {
                $galleryImages.each(function() {
                    let mobileSrc = $(this).attr(CONST.ATTRIBUTES.mobileSrc);
                    let imgTag = $(this).find(
                        CONST.SELECTORS.transformImageTag
                    );

                    if (mobileSrc && imgTag) {
                        $(this).attr('href', mobileSrc);
                        imgTag.attr('src', mobileSrc);
                        imgTag.attr('data-src', mobileSrc);
                    }
                });
            }

            initCarousel($carousel);
        }
    }

    return {
        init: init,
        contextualInit: contextualInit,
        carouselCallback: carouselCallback,
        carouselDestroy: carouselDestroy,
        carouselInitCallback: carouselInitCallback
    };
})(vca.$, vca.util);

/* global vca */

/**
 * validator.js
 * @fileOverview Provides a utility function to check for the breakpoints.
 */
(function(vca, $, util) {
    'use strict';

    /**
     * Utility for performing custom validations
     * @memberof vca.util
     */
    util.validator = (function() {
        var emailRegex = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;

        /**
         * Function to check valid email input against an email regex.
         * @memberof vca.util.validator
         * @public
         * @param {string} email is the input email string to check for validation.
         * @return {boolean}
         */
        function isValidEmail(email) {
            return emailRegex.test(email);
        }

        /**
         * Function to check if the object is empty or not
         * @memberof vca.util.validator
         * @public
         * @param {string} obj is the input object to check if any property is associated to it or not.
         * @return {boolean}
         */
        function isEmptyObject(obj) {
            for (var i in obj) return false;
            return true;
        }

        return {
            isValidEmail: isValidEmail,
            isEmptyObject: isEmptyObject
        };
    })();
})(vca, vca.$, vca.util);

/**
 * @fileOverview Shorthands for jQuery AJAX functions.
 * TODO: review with team if these are necessary
 */
(function(vca, util) {
    'use strict';

    const CONST = {
        SELECTORS: {
            genericError: '#vca-generic-error'
        },
        CLASSES: {
            loading: 'vca-ajax-loading'
        },
        CACHE: {
            GET: {},
            POST: {}
        },
        TTL: 500
    };

    /**
     * jQuery AJAX wrapper
     * @memberof vca.util
     */
    util.request = (function($) {
        let reqCounter = 0;

        const $body = $('body'),
            DEFAULT_OPTS = {
                beforeSend: function() {
                    reqCounter += 1;
                    if (!$body.data('disableLoader')) {
                        $body.addClass(CONST.CLASSES.loading);
                    }

                    // console.log(
                    //     'beforeSend',
                    //     reqCounter,
                    //     Date.now(),
                    //     arguments
                    // );
                },
                complete: function() {
                    reqCounter -= 1;

                    // remove ajax loading indicator, when all parallel requests are completed
                    util.throttle(function() {
                        if (!reqCounter) {
                            $body.removeClass(CONST.CLASSES.loading);
                        }
                    }, CONST.TTL)();

                    // console.log('complete', reqCounter, Date.now(), arguments);
                }
            },
            listeners = [];

        /**
         * Get request function
         * @function get
         * @memberOf vca.util.request
         * @private
         * @param {URL} url The url to make request
         * @param {string} dataType The datatype
         * @returns {Promise}
         */
        function get(url, dataType) {
            const q = new $.Deferred();

            if (!url) {
                q.reject('No url to make request!');
                return q.promise();
            }

            // let cache = util.productCache.get();
            // console.log(
            //     url,
            //     // encodeURIComponent(url),
            //     cache
            // );
            // // // if response in productCache, return it instead
            // // if (CONST.CACHE.GET[encodeURIComponent(url)]) {
            // //     q.resolve(CONST.CACHE.GET[encodeURIComponent(url)]);
            // //     return q.promise();
            // // }

            const opts = $.extend(DEFAULT_OPTS, {
                type: 'GET',
                url: url
            });

            if (dataType) {
                opts.dataType = dataType;
            }

            // return $.ajax(opts);

            $.ajax(opts)
                .done(function(result, status, xhr) {
                    if (url.indexOf('.productinfo.') > -1) {
                        // save data for the result
                        extractAndSaveData(result);

                        // iterate over response keys
                        Object.keys(result).forEach(function(ref) {
                            var refData = result[ref];

                            // set variants products data
                            if (refData.variants && refData.variants.products) {
                                extractAndSaveData(refData.variants.products);
                            }

                            // set alternatives products data
                            if (
                                refData.alternatives &&
                                refData.alternatives.products
                            ) {
                                extractAndSaveData(
                                    refData.alternatives.products
                                );
                            }
                        });
                    }

                    q.resolve(result, status, xhr);
                })
                .fail(function(err) {
                    q.reject(err);
                });
            return q.promise();
        }

        /**
         * Extract and save data in product cache
         * @function extractAndSaveData
         * @memberOf vca.util.request
         * @private
         * @param {Object} data The JSON object
         * @returns {Promise}
         */
        function extractAndSaveData(data) {
            if (!data) {
                return;
            }

            const keys = Object.keys(data);

            if (keys.length) {
                keys.forEach(function(ref) {
                    if (data[ref]) {
                        util.productCache.set(ref, data[ref]);
                    }
                });
            }
        }

        /**
         * Post request function
         * @function post
         * @memberOf vca.util.request
         * @private
         * @param {URL} url The url to make request
         * @param {Object} data The data for the request
         * @param {Object} config The request header properties
         * @returns {Promise}
         */
        function post(url, data, config) {
            const q = $.Deferred();

            if (!url) {
                q.reject('No url to make request!');
                return q.promise();
            }

            const opts = $.extend({}, DEFAULT_OPTS, {
                type: 'POST',
                url: url
            });

            if (data) {
                opts.data = data;
            }

            if (config) {
                Object.keys(config).forEach(function(ref) {
                    opts[ref] = config[ref];
                });
            }
            return $.ajax(opts);

            // $.ajax(opts)
            //     .done(function(data) {
            //         q.resolve(data);
            //     })
            //     .fail(function(data) {
            //         q.reject(data);
            //     });
            // return q.promise();
        }

        /**
         * Handle erros from requests
         * @function handleErrors
         * @memberOf vca.util.request
         * @private
         * @returns {void}
         */
        function handleErrors() {
            $.ajaxSetup({
                error: function() {
                    console.log(arguments);

                    // var code = Number(xhr.status.toString().charAt(0));

                    // if (code === 1) {
                    //     console.log(
                    //         xhr,
                    //         exception,
                    //         error,
                    //         'Informational responses'
                    //     );
                    // } else if (code === 2) {
                    //     console.log(
                    //         xhr,
                    //         exception,
                    //         error,
                    //         'Successful responses'
                    //     );
                    // } else if (code === 3) {
                    //     console.log(xhr, exception, error, 'Redirects');
                    // } else if (code === 4) {
                    //     console.log(xhr, exception, error, 'Client errors');
                    // } else if (code === 5) {
                    //     console.log(xhr, exception, error, 'Server errors');
                    // } else {
                    //     console.log(xhr, exception, error, 'Others');
                    // }

                    // // if (xhr.status === 0) {
                    // //     console.log('Not connect.n Verify Network.');
                    // // } else if (xhr.status == 404) {
                    // //     console.log('Requested page not found. [404]');
                    // // } else if (xhr.status == 500) {
                    // //     console.log('Internal Server Error [500].');
                    // // } else if (exception === 'parsererror') {
                    // //     console.log('Requested JSON parse failed.');
                    // // } else if (exception === 'timeout') {
                    // //     console.log('Time out error.');
                    // // } else if (exception === 'abort') {
                    // //     console.log('Ajax request aborted.');
                    // // } else {
                    // //     console.log('Uncaught Error.' + xhr.responseText);
                    // // }

                    // // TODO: Generic error handling !!!!
                    // // var errObj = {};

                    // // errObj.error = xhr;
                    // // errObj.url = 'url';
                    // // errObj.feature = 'feature';

                    // // // if (payload) {
                    // // //     errObj.payload = payload;
                    // // // }

                    // // // if (
                    // // //     error.userInitiated ||
                    // // //     (payload && payload.domElement)
                    // // // ) {
                    // // //     errObj.userInitiated = error.userInitiated;
                    // // // }
                    // // errObj.userInitiated = true;

                    // // handleBaseError(errObj);
                }
            });
        }

        /**
         * Method to open lightbox
         * @function handleBaseError
         * @memberOf vca.util.request
         * @private
         * @param {json} errObj The obj published by base
         *
         * Approach:
         *     Here we are consuming the event published from cms-base ajaxUtil.
         *     The published event is: base.util.customEvents.AJAX_ERROR_OCCURRED
         *     The published data is an error object, containing [payload, url, status, statusText, responseText].
         *         payload      - is the request payload sent.
         *         url          - is the request endpoint.
         *         status       - is the status code of the response.
         *         statusText   - is the status text of the response that may be used as the heading of the error message.
         *         responseText - is the object containing the actual response(error) of the response. It may be of 3 types:
         *             - string : which contains single error message.
         *             - html   : which contains the error html. So we may need to extract right error message from the title present in the html.
         *             - object : which contains the list of errors from server.
         */
        function handleBaseError(errObj) {
            const genericErrorMsg = $(CONST.SELECTORS.genericError).val();

            // here we are showing errors to user if the error is:
            // - generated by a user action
            // - related to: bis, captcha, checkout, formfield, searchresults, profile, wishlist
            if (errObj.userInitiated) {
                window.base.util.ajaxUtil.defaultBaseErrorHandler(
                    errObj,
                    genericErrorMsg
                );
            }
        }

        /**
         * Bind events
         * @function bindEvents
         * @memberOf vca.util.request
         * @private
         * @returns {void}
         */
        function bindEvents() {
            listeners.push(
                $.subscribe(
                    window.base.util.customEvents.AJAX_ERROR_OCCURRED,
                    handleBaseError
                )
            );
        }

        /**
         * Unbinds all pre-existing events
         * @function teardown
         * @memberOf vca.util.request
         * @private
         * @returns {void}
         */
        function teardown() {
            while (listeners.length) {
                $.unsubscribe(listeners.pop());
            }
        }

        /**
         * Initialise function
         * @function init
         * @memberOf vca.util.request
         * @private
         * @returns {void}
         */
        function init() {
            teardown();
            bindEvents();

            handleErrors();
        }

        return {
            init: init,
            get: get,
            post: post
        };
    })(vca.$);
})(vca, vca.util);

/**
 * focus.js
 * @fileOverview Provides a utility for focus related stuff.
 *
 * Reference - https://www.w3.org/TR/wai-aria-practices/examples/dialog-modal/dialog.html
 */
(function(vca, util) {
    'use strict';

    // jQuery formatted selector to search for focusable items
    var focusableElementsString =
        'a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, *[tabindex], *[contenteditable]';

    /**
     * focus utility
     * @memberof vca.util
     */
    util.focus = (function($) {
        var IgnoreUtilFocusChanges = false;

        function isFocusable(element) {
            element = $(element)[0];

            if (
                element.tabIndex > 0 ||
                (element.tabIndex === 0 &&
                    element.getAttribute('tabindex') !== null)
            ) {
                return true;
            }

            if (element.disabled) {
                return false;
            }

            if (element.inert) {
                return false;
            }

            switch (element.nodeName) {
                case 'A':
                    return !!element.href && element.rel != 'ignore';
                case 'INPUT':
                    return element.type != 'hidden' && element.type != 'file';
                case 'BUTTON':
                case 'SELECT':
                case 'TEXTAREA':
                    return true;
                default:
                    return false;
            }
        }

        function focusFirstDescendant(element) {
            element = $(element)[0];

            var descendants = element.childNodes; // element.querySelectorAll('*');
            for (var i = 0; i < descendants.length; i++) {
                var child = descendants[i];

                if (attemptFocus(child)) {
                    return true;
                }
            }

            return false;
        }

        function focusLastDescendant(element) {
            element = $(element)[0];

            var descendants = element.childNodes; // element.querySelectorAll('*');
            for (var i = descendants.length - 1; i >= 0; i--) {
                var child = descendants[i];

                if (attemptFocus(child)) {
                    return true;
                }
            }

            return false;
        }

        function attemptFocus(element) {
            element = $(element)[0];

            if (!isFocusable(element)) {
                return false;
            }

            IgnoreUtilFocusChanges = true;

            try {
                element.focus();
            } catch (e) {}

            IgnoreUtilFocusChanges = false;
            return document.activeElement === element;
        }

        // https://github.com/gdkraus/accessible-modal-dialog/blob/master/modal-window.js
        function trapTabKey(obj, evt) {
            // if tab or shift-tab pressed
            if (evt.which == util.constants.KeyCode.TAB) {
                // get list of all children elements in given object
                var o = obj.find('*');

                // get list of focusable items
                var focusableItems;
                focusableItems = o
                    .filter(focusableElementsString)
                    .filter(':visible');

                // get currently focused item
                var focusedItem;
                focusedItem = $(':focus');

                // get the number of focusable items
                var numberOfFocusableItems;
                numberOfFocusableItems = focusableItems.length;

                // get the index of the currently focused item
                var focusedItemIndex;
                focusedItemIndex = focusableItems.index(focusedItem);

                if (evt.shiftKey) {
                    //back tab
                    // if focused on first item and user preses back-tab, go to the last focusable item
                    if (focusedItemIndex == 0) {
                        focusableItems.get(numberOfFocusableItems - 1).focus();
                        evt.preventDefault();
                    }
                } else {
                    //forward tab
                    // if focused on the last item and user preses tab, go to the first focusable item
                    if (focusedItemIndex == numberOfFocusableItems - 1) {
                        focusableItems.get(0).focus();
                        evt.preventDefault();
                    }
                }
            }
        }

        return {
            isFocusable: isFocusable,
            focusFirstDescendant: focusFirstDescendant,
            focusLastDescendant: focusLastDescendant,
            attemptFocus: attemptFocus,
            IgnoreUtilFocusChanges: IgnoreUtilFocusChanges,
            trapTabKey: trapTabKey
        };
    })(vca.$);
})(vca, vca.util);

/**
 * intersectionObserver.js
 * @fileOverview Provides a utility to observe elements when they enter or leave viewport.
 */
(function(w, vca) {
    'use strict';

    vca.util.io = (function($, util) {
        var observerOptions = {
            root: null,
            rootMargin: '0px',
            threshold: [0, 0.25, 0.5, 0.75, 1]
        };

        /**
         * Function to initialse the intersection observer and publish events
         * when the element enters and leaves the view port
         */
        var observer = new IntersectionObserver(function(entries) {
            entries.forEach(function(entry) {
                var compName = entry.target.dataset.componentName;

                if (entry.intersectionRatio > 0) {
                    $.publish(util.customEvents.IO_IN + ':' + compName, [
                        entry.boundingClientRect
                    ]);
                } else {
                    $.publish(util.customEvents.IO_OUT + ':' + compName, [
                        entry.boundingClientRect
                    ]);
                }
            });
        }, observerOptions);

        /**
         * Function to observer that give element is in view regarding given config or not, and publish
         * events regarding its availiblity.
         * @function isElementInView
         * @public
         * @param {string} $identifier unique string attached with event name
         * @param {DOM Node} $element html dom selector, which we want to observe
         * @param {Object} $config IO config object
         * @memberOf vca.util.io
         */
        function isElementInView(identifier, element, config) {
            // configure the intersection observer instance
            let intersectionObserverOptions = config
                ? config
                : {
                    root: null,
                    rootMargin: '10px'
                };

            let observer = new IntersectionObserver(
                onIntersection,
                intersectionObserverOptions
            );
            // provide the observer with a target element
            observer.observe(element);

            function onIntersection(entries) {
                entries.forEach(function(entry) {
                    // Is element in viewport?
                    if (entry.intersectionRatio > 0) {
                        $.publish(
                            util.customEvents.IO_ELEM_IN + ':' + identifier,
                            [entry.boundingClientRect]
                        );
                    } else {
                        // When element is not in viewport?
                        $.publish(
                            util.customEvents.IO_ELEM_OUT + ':' + identifier,
                            [entry.boundingClientRect]
                        );
                    }
                });
            }
        }

        return {
            observer: observer,
            isElementInView: isElementInView
        };
    })(vca.$, vca.util);
})(window, window.vca);

/**
 * cookieManager.js
 * @fileOverview Provides a utility to look for page resized event.
 */
(function(w, vca) {
    'use strict';

    vca.util.cookieManager = (function() {
        /**
         * Function to set a cookie
         * @function setCookie
         * @memberOf vca.util.cookieManager
         * @public
         * @param {string} name Name of the cookie
         * @param {string} value Value of the cookie
         * @param {number} duration Duration in days which specifies the life of cookie
         * @param {string} path The url path for which the cookie should be created.
         * If blank it creates a cookie on the root path
         * @returns {void}
         */
        const setCookie = function(name, value, duration, path) {
            let date,
                secure,
                cookieStr,
                cookiePath = path || '/';

            date = new Date();
            date.setDate(date.getDate() + parseInt(duration));

            if (location.protocol === 'https:') {
                secure = 'secure';
            }

            cookieStr = [
                name + '=' + value,
                'expires=' + date.toUTCString(),
                'path=' + cookiePath,
                secure
            ]
                .filter(Boolean)
                .join(';');

            // console.log(cookieStr);

            document.cookie = cookieStr;
        };

        /**
         * Function to get a cookie
         * @function getCookie
         * @memberOf vca.util.cookieManager
         * @public
         * @param {string} name Name of the cookie
         * @returns {string} value is the values stired for the cookie, if nothing found it returns null
         */
        const getCookie = function(name) {
            const value = document.cookie.match(
                '(^|;) ?' + name + '=([^;]*)(;|$)'
            );
            return value ? value[2] : null;
        };

        /**
         * Function to delete a cookie
         * @function deleteCookie
         * @memberOf vca.util.cookieManager
         * @public
         * @param {string} name Name of the cookie
         * @returns {void}
         */
        const deleteCookie = function(name) {
            setCookie(name, '', -1);
        };

        return {
            setCookie: setCookie,
            getCookie: getCookie,
            deleteCookie: deleteCookie
        };
    })();
})(window, window.vca);

/**
 * productCache.js
 * functionality for the productCache utility
 */
(function(vca) {
    'use strict';

    const CONST = {
            IN_NETWORK: new Set(),
            REQ_ELEMENTS: {},
            DATASTORE: {}
        },
        TRACK_INTERVAL_TIMEOUT = 50;

    /**
     * productCache utility
     * @namespace productCache
     * @memberof vca.util
     */
    vca.util.productCache = (function($, util) {
        let //listeners = [],
            INTERVAL_ID = null;

        /**
         * Register card instance that needs to be updated
         * @function registerCard
         * @memberOf vca.util.productCache
         * @private
         * @param {Object} inst The instance of the requesting card
         * @returns {void}
         */
        function registerCard(inst) {
            // check for ref in datastore, else track productQ
            if (CONST.DATASTORE[inst.gRef]) {
                updateCard(inst);
                return;
            }

            if (!CONST.REQ_ELEMENTS[inst.gRef]) {
                CONST.REQ_ELEMENTS[inst.gRef] = [];
            }

            // add the instance to the cache
            CONST.REQ_ELEMENTS[inst.gRef].push(inst);

            // track products in network
            trackProdQ();
        }

        /**
         * Sets the data to cache
         * @function trackProdQ
         * @memberOf vca.util.productCache
         * @private
         * @returns {void}
         */
        function trackProdQ() {
            if (INTERVAL_ID) {
                return;
            }

            // setInterval to check
            INTERVAL_ID = setInterval(function() {
                try {
                    const refsArr = Object.keys(CONST.REQ_ELEMENTS);
                    let refsInWay = [];
                    CONST.IN_NETWORK.forEach(function(item) {
                        refsInWay.push(item);
                    });

                    let refsPending = refsArr.difference(refsInWay);
                    let refsForRequest = refsPending.splice(0, 10);
                    const urlToRequest = util.dataStore.getProdInfoUrl(
                        util.dataStore.CONST.URL_TYPE.mul_pI,
                        refsForRequest
                    );

                    // stop further executions
                    if (!refsPending.length && INTERVAL_ID) {
                        clearInterval(INTERVAL_ID);
                    }

                    // adding refs from network Q
                    refsForRequest.forEach(
                        CONST.IN_NETWORK.add,
                        CONST.IN_NETWORK
                    );

                    // make request
                    util.request.get(urlToRequest).done(processResponse);
                } catch (err) {
                    // console.log(err, INTERVAL_ID);
                    clearInterval(INTERVAL_ID);
                }
            }, TRACK_INTERVAL_TIMEOUT);
        }

        /**
         * Process response
         * @function processResponse
         * @memberOf vca.util.productCache
         * @private
         * @returns {void}
         */
        function processResponse(data) {
            const refsArr = Object.keys(data);

            // removing refs from network Q
            util.throttle(function() {
                refsArr.forEach(CONST.IN_NETWORK.delete, CONST.IN_NETWORK);
            }, TRACK_INTERVAL_TIMEOUT)();
            // process cards
            processCards(refsArr);
        }

        /**
         * Process cards
         * @function processCards
         * @memberOf vca.util.productCache
         * @private
         * @returns {void}
         */
        function processCards(refsArr) {
            refsArr.forEach(function(ref) {
                const instArr = CONST.REQ_ELEMENTS[ref];

                instArr.forEach(function(inst) {
                    updateCard(inst);
                });

                // clearing updated references
                CONST.REQ_ELEMENTS[ref] = [];
            });
        }

        /**
         * Update product card
         * @function updateCard
         * @memberOf vca.util.productCache
         * @private
         * @param {Instance<CCProduct>} inst The instance of CCProduct
         * @returns {void}
         */
        function updateCard(inst) {
            var q = new $.Deferred();

            try {
                if (inst.isPriceUpdated) {
                    return;
                }

                get(inst.gRef).done(function(data) {
                    inst.updateCardInfo(data);
                    q.resolve(data);
                });
            } catch (e) {
                q.reject(e);
            }

            return q.promise();
        }

        /**
         * Sets the data to cache
         * @function set
         * @memberOf vca.util.productCache
         * @private
         * @returns {void}
         */
        function set(ref, data) {
            var q = new $.Deferred();

            try {
                if (!CONST.DATASTORE[ref]) {
                    CONST.DATASTORE[ref] = {};
                }

                // adding data in cache
                Object.assign(CONST.DATASTORE[ref], data);

                q.resolve(data);
            } catch (e) {
                q.reject(e);
            }

            return q.promise();
        }

        /**
         * Gets the data from cache
         * @function get
         * @memberOf vca.util.productCache
         * @private
         * @returns {void}
         */
        function get(ref) {
            var q = new $.Deferred();

            try {
                let dataCopy = JSON.parse(JSON.stringify(CONST.DATASTORE));

                if (!ref) {
                    q.resolve(dataCopy);
                } else {
                    q.resolve(dataCopy[ref]);
                }
            } catch (e) {
                q.reject(e);
            }

            return q.promise();
        }

        return {
            registerCard: registerCard,
            get: get,
            set: set
        };
    })(vca.$, vca.util);
})(window.vca);

/**
 * tabs.js
 * functionality for the tab utility
 */
(function(vca) {
    'use strict';

    const CONST = {
        SELECTORS: {
            tabsComp: '.vca-tabs',
            tabsList: '.vca-tabs-list',
            tabsButton: '.vca-tabs-button',
            tabsPanel: '.vca-tabs-panel'
        },
        CLASSES: {
            hide: 'vca-hide',
            show: 'vca-show-section'
        }
    };

    /**
     * tabs utility
     * @namespace tabs
     * @memberof vca.util
     */
    vca.util.tabs = (function($, util) {
        let listeners = [],
            $body = $('body');

        /**
         * Tab click event handler
         * @function tabButtonClickHandler
         * @memberOf vca.util.tabs
         * @private
         * @param {Event} e The click event
         * @returns {void}
         */
        function tabButtonClickHandler(e) {
            let $thisElem = $(e.target || e.currentTarget),
                $prevSelectedTab = $thisElem
                    .closest(CONST.SELECTORS.tabsList)
                    .find(CONST.SELECTORS.tabsButton)
                    .filter(function(_i, tab) {
                        return $(tab).attr('aria-selected') == 'true';
                    }),
                $thisPanel = $thisElem
                    .closest(CONST.SELECTORS.tabsComp)
                    .find(CONST.SELECTORS.tabsPanel)
                    .filter(function(_i, panel) {
                        return (
                            $thisElem.attr('id') ===
                            $(panel).attr('aria-labelledby')
                        );
                    });

            $thisElem
                .attr('aria-selected', 'true')
                .siblings(CONST.SELECTORS.tabsButton)
                .attr('aria-selected', 'false');

            $thisPanel
                .prop('hidden', false)
                .removeClass(CONST.CLASSES.hide)
                .addClass(CONST.CLASSES.show)
                .siblings(CONST.SELECTORS.tabsPanel)
                .prop('hidden', true)
                .removeClass(CONST.CLASSES.show)
                .addClass(CONST.CLASSES.hide);
            $.publish(util.customEvents.TAB_CLICKED, [
                {
                    currentTab: $thisElem,
                    previousTab: $prevSelectedTab
                }
            ]);
        }

        /**
         * Bind events
         * @function bindEvents
         * @memberOf vca.util.tabs
         * @private
         * @returns {void}
         */
        function bindEvents() {
            $body.on(
                util.customEvents.INTERACTION,
                CONST.SELECTORS.tabsButton,
                tabButtonClickHandler
            );
        }

        /**
         * Unbinds all pre-existing events
         * @function teardown
         * @memberOf vca.util.tabs
         * @private
         * @returns {void}
         */
        function teardown() {
            while (listeners.length) {
                $.unsubscribe(listeners.pop());
            }

            $body.off(
                util.customEvents.INTERACTION,
                CONST.SELECTORS.tabsButton,
                tabButtonClickHandler
            );
        }

        /**
         * Initialize the utility
         * @function init
         * @memberOf vca.util.tabs
         * @private
         * @param {HTMLElement} elem The utility element
         * @returns {void}
         */
        function init() {
            teardown();
            bindEvents();
        }

        return {
            init: init,
            teardown: teardown
        };
    })(vca.$, vca.util);
})(window.vca);

/**
 * slider.js
 * functionality for the slider utility
 */
(function(vca) {
    'use strict';

    var CONST = {
        SELECTORS: {
            sliderComp: '.vca-slider',
            sliderColumn: '.vca-slider-column',
            sliderClose: '.vca-slider-close',
            sliderOverlay: '.vca-slider-overlay'
        },
        CLASSES: {
            active: 'vca-active',
            overlayVisible: 'vca-overlay-visible'
        }
    };

    /**
     * slider utility
     * @namespace slider
     * @memberof vca.util
     */
    vca.util.slider = (function($, util) {
        var listeners = [],
            $body = $('body,html'),
            $overlay = null;

        /**
         * Tab click event handler
         * @function tabButtonClickHandler
         * @memberOf vca.util.slider
         * @private
         * @param {Event} e The click event
         * @returns {void}
         */
        function sliderCloseBtnHandler(e) {
            var $thisElem = $(e.target || e.currentTarget),
                $sliderColumn = $thisElem.closest(CONST.SELECTORS.sliderColumn);

            $sliderColumn.removeClass(CONST.CLASSES.active);
        }

        /**
         * Function to open the slider
         * @function openSlider
         * @memberOf vca.util.slider
         * @private
         * @param {Function} cb The callback function
         * @returns {void}
         */
        function openSlider(cb) {
            // disable body scroll
            $body.addClass(CONST.CLASSES.overlayVisible);

            // open overlay
            $overlay.addClass(CONST.CLASSES.active);

            if (typeof cb === 'function') {
                cb.call(this.arguments);
            }
        }

        /**
         * Function to close the slider
         * @function closeSlider
         * @memberOf vca.util.slider
         * @private
         * @param {Function} cb The callback function
         * @returns {void}
         */
        function closeSlider(cb) {
            if (typeof cb === 'function') {
                cb.call(this.arguments);
            }

            // close overlay
            $overlay.removeClass(CONST.CLASSES.active);

            // enable body scroll
            $body.removeClass(CONST.CLASSES.overlayVisible);
        }

        /**
         * Bind events
         * @function bindEvents
         * @memberOf vca.util.slider
         * @private
         * @returns {void}
         */
        function bindEvents() {
            $body.on(
                util.customEvents.INTERACTION,
                CONST.SELECTORS.sliderClose,
                sliderCloseBtnHandler
            );
        }

        /**
         * Unbinds all pre-existing events
         * @function teardown
         * @memberOf vca.util.slider
         * @private
         * @returns {void}
         */
        function teardown() {
            while (listeners.length) {
                $.unsubscribe(listeners.pop());
            }

            $body.off(
                util.customEvents.INTERACTION,
                CONST.SELECTORS.sliderClose,
                sliderCloseBtnHandler
            );
        }

        function cacheVars() {
            $overlay = $body.find(CONST.SELECTORS.sliderOverlay);
        }

        /**
         * Initialize the utility
         * @function init
         * @memberOf vca.util.slider
         * @private
         * @param {HTMLElement} elem The utility element
         * @returns {void}
         */
        function init() {
            cacheVars();
            teardown();
            bindEvents();
        }

        return {
            init: init,
            teardown: teardown,
            openSlider: openSlider,
            closeSlider: closeSlider
        };
    })(vca.$, vca.util);
})(window.vca);

/**
 * accordion.js
 * Accordion component
 * Usage:
 * Add data-accordion="true" attribute on the element to add a accordion on it
 * Use "vca-accordion-head" css class on accordion item header
 * Use "vca-accordion-content" css class on accordion item content wrapper
 * Use "vca-accordion-uninitialized" css class on element where you want to add accordion to not initialize accordion
 */

'use strict';

(function(vca) {
    const CONST = {
        SELECTORS: {
            accordionElem: '[data-accordion]',
            head: '.vca-accordion-head',
            content: '.vca-accordion-content'
        },
        CSS_CLASS: {
            uninitialized: 'vca-accordion-uninitialized',
            active: 'vca-active',
            hide: 'vca-hide'
        },
        DATA_ATTRIBUTES: {
            disableScroll: 'disableScroll',
            preventClose: 'preventClose'
        }
    };

    /**
     * accordion util
     * @namespace accordion
     * @memberof vca.util
     */
    vca.util.accordion = (function($, util) {
        const listeners = [],
            $body = $('body');

        /**
         * Accordion heading click handler
         * @function accordianHeadingClickHandler
         * @memberof vca.util.accordion
         * @private
         * @param {Event} e The click event
         */
        function accordianHeadingClickHandler(e) {
            e.preventDefault();

            var $thisElem = $(e.currentTarget || e.target),
                $thisContent = $thisElem.next(),
                $thisSibHeading = $body.find(CONST.SELECTORS.head),
                $thisSibContent = $body.find(CONST.SELECTORS.content),
                toMakeActive = !$thisElem.hasClass(CONST.CSS_CLASS.active),
                preventScroll = $thisSibHeading.data(
                    CONST.DATA_ATTRIBUTES.disableScroll
                ),
                preventClose = $thisElem.data(
                    CONST.DATA_ATTRIBUTES.preventClose
                );

            if (!preventClose) {
                // update siblings heading attributes
                $thisSibHeading
                    .removeClass(CONST.CSS_CLASS.active)
                    // .attr('tabindex', '-1')
                    .attr('aria-selected', 'false')
                    .attr('aria-expanded', 'false');

                // update siblings content attributes
                $thisSibContent
                    .addClass(CONST.CSS_CLASS.hide)
                    .removeClass(CONST.CSS_CLASS.active)
                    .attr('aria-hidden', 'true');
            }

            // update this heading attributes
            $thisElem
                .toggleClass(CONST.CSS_CLASS.active, toMakeActive)
                // .attr('tabindex', '0')
                .attr('aria-selected', toMakeActive ? 'true' : 'false')
                .attr('aria-expanded', toMakeActive ? 'true' : 'false');

            // update this content attributes
            $thisContent
                .toggleClass(CONST.CSS_CLASS.active, toMakeActive)
                .toggleClass(CONST.CSS_CLASS.hide, !toMakeActive)
                .attr('aria-hidden', toMakeActive ? 'false' : 'true');

            // Scroll content if not in lightbox and and not a system trigger
            util.throttle(function() {
                if (
                    !vca.util.lightbox.getLightboxStatus() &&
                    !Boolean(e.isTrigger) &&
                    !Boolean(preventScroll)
                ) {
                    vca.util.scrollTo.element(
                        $thisElem,
                        { duration: 10 },
                        vca.comp.header.getHeaderHeight()
                    );
                }
            }, 0)();
        }

        /**
         * Initialize accordions in the default state
         * @function initializeAccordions
         * @memberOf vca.util.accordion
         * @private
         * @param {jQuery} $content The content to initialize
         * @returns {void}
         */
        function initializeAccordions($content) {
            if (!$content) {
                $content = $body;
            }

            const $accList = $content.find(CONST.SELECTORS.accordionElem);

            if (!$accList.length) {
                return;
            }

            $.each($accList, function(i) {
                const $acc = $accList.eq(i);
                if (!$acc.hasClass(CONST.CSS_CLASS.uninitialized)) {
                    updateInitialState($acc);
                } else {
                    $acc.find(CONST.SELECTORS.content).addClass(
                        CONST.CSS_CLASS.hide
                    );
                }
            });
        }

        /**
         * Update initial state
         * @function updateInitialState
         * @memberOf vca.util.accordion
         * @private
         * @param {jQuery} $acc The accordion content
         * @returns {void}
         */
        function updateInitialState($acc) {
            const $heads = $acc.find(CONST.SELECTORS.head);
            let $activeHead = $heads.filter(function() {
                return $(this).hasClass(CONST.CSS_CLASS.active);
            });

            // // for multiple active heads, pick 1st out of them
            // $activeHead = $activeHead.eq(0);

            if (!$activeHead.length) {
                $activeHead = $heads.eq(0);
                $activeHead.trigger(util.customEvents.INTERACTION);
            }
        }

        /**
         * Start basic functionality
         * @function start
         * @memberOf vca.util.accordion
         * @private
         * @returns {void}
         */
        function start() {
            initializeAccordions();
        }

        /**
         * Bind events
         * @function bindEvents
         * @memberOf vca.util.accordion
         * @private
         * @returns {void}
         */
        function bindEvents() {
            listeners.push(
                $.subscribe(util.customEvents.LB_OPENED, function(data) {
                    initializeAccordions(data.content);
                })
            );

            $body.on(
                util.customEvents.INTERACTION,
                CONST.SELECTORS.head,
                accordianHeadingClickHandler
            );
        }

        /**
         * Unbinds all pre-existing events
         * @function teardown
         * @memberOf vca.util.accordion
         * @private
         * @returns {void}
         */
        function teardown() {
            while (listeners.length) {
                $.unsubscribe(listeners.pop());
            }

            $body.off(
                util.customEvents.INTERACTION,
                CONST.SELECTORS.head,
                accordianHeadingClickHandler
            );
        }

        /**
         * Initialize the utility
         * @function init
         * @memberOf vca.util.accordion
         * @private
         * @param {HTMLElement} elem The utility element
         * @returns {void}
         */
        function init() {
            teardown();
            bindEvents();

            start();
        }

        return {
            init: init
        };
    })(vca.$, vca.util);
})(window.vca);

/*global vca*/
/**
 * Lighbox utility
 * lightbox mould type  - vca-lb-center(default)    -> default lightbox position.
 *                      - vca-lb-full               -> cover full page
 *                      - vca-lb-left               -> Left
 *                      - vca-lb-right              -> Right
 */

(function(vca, base) {
    /**
     * lightbox Util
     * @namespace lightbox
     * @memberof vca.util
     */
    vca.util.lightbox = (function($, util, baseUtil) {
        // get all components
        const $html = $('html'),
            $body = $('body'),
            selectors = {
                overlay: '.base-lightbox-overlay',
                wrapper: '.base-lightbox-wrapper',
                content: '.base-lightbox-content',
                close: '.vca-lb-close',
                viewport: '#viewport',
                loader: '.vca-loader-wrapper',
                header: '.vca-lb-header',
                vcaWrapper: '.vca-lightbox-wrapper',
                vcaContent: '.vca-lightbox-content',
                backArrowBtn: '.vca-back-arrow',
                lightboxLevel: '.vca-lb-level'

                //TODO: Commenting this code causing regression on china login case on click of next button
                // vcaLightboxWrapper:
                //     '.base-lightbox-wrapper.vca-lightbox-wrapper'
            },
            cssClass = {
                lightboxOpen: 'base-lightbox-open',
                fullscreen: 'base-lightbox-fullscreen',
                large: 'base-lightbox-large',
                hidden: 'vca-hidden',
                hide: 'vca-hide',
                animateFromRight: 'vca-light-box-right',
                full: 'vca-lb-full',
                left: 'vca-lb-left',
                right: 'vca-lb-right',
                default: 'vca-lb-center',
                vcaMouldedLightbox: 'vca-lightbox',
                header: 'vca-lb-header',
                vcaContent: 'vca-lightbox-content',
                showBackArrowBtn: 'vca-show-back-arrow',
                lightboxLevel: 'vca-lb-level'
            };

        let $lightboxWrapper,
            $lightboxCloseBtn,
            $lightboxContent,
            $lightboxOverlay,
            $header,
            // $lighboxVideo, // will use this later once we have the video componenent
            $target,
            $loader,
            lightboxMould = 'default',
            customCssClass = '',
            headerText = '',
            cacheburst = false,
            currentLightboxStatus = false,
            lightboxStore = [],
            pageScrollPosition = 0,
            params;

        /**
         * initialize all component which are part of lightbox content
         * @function initializeLightboxContentComp
         * @private
         * @param {string} $Content html dom string
         * @memberOf vca.util.lightbox
         */
        function initializeLightboxContentComp($Content) {
            baseUtil.initialise($Content);
            vca.util.initialise($Content);

            // publish with new content
            $.publish(util.customEvents.LB_OPENED, [
                {
                    content: $Content
                }
            ]);
        }

        /**
         * Listen if any change happen in given array using few methods and if then call the callback menthod
         * @function listenChangesinArray
         * @private
         * @param {string} @arr array you want to listen to
         * @param {function} @callback function that will be called on any change inside array
         * @memberOf vca.util.lightbox
         */
        function listenChangesinArray(arr, callback) {
            // Add more methods here if you want to listen to them
            ['pop', 'push', 'shift', 'unshift', 'splice'].forEach(function(
                method
            ) {
                arr[method] = function() {
                    var res = Array.prototype[method].apply(arr, arguments),
                        args = arguments; // call normal behaviour

                    // if (arguments.length) {
                    //     arguments[0]['method'] = method;
                    // } else {
                    //     arguments = [{ method: method }];
                    // }
                    args[method] = method;
                    callback.apply(arr, args); // finally call the callback supplied
                    return res;
                };
            });
        }

        /**
         * It update lightboxStore Array with provided action
         * @function updateLightboxStore
         * @private
         * @param {string} @action action to be performed on lightboxStore
         * @memberOf vca.util.lightbox
         */
        function updateLightboxStore(action) {
            switch (action) {
                case 'push':
                    lightboxStore.push({
                        level: lightboxStore.length,
                        class: 'vca-lb-level-' + lightboxStore.length,
                        header: $header.text()
                    });
                    break;
                case 'pop':
                    lightboxStore.pop();
                    break;
                default:
                    return lightboxStore;
                    break;
            }
        }

        /**
         * It return a html template wrapped in the level specific container.
         * @function getLevelWrapedHtml
         * @private
         * @param {string} @data html template string to be render in lightbox
         * @memberOf vca.util.lightbox
         */
        function getLevelWrapedHtml(data) {
            let $level = $('<div>')
                .addClass(cssClass.lightboxLevel)
                .addClass(
                    cssClass.lightboxLevel + '-' + Number(lightboxStore.length)
                );

            let $content =
                typeof data === 'string' ? $(data) : $(data.prop('outerHTML'));

            return $level.html($content.clone());
        }

        /**
         * append content to lightbox content container and initialise all component specific to that html
         * @function appendContentAndInitHandler
         * @private
         * @param {string} data html string
         * @memberOf vca.util.lightbox
         */
        function appendContentAndInitHandler(data) {
            let lightboxLeveledContent = getLevelWrapedHtml(data);

            if (!currentLightboxStatus) {
                $lightboxContent.empty().html(lightboxLeveledContent);
                initializeLightboxContentComp(
                    $lightboxContent.find(
                        '.vca-lb-level-' + Number(lightboxStore.length)
                    )
                );
                updateLightboxStore('push');
                listenChangesinArray(lightboxStore, lightboxStoreUpdateHandler);
            } else {
                $lightboxContent
                    .find(selectors.lightboxLevel)
                    .addClass(cssClass.hide);
                $lightboxContent
                    .find('.vca-lb-level-' + Number(lightboxStore.length - 1))
                    .after(lightboxLeveledContent);

                initializeLightboxContentComp(
                    $lightboxContent.find(
                        '.vca-lb-level-' + Number(lightboxStore.length)
                    )
                );
                updateLightboxStore('push');
            }
        }

        /**
         * Add lightbox open specific classes and set lightbox status to open
         * @function addLightboxOpenStyle
         * @private
         * @memberOf vca.util.lightbox
         */
        function addLightboxOpenStyle() {
            $html.addClass(cssClass.lightboxOpen);
            $body.addClass(cssClass.lightboxOpen);
            $loader.addClass(cssClass.hidden);
            $lightboxCloseBtn.focus();
            setLightboxStatus(true);
        }

        /**
         * Set content inside lightbox content
         * @function setContent
         * @param {string} data html string
         * @private
         * @memberOf vca.util.lightbox
         */
        function setContent(data) {
            // check if response contains full page, then just insert the contents of body
            const doc = new DOMParser().parseFromString(data, 'text/html');
            if (doc.body) {
                data = doc.body.innerHTML;
            }
            // append the content in lightbox
            appendContentAndInitHandler(data);
            addLightboxOpenStyle();
        }

        /**
         * closeLightbox and destroy its content
         * @function closeLightbox
         * @public
         * @memberOf vca.util.lightbox
         */
        function closeLightbox() {
            $html.removeClass(cssClass.lightboxOpen);
            $body.removeClass(cssClass.lightboxOpen);

            if (util.matchmedia.narrow.matches) {
                $(selectors.viewport).attr(
                    'content',
                    'width=device-width, initial-scale=1'
                );
            }
            // reset to last scrolled position & reset the variable
            scrollToUserPos();
            // Clear other content if any
            $lightboxContent.empty();
            $lightboxWrapper.removeClass(cssClass.fullscreen);
            $lightboxWrapper.removeClass(cssClass.large);
            $header.empty();
            resetMouldType();
            resetLightboxStore();
            setLightboxStatus(false);
            $.publish(util.customEvents.LB_CLOSED);
        }

        /**
         * It will reset LightboxStore array
         * @function resetLightboxStore
         * @private
         * @memberOf vca.util.lightbox
         */
        function resetLightboxStore() {
            lightboxStore.splice(0, lightboxStore.length);
        }

        /**
         * errorHandler
         * @function errorHandler
         * @param  {[type]} error [description]
         */
        function errorHandler(error) {
            console.log('error', error, error.statusText);
        }

        /**
         * It will get html templete string from the given url
         * @function getData
         * @param {object} settings contain ajax call settings like url
         * @return {[promise]} either success or error
         */
        function getData(settings) {
            util.request
                .get(settings.url)
                .done(function(result, status, xhr) {
                    if (status === 'success' && xhr.status === 200) {
                        setContent(result);
                    }
                })
                .fail(errorHandler);
        }

        /**
         * Set Lightbox Data
         * @function setLightboxData
         * @public
         * @param {String} url page url
         * @memberOf vca.util.lightbox
         */
        function setLightboxData(targetUrl) {
            getData({
                url: targetUrl,
                type: 'GET'
            });

            if (util.matchmedia.narrow.matches) {
                $(selectors.viewport).attr(
                    'content',
                    'width=device-width, initial-scale=1, maximum-scale=1'
                );
            }
        }

        /**
         * It will update the lightbox config properties
         * @function updateLightboxConfig
         * @private
         * @param {Object} config page url
         * @param {boolean} isRefererTypeElement - whether it lightbox is called from an element or not.
         * @memberOf vca.util.lightbox
         */
        function updateLightboxConfig(config, isRefererTypeElement) {
            if (isRefererTypeElement) {
                lightboxMould = config.data('lightboxMould') || lightboxMould;
                customCssClass = config.data('customClass') || '';
                headerText = config.data('lightboxHeader') || '';
                cacheburst = config.data('cacheburst') || false;
                params = config.data('params');
            } else {
                if (config) {
                    lightboxMould = config.mould || lightboxMould;
                    customCssClass = config.customCssClass || '';
                    headerText = config.header || '';
                    cacheburst = config.cacheburst || false;
                    params = config.params;
                }
            }
        }

        /**
         * Open Lightbox
         * @function openLightbox
         * @public
         * @param @param {object} e event object
         * @memberOf vca.util.lightbox
         */
        function openLightbox(e, insider) {
            e.preventDefault();
            // get contentUrl for lightbox
            $target = e ? (insider ? $(e.target) : $(e.currentTarget)) : {};
            let contentUrl = $target.prop('href') || undefined;
            // get content for lightbox for the given url
            getContentForLightbox(contentUrl, $target, true);
        }

        /**
         * Open URL in Lightbox
         * @function openUrlInLightbox
         * @public
         * @param {String} url page path
         * @param {Object} config Object contain all basic config like mould type, custom class, header text,         cacheburst, etc.
         * @memberOf vca.util.lightbox
         */
        function openUrlInLightbox(url, config) {
            let contentUrl = url;
            // get content for lightbox for the given url
            getContentForLightbox(contentUrl, config, false);
        }

        /**
         * Method to open lightbox with content
         * @function openContentInLightBox
         * @memberOf vca.util.lightbox
         * @public
         * @param {HTMLElement} content The html to push into the lightbox
         * @param {Object} config Object contain all basic config like mould type, custom class, header text,         cacheburst, etc.
         */
        function openContentInLightBox(content, config) {
            initLightboxConfig(config, false);

            if (content.length) {
                appendContentAndInitHandler(content);
            }
            if (!currentLightboxStatus) {
                addLightboxOpenStyle();
            }
        }
        /**
         * Reset lightbox page scroll position to where user was
         * @function scrollToUserPos
         * @memberOf vca.util.lightbox
         * @private
         * @returns {void}
         */
        function scrollToUserPos() {
            // reset to last scrolled position & reset the variable
            util.scrollTo.position(pageScrollPosition, 0);
            pageScrollPosition = 0;
        }

        /**
         * Cache page scroll position where user is, before opening overlay
         * @function cachePageScrollPos
         * @memberOf vca.util.lightbox
         * @private
         * @returns {void}
         */
        function cachePageScrollPos() {
            // cache current page scroll position before opeing lightbox
            if (!Number(lightboxStore.length)) {
                pageScrollPosition = window.pageYOffset;
            }
        }
        /**
         * wrapper method to call getUrlHtml with given content url and initialize inital lightbox config
         * @function getContentForLightbox
         * @memberOf vca.util.lightbox
         * @private
         * @param {string} contentUrl url from where html template need to fetch
         * @param {Object} config Object contain all basic config like mould type, custom class, header text,         cacheburst, etc.
         * @param {boolean} isThroughDataAttr The html to push into the lightbox
         */
        function getContentForLightbox(contentUrl, config, isThroughDataAttr) {
            initLightboxConfig(config, isThroughDataAttr);

            if (contentUrl) {
                getUrlHtml(contentUrl);
            }
        }

        /**
         * wrapper method to call setLightboxData with cacheburst url if required
         * @function getUrlHtml
         * @param {string} contentUrl url from where html template need to fetch
         * @private
         * @memberOf vca.util.lightbox
         */
        function getUrlHtml(contentUrl) {
            const query = params ? `params=${params}` : null;
            if (cacheburst) {
                setLightboxData(
                    contentUrl +
                        '?cacheburst=' +
                        new Date().getTime() +
                        `${query ? `&${query}` : ''}`
                );
            } else {
                setLightboxData(contentUrl + `${query ? `?${query}` : ''}`);
            }
        }

        /**
         * initialize lightbox basic configuration
         * @function initLightboxConfig
         * @param {Object} config Object contain all basic config like mould type, custom class, header text,         cacheburst, etc.
         * @param {boolean} isThroughDataAttr The html to push into the lightbox
         * @private
         * @memberOf vca.util.lightbox
         */
        function initLightboxConfig(config, isThroughDataAttr) {
            // cache current page scroll position before opeing lightbox
            cachePageScrollPos();
            // show loader on page
            $loader.removeClass(cssClass.hidden);
            cacheburst = config.cacheburst || false;

            // update lightbox display configurations
            updateLightboxContainers();
            updateLightboxConfig(config, isThroughDataAttr);
            updateMouldType();
            // append header text
            $header.text(headerText);
        }

        /**
         * Update lightbox mould setting
         * @function updateMouldType
         * @private
         * @description It will update the type of lightbox to render like - full-page, left-only, right-only or center(default)
         * @memberOf vca.util.lightbox
         */
        function updateMouldType() {
            if (lightboxMould !== cssClass.default) {
                $body.addClass(cssClass.vcaMouldedLightbox);
            }
            $lightboxWrapper.addClass(
                [cssClass[lightboxMould], customCssClass].join(' ')
            );
        }

        /**
         * reset mould settind
         * @function resetMouldType
         * @private
         * @description It will reset all updated lightbox mould setting
         * @memberOf vca.util.lightbox
         */
        function resetMouldType() {
            $body.removeClass(cssClass.vcaMouldedLightbox);
            $lightboxWrapper.removeClass(
                [cssClass[lightboxMould], customCssClass].join(' ')
            );
        }

        /**
         * It will set lightbox status with the provided state, true for opend state and false for closed
         * @function setLightboxStatus
         * @param {boolean} state set state for lightbox
         * @private
         * @memberOf vca.util.lightbox
         */
        function setLightboxStatus(state) {
            return (currentLightboxStatus = state);
        }

        /**
         * It will return if lightbox is opened or not.
         * @function getLightboxStatus
         * @public
         * @memberOf vca.util.lightbox
         */
        function getLightboxStatus() {
            return currentLightboxStatus;
        }

        /**
         * It will set lightbox status with the provided state, true for opend state and false for closed
         * @function lightboxWrapperClickHandler
         * @private
         * @memberOf vca.util.lightbox
         */
        function lightboxWrapperClickHandler(event) {
            let $targetElement = $(event.target);
            /* Close lightbox if click outside */
            if (!$targetElement.parents(selectors.vcaWrapper).length) {
                closeLightbox();
            }
        }

        /**
         * It will bind events
         * @function bindEvents
         * @private
         * @memberOf vca.util.lightbox
         */
        function bindEvents() {
            $(document).on(
                util.customEvents.INTERACTION,
                '[data-lightbox]',
                openLightbox
            );

            $lightboxCloseBtn.on(util.customEvents.INTERACTION, closeLightbox);

            /* event delegation handler for lightbox wrapper*/
            $(document).on(
                util.customEvents.INTERACTION,
                selectors.vcaWrapper,
                lightboxWrapperClickHandler
            );

            if (!util.matchmedia.narrow.matches) {
                $lightboxOverlay
                    .on(util.customEvents.INTERACTION, closeLightbox)
                    .children()
                    .on(util.customEvents.INTERACTION, function(event) {
                        event.stopPropagation();
                    });
            }

            // close lightbox on keyboard escape key press
            $(window).on(util.customEvents.KEYUP, function(event) {
                let key = event.charCode || event.keyCode;
                if (key === 27) {
                    closeLightbox();
                }
            });

            $(selectors.backArrowBtn).on(
                util.customEvents.INTERACTION,
                backBtnClickHandler
            );
        }

        /**
         * Handler for lightboxStore array mutation
         * @function lightboxStoreUpdateHandler
         * @private
         * @memberOf vca.util.lightbox
         */
        function lightboxStoreUpdateHandler() {
            if (lightboxStore.length <= 1) {
                $lightboxWrapper
                    .find(selectors.backArrowBtn)
                    .removeClass(cssClass.showBackArrowBtn);
            } else {
                if (
                    !$lightboxWrapper
                        .find(selectors.backArrowBtn)
                        .hasClass(cssClass.showBackArrowBtn)
                ) {
                    $lightboxWrapper
                        .find(selectors.backArrowBtn)
                        .addClass(cssClass.showBackArrowBtn);
                }
            }
            vca.util.conciergeDetail.init();
        }

        /**
         * Handler for back button click interaction
         * @function backBtnClickHandler
         * @private
         * @memberOf vca.util.lightbox
         */
        function backBtnClickHandler() {
            $lightboxContent
                .find('.' + lightboxStore[lightboxStore.length - 1].class)
                .remove();
            updateLightboxStore('pop');
            $lightboxContent
                .find('.' + lightboxStore[lightboxStore.length - 1].class)
                .removeClass(cssClass.hide);
            $header.text(lightboxStore[lightboxStore.length - 1].header);
        }

        /**
         * Handler for lightbox container selectors
         * @function updateLightboxContainers
         * @private
         * @memberOf vca.util.lightbox
         */
        function updateLightboxContainers() {
            $lightboxWrapper = $(selectors.wrapper);
            $lightboxContent = $lightboxWrapper.find(selectors.content);
        }

        /**
         * Handler for cache intiail selectors
         * @function cacheVars
         * @private
         * @memberOf vca.util.lightbox
         */
        function cacheVars() {
            $loader = $(selectors.loader);
            //overlay
            $lightboxOverlay = $(selectors.overlay);
            //content
            $lightboxWrapper = $(selectors.wrapper);
            $lightboxContent = $lightboxWrapper.find(selectors.content);
            $lightboxCloseBtn = $lightboxWrapper.find(selectors.close);
            // $lighboxVideo = $(selectors.video);
            $header = $(selectors.header);
        }

        /**
         * Init Lightbox
         * @return {[type]} [description]
         */
        function init() {
            cacheVars();
            bindEvents();
        }

        return {
            init: init,
            closeLightbox: closeLightbox,
            openUrlInLightbox: openUrlInLightbox,
            openContentInLightBox: openContentInLightBox,
            getLightboxStatus: getLightboxStatus
        };
    })(vca.$, vca.util, base.util);
})(vca, base);

/*global vca, base*/
/**
 * Common utility keep & share data required by multiple components
 * If required fetch data from server
 */
(function () {
    const CONST = {
            SELECTORS: {
                ecommerceEnabled: 'ecommerce-enabled',
                defaultCountryCode: 'default-country-code',
                countryMapNz: 'countryMapNz',
                productConfigWrapper: '.vca-pdp-config-wrapper',
                pdpMain: '.vca-pdp-main',
                pdpPpc: '.vca-pdp-ppc',
                ccpInfoPrice: '.vca-ccp-price',
                ccpInfo: '.vca-ccp-info',
                vcaPdp: '.vca-product'
            },
            CLASSESS: {
                hide: 'vca-hide'
            },
            ATTRIBUTE: {
                dataPpcEnable: 'data-enable-price-per-country'
            },
            URL_TYPE: {
                pI: 'prodinfo',
                mul_pI: 'multiple-prodinfo',
                var: 'variants',
                mul_var: 'variants-multiple'
            },
            DATA_ATTR: {
                languageCode: 'language-code'
            },
            CLS_DATA: 'vcaClsData',
            IS_PPC_ENABLED: true
        },
        TRACK_INTERVAL_TIMEOUT = 0;

    /**
     * dataStore Util
     * @namespace dataStore
     * @memberof vca.util
     */
    vca.util.dataStore = (function ($, baseUtil, util) {
        let $html = $('html'),
            $body = $('body'),
            defaultCountryCode = $html.data('websiteCode') || null,
            defaultLangCode = $body.data(CONST.DATA_ATTR.languageCode),
            currentPagePath = '',
            currentPagePathWithoutSelector = '';
        if (
            defaultCountryCode == null ||
            defaultCountryCode.toUpperCase() == 'WW'
        ) {
            defaultCountryCode = $html.data('globalCc') || 'US';
        }

        // commerceEnabled = $body.data(CONST.SELECTORS.ecommerceEnabled);

        /**
         * getDefaultCountryCode
         * @public
         * @memberOf vca.util.dataStore
         * @return {string}
         */
        const getDefaultCountryCode = function () {
            return defaultCountryCode;
        };

        /**
         * getLangCode
         * @public
         * @memberOf vca.util.dataStore
         * @return {string}
         */
        const getLangCode = function () {
            return defaultLangCode.toLowerCase();
        };

        /**
         * isChina
         * @public
         * @memberOf vca.util.dataStore
         * @return {string}
         */
        const isChina = function () {
            return getDefaultCountryCode() === 'cn';
        };

        /**
         * isKorea
         * @public
         * @memberOf vca.util.dataStore
         * @return {string}
         */
        const isKorea = function () {
            return getDefaultCountryCode() === 'kr';
        };

        /**
         * getProfileStoreData
         * @public
         * @memberOf vca.util.dataStore
         * @return {string}
         */
        const getProfileStoreData = function () {
            if (vca.util.wcmmode.isAuthor) {
                return null;
            }

            return baseUtil.profileManager.getProfileStoreData();
        };

        // /**
        //  * getProductInfoJsonPath
        //  * @public
        //  * @memberOf vca.util.dataStore
        //  * @return {string}
        //  */
        // const getProductInfoJsonPath = function() {
        //     var profileStore = getProfileStoreData(),
        //         jsonUrl,
        //         countryMap = $body.data(CONST.SELECTORS.countryMapNz);

        //     if (
        //         profileStore &&
        //         profileStore.preferences &&
        //         profileStore.preferences.priceCountry
        //     ) {
        //         if (
        //             profileStore.preferences.priceCountry === 'NZ' &&
        //             typeof countryMap !== 'undefined'
        //         ) {
        //             jsonUrl = 'productinfo.' + countryMap + '.json';
        //         } else {
        //             jsonUrl =
        //                 'productinfo.' +
        //                 profileStore.preferences.priceCountry +
        //                 '.json';
        //         }
        //     } else if (
        //         profileStore &&
        //         profileStore.preferences &&
        //         profileStore.preferences.websiteCountry
        //     ) {
        //         jsonUrl =
        //             'productinfo.' +
        //             profileStore.preferences.websiteCountry +
        //             '.json';
        //     } else {
        //         jsonUrl = 'productinfo.' + defaultCountryCode + '.json';
        //     }

        //     return jsonUrl;
        // };

        // /**
        //  * getProductFilterJsonPath
        //  * @public
        //  * @memberOf vca.util.dataStore
        //  * @return {string}
        //  */
        // const getProductFilterJsonPath = function() {
        //     var profileStore = getProfileStoreData(),
        //         jsonUrl;

        //     if (profileStore && profileStore.preferences) {
        //         jsonUrl =
        //             'product-filter.' +
        //             profileStore.preferences.priceCountry +
        //             '.json';
        //     } else {
        //         jsonUrl = 'product-filter.' + defaultCountryCode + '.json';
        //     }

        //     return jsonUrl;
        // };

        /**
         * getCurrentPagePath
         * @public
         * @memberOf vca.util.dataStore
         * @return {string}
         */
        const getCurrentPagePath = function () {
            if (currentPagePath === '') {
                currentPagePath = window.location.pathname
                    .split('#')[0]
                    .replace('.html', '');
            }
            return currentPagePath;
        };

        /**
         * getCurrentPagePathWithoutSelector
         * @public
         * @memberOf vca.util.dataStore
         * @return {string}
         */
        const getCurrentPagePathWithoutSelector = function () {
            if (currentPagePathWithoutSelector === '') {
                currentPagePathWithoutSelector = window.location.pathname
                    .split('#')[0]
                    .replace(/\.(.*)html(.*)/, '');
            }
            return currentPagePathWithoutSelector;
        };

        // /**
        //  * isCommerceEnabled
        //  * @public
        //  * @memberOf vca.util.dataStore
        //  * @return {Boolean}
        //  */
        // const isCommerceEnabled = function() {
        //     return commerceEnabled;
        // };

        // /**
        //  * getLogoutPagePath
        //  * @public
        //  * @memberOf vca.util.dataStore
        //  * @return {string}
        //  */
        // const getLogoutPagePath = function() {
        //     currentPagePath = getCurrentPagePath();
        //     return currentPagePath + '.vcalogout.html';
        // };

        /**
         * Get request url
         * @function getProdInfoUrl
         * @memberOf vca.util.dataStore
         * @private
         * @param {String} urlType The urlType - based on vca.util.dataStore.CONST.URL_TYPE
         * @param {Array<String>} arrProds An array of product references - MANDATORY for URL_TYPE.mul_var AND URL_TYPE.mul_pI
         * @returns {URL} The request url for product info json
         */
        const getProdInfoUrl = function (urlType, arrProds) {
            const pagePath = getCurrentPagePathWithoutSelector();
            let reqUrl = '',
                replacer = '',
                clsData = JSON.parse(
                    util.cookieManager.getCookie(CONST.CLS_DATA)
                ),
                ppcCountry = null,
                websiteCode = $html.data('websiteCode').toUpperCase(),
                cleanedArrProds = null,
                profileStore = null,
                prodInfoPart = '.productinfo',
                refs = '';

            if (arrProds) {
                cleanedArrProds = arrProds.filter(function (ref) {
                    return ref && ref !== 'undefined';
                });
                refs = cleanedArrProds.unique().join('-');
            }

            if (CONST.IS_PPC_ENABLED) {
                try {
                    profileStore = util.throttle(function () {
                        baseUtil.profileManager.getProfileStoreData();
                    }, TRACK_INTERVAL_TIMEOUT)();
                    ppcCountry = profileStore.preferences.priceCountry;
                } catch (e) {
                    ppcCountry = defaultCountryCode
                        ? defaultCountryCode.toUpperCase()
                        : 'US';
                }
                if (clsData && clsData.ppcEnable && websiteCode === 'WW') {
                    $(CONST.SELECTORS.productConfigWrapper).attr(
                        CONST.ATTRIBUTE.dataPpcEnable,
                        true
                    );
                    $(CONST.SELECTORS.ccpInfo).attr(
                        CONST.ATTRIBUTE.dataPpcEnable,
                        true
                    );
                    $(CONST.SELECTORS.vcaPdp).attr(
                        CONST.ATTRIBUTE.dataPpcEnable,
                        true
                    );

                    $(CONST.SELECTORS.pdpPpc).removeClass(CONST.CLASSESS.hide);
                    $(CONST.SELECTORS.ccpInfoPrice).removeClass(
                        CONST.CLASSESS.hide
                    );
                    $(CONST.SELECTORS.pdpMain).attr(CONST.ATTRIBUTE.dataPpcEnable, true);
                    prodInfoPart = prodInfoPart + '.' + clsData.countryCode;
                } else {
                    prodInfoPart = prodInfoPart + '.' + ppcCountry;
                }
            }

            // create the url based on URL_TYPE
            if (urlType === CONST.URL_TYPE.pI) {
                replacer = prodInfoPart + '.json';
            } else if (urlType === CONST.URL_TYPE.var) {
                replacer = prodInfoPart + '.variants.json';
            } else if (urlType === CONST.URL_TYPE.mul_pI) {
                replacer = refs ? prodInfoPart + '.REF-' + refs + '.json' : '';
            } else if (urlType === CONST.URL_TYPE.mul_var) {
                replacer = refs
                    ? prodInfoPart + '.variants.REF-' + refs + '.json'
                    : '';
            } else {
                replacer = '';
            }

            reqUrl = replacer ? pagePath + replacer : replacer;

            return reqUrl;
        };

        return {
            getCurrentPagePath: getCurrentPagePath,
            // isCommerceEnabled: isCommerceEnabled,
            getCurrentPagePathWithoutSelector: getCurrentPagePathWithoutSelector,
            // getProductInfoJsonPath: getProductInfoJsonPath,
            getProfileStoreData: getProfileStoreData,
            getDefaultCountryCode: getDefaultCountryCode(),
            getLangCode: getLangCode(),
            // getProductFilterJsonPath: getProductFilterJsonPath,
            // getLogoutPagePath: getLogoutPagePath,
            getProdInfoUrl: getProdInfoUrl,
            isChina: isChina,
            isKorea: isKorea,

            CONST: CONST
        };
    })(vca.$, base.util, vca.util);
})();

/**
 * webStorage.js
 * HTML 5 Web storage js
 */
(function() {
    'use strict';

    const webStorage = window.sessionStorage;

    /**
     * IsInViewport Util
     * @namespace webStorage
     * @memberof vca.util
     */
    vca.util.webStorage = (function() {
        /**
         * set value of session storage item
         * @memberOf vca.util.webStorage
         * @private
         * @param {string} key containing the name of the key you want to create/update
         * @param {object} value containing the value you want to give the key you are creating/updating
         */
        function set(key, value) {
            if (key && value) {
                webStorage.setItem(key, value);
            }
        }

        /**
         * get value of session storage item
         * @memberOf vca.util.webStorage
         * @private
         * @param {string} key containing the name of the key you want to retrieve the value of
         * @returns {object} key's value
         */
        function get(key) {
            if (key) {
                return webStorage.getItem(key);
            }
        }

        /**
         * remove value from session storage item
         * @memberOf vca.util.webStorage
         * @private
         * @param {string} key containing the name of the key you want to remove
         */
        function remove(key) {
            if (key) {
                webStorage.removeItem(key);
            }
        }

        /**
         * clear all items in session storage
         * @memberOf vca.util.webStorage
         * @private
         */
        function clear() {
            webStorage.clear();
        }

        /**
         * show full session storage object
         * @memberOf vca.util.webStorage
         * @private
         * @returns {object} Storaged Session
         */
        function storage() {
            return webStorage;
        }

        return {
            set: set,
            get: get,
            remove: remove,
            clear: clear,
            storage: storage
        };
    })();
})();

/*global vca*/

/**
 * customSelect.js
 * functionality for the customSelect utility
 */
(function(vca, $, util) {
    'use strict';

    var CONST = {
        SELECTORS: {
            csMain: '.vca-custom-select-main',
            cs: '.vca-custom-select',
            csButton: '.vca-custom-select-button',
            csSelect: '.vca-custom-select',
            csUl: '.vca-custom-select-ul',
            csLi: '.vca-custom-select-li',
            csContent: '.vca-custom-select-content'
        },
        CLASSES: {
            selected: 'vca-selected',
            active: 'vca-active',
            disableCsButtonTextUpdate: 'disable-cs-button-text-update',
            csUl: 'vca-custom-select-ul'
        }
    };

    /**
     * Constructor for CustomSelect
     * @memberof vca.util.customSelect
     * @private
     * @constructor
     * @param {HTMLElement} elem The component element
     */
    function CustomSelect(elem) {
        this.$comp = $(elem);
        this.listeners = [];
        this.selectedOption = null;

        this.initialize.apply(this);
    }

    CustomSelect.prototype = {
        /**
         * csButton click event handler
         * @function csButtonClickHandler
         * @memberOf vca.util.customSelect.CustomSelect#
         * @private
         * @param {Event} e The click event
         * @returns {void}
         */
        csButtonClickHandler: function(e) {
            e.preventDefault();

            // if already open, close list
            if (this.$csUl.hasClass(CONST.CLASSES.active)) {
                this.closeSelect.call(this);
            } else {
                this.openSelect.call(this);
            }
        },

        /**
         * Close select
         * @function closeSelect
         * @memberOf vca.util.customSelect.CustomSelect#
         * @private
         * @returns {void}
         */
        closeSelect: function() {
            // remove aria attrs
            this.$csButton.removeAttr('aria-expanded');

            // close the list
            this.$csUl.removeClass(CONST.CLASSES.active);
        },

        /**
         * Open select
         * @function openSelect
         * @memberOf vca.util.customSelect.CustomSelect#
         * @private
         * @returns {void}
         */
        openSelect: function() {
            // add aria attrs
            this.$csButton.attr('aria-expanded', true);

            // open the list, and focus
            this.$csUl.addClass(CONST.CLASSES.active).focus();
        },

        /**
         * The document click event handler
         * @function documentClickHandler
         * @memberOf vca.util.customSelect.CustomSelect#
         * @private
         * @param {Event} e The click event
         * @returns {void}
         */
        documentClickHandler: function(e) {
            var $thisElem = $(e.target || e.currentTarget),
                isThisChild = this.$comp[0].contains($thisElem[0]);

            // close the dropdowns if not this custom select type
            if (!isThisChild) {
                // close the dropdowns
                this.closeSelect.call(this);
            }
        },

        /**
         * Method to set option for select
         * @function setOption
         * @memberOf vca.util.customSelect.CustomSelect#
         * @private
         */
        setOption: function(value) {
            if (!value || value === '#') {
                return;
            }
            let isSelectedOptionSet = false,
                $selectedOption = this.$csLi.filter(function() {
                    if (!isSelectedOptionSet) {
                        let liValue = this.dataset.value,
                            currentLiValue =
                                liValue && liValue !== '#'
                                    ? liValue
                                    : this.dataset.prodId;
                        let isThisSelectedOption =
                            String(currentLiValue).toLowerCase() ===
                            String(value).toLowerCase();
                        if (isThisSelectedOption) {
                            isSelectedOptionSet = true;
                            return isThisSelectedOption;
                        }
                    }
                }),
                $csContent = $selectedOption.find(CONST.SELECTORS.csContent);

            // update the selection on li
            $selectedOption
                .addClass(CONST.CLASSES.selected)
                .attr('aria-selected', true)
                .siblings()
                .removeClass(CONST.CLASSES.selected)
                .removeAttr('aria-selected');

            // update the selection text in button
            if (!this.$csUl.hasClass(CONST.CLASSES.disableCsButtonTextUpdate)) {
                this.$csButton
                    .html(this.disableFocus.call(this, $csContent.clone()))
                    .removeAttr('aria-expanded')
                    .focus();
            }

            // close the dropdown list & set attr
            this.$csUl
                .attr({
                    'aria-activedescendant': $selectedOption.attr('id'),
                    'aria-labelledby': $selectedOption.attr('id')
                })
                .removeClass(CONST.CLASSES.active);
        },

        /**
         * csLi click event handler
         * @function csLiClickHandler
         * @memberOf vca.util.customSelect.CustomSelect#
         * @private
         * @param {Event} e The click event
         * @returns {void}
         */
        csLiClickHandler: function(e) {
            e.preventDefault();

            var $thisElem = $(e.currentTarget || e.target);

            // set selected option in instance
            var $thisCurrentElem = $thisElem.data('value');
            this.selectedOption =
                $thisCurrentElem && $thisCurrentElem !== '#'
                    ? $thisCurrentElem
                    : $thisElem.data('prodId');

            // set option in html
            this.setOption.call(this, this.selectedOption);

            // publish selected event
            $.publish(util.customEvents.CS_SELECTED, [
                {
                    inst: this,
                    dataset: $thisElem[0].dataset
                }
            ]);
        },

        /**
         * Method to disable focus
         * @function disableFocus
         * @memberOf vca.util.customSelect.CustomSelect#
         * @private
         * @returns {HTMLElement}
         */
        disableFocus: function($elem) {
            return $elem.find('button, a').attr('tabindex', -1);
        },

        /**
         * csUl keydown event handler
         * @function csUlKeydownHandler
         * @memberOf vca.util.customSelect.CustomSelect#
         * @private
         * @param {Event} e The click event
         * @returns {void}
         */
        csUlKeydownHandler: function(e) {
            // trap focus
            util.focus.trapTabKey(this.$csUl, e);
        },

        /**
         * Cache variables being used
         * @function cacheVars
         * @memberOf vca.util.customSelect.CustomSelect#
         * @private
         */
        cacheVars: function() {
            this.$csButton = this.$comp.find(CONST.SELECTORS.csButton);
            this.$csUl = this.$comp.find(CONST.SELECTORS.csUl);
            this.$csLi = this.$comp.find(CONST.SELECTORS.csLi);
            this.type = this.$csButton.data('type');
        },

        /**
         * Bind events
         * @function bindEvents
         * @memberOf vca.util.customSelect.CustomSelect#
         * @private
         */
        bindEvents: function() {
            // this.listeners.push($.subscribe(util.customEvents.CLICK, this.update.bind(this)));

            this.$comp.on(
                util.customEvents.INTERACTION,
                CONST.SELECTORS.csButton,
                this.csButtonClickHandler.bind(this)
            );

            this.$comp.on(
                util.customEvents.INTERACTION,
                CONST.SELECTORS.csLi,
                this.csLiClickHandler.bind(this)
            );

            this.$comp.on(
                util.customEvents.KEYDOWN,
                CONST.SELECTORS.csUl,
                this.csUlKeydownHandler.bind(this)
            );

            // Namespaced click handler
            $(document).on(
                util.customEvents.INTERACTION + CONST.SELECTORS.cs,
                this.documentClickHandler.bind(this)
            );
        },

        /**
         * Unbinds all pre-existing events
         * @function teardown
         * @memberOf vca.util.customSelect.CustomSelect#
         * @private
         */
        teardown: function() {
            while (this.listeners.length) {
                $.unsubscribe(this.listeners.pop());
            }

            this.$comp.off(
                util.customEvents.INTERACTION,
                CONST.SELECTORS.csButton,
                this.csButtonClickHandler.bind(this)
            );

            this.$comp.off(
                util.customEvents.INTERACTION,
                CONST.SELECTORS.csLi,
                this.csLiClickHandler.bind(this)
            );

            $(document).off(
                util.customEvents.INTERACTION + CONST.SELECTORS.cs,
                this.documentClickHandler.bind(this)
            );
        },

        /**
         * Initialise CustomSelect
         * @function initialize
         * @memberOf vca.util.customSelect.CustomSelect#
         * @private
         */
        initialize: function() {
            this.cacheVars();
            this.teardown();
            this.bindEvents();
        }
    };

    /**
     * customSelect utility
     * @namespace customSelect
     * @memberof vca.util
     */
    vca.util.customSelect = (function() {
        var name = 'customSelectInst';

        /**
         * Initializes & returns the instance of CustomSelect
         * @function init
         * @memberOf vca.util.customSelect
         * @private
         * @param {HTMLElement} elem The component element
         */
        function init() {
            var $el = $(CONST.SELECTORS.csMain);

            $.each($el, function(_i, elem) {
                var $elem = $(elem),
                    inst = null;

                if (!$elem.data(name)) {
                    inst = new CustomSelect($elem);
                    $elem.data(name, inst);
                }
            });
        }

        return {
            init: init
        };
    })();
})(window.vca, vca.$, vca.util);

/**
 * addToWishlist.js
 * functionality for the addToWishlist utility
 */
(function(vca, base) {
    'use strict';

    const CONST = {
        SELECTORS: {
            addToWL: '.vca-addtowl',
            serviceMenuList: '.vca-sm-list'
        },
        CLASSES: {
            hide: 'vca-hide'
        },
        ATTRIBUTES: {
            ref: 'ref',
            tracking: 'tracking'
        },
        wishlistUrlKey: 'wlURL',
        wishlistEnabledKey: 'wlEnabled',
        wlPageUrl: 'wlPageUrl',
        wishlistEnabled: 'wlEnabled',
        refTitle: 'refTitle',
        wlSuportiveText: 'wlSuportiveText',
        wlLinkText: 'wlLinkText',
        productline: 'line',
        productid: 'prdid',
        productcollection: 'collection'
    };

    /**
     * addToWishlist utility
     * @namespace addToWishlist
     * @memberof vca.util
     */
    vca.util.addToWishlist = (function($, util, baseUtil) {
        const listeners = [];
        const $body = $('body');
        let msgString = null;

        /**
         * Tab click event handler
         * @function wishlistButtonClickHandler
         * @memberOf vca.util.addToWishlist
         * @private
         * @param {Event} e The click event
         * @returns {void}
         */
        function wishlistButtonClickHandler(e) {
            e.preventDefault();

            const $thisElem = $(e.currentTarget || e.target);
            const ref = $thisElem.data(CONST.ATTRIBUTES.ref);
            const isAdded = $thisElem.attr('data-added') === 'true';
            const defWL = baseUtil.wishlistManager.getDefaultWLName();
            const trackingAction = isAdded ? 'remove' : 'add';
            let tracking = $thisElem.data(CONST.ATTRIBUTES.tracking) || {};

            let trackingData;

            if (typeof tracking === 'object' && tracking !== null) {
                if (Array.isArray(tracking)) {
                    trackingData = tracking[0];
                } else {
                    trackingData = tracking;
                }
            } else {
                // converted tracking data string to object
                trackingData = vca.util.parseTrackingData.convertDataToObject(
                    tracking
                );
            }

            let trackingProduct = { product: trackingData };
            const engraving = '';

            util.loader.show();
            if (isAdded) {
                baseUtil.wishlistManager.deleteItemFromWishlist(
                    ref,
                    defWL,
                    engraving,
                    trackingProduct
                );
            } else {
                baseUtil.wishlistManager.addItemIntoWishlist(
                    ref,
                    defWL,
                    engraving,
                    trackingProduct
                );
                updateMsgInfo(
                    $thisElem.data(CONST.refTitle),
                    $thisElem.data(CONST.wlSuportiveText),
                    $thisElem.data(CONST.wlLinkText)
                );
            }

            // Tracking for wishlist item add/remove.
            if (trackingAction) {
                const productline = $thisElem.data(CONST.productline);
                const productid = $thisElem.data(CONST.productid);
                const productcollection = $thisElem.data(
                    CONST.productcollection
                );

                const trackingEventObj = {
                    event: 'wishlist',
                    line: productline,
                    collection: productcollection,
                    id: productid
                };

                baseUtil.analytics.pushDataToDataLayer(trackingEventObj);
            }
        }

        /**
         * On product added to wishlist, message handler
         * @function updateMsgInfo
         * @memberOf vca.util.addToWishlist
         * @private
         * @param {refTitle} reference title
         *        {supportiveText} supportive text
         *        {linkText} wishlist link text
         * @returns {void}
         */
        function updateMsgInfo(refTitle, supportiveText, linkText) {
            const link =
                '<a href="' +
                util.webStorage.get(CONST.wishlistUrlKey) +
                '" class="vca-wl-msg-link" title="' +
                linkText +
                '" >' +
                linkText +
                '</a>';
            refTitle = '"' + refTitle + '"';
            msgString = [refTitle, supportiveText, link].join(' ');
        }

        /**
         * Sync product WL icons
         * @function syncProds
         * @memberOf vca.util.addToWishlist
         * @private
         * @param {Array<JSON>} data The recieved data from the CMS-Base
         * @returns {void}
         */
        function syncProds(data) {
            util.loader.hide();
            try {
                const wlData =
                    data || baseUtil.wishlistManager.getWishlistStoreData();
                const $addToWL = $body.find(CONST.SELECTORS.addToWL);
                const prodList = wlData
                    ? wlData[0]
                        ? wlData[0].entries
                            ? wlData[0].entries
                            : []
                        : []
                    : [];

                // enable products which are already added
                $addToWL.attr('data-added', 'false');

                // enable products which are already added
                $.each(prodList, function(_i, item) {
                    $addToWL
                        .filter(function() {
                            return (
                                $(this).attr('data-ref') ===
                                item.globalReference
                            );
                        })
                        .attr('data-added', 'true');
                });
            } catch (e) {
                console.warn('Wishlist Store Data is not available.');
            }
        }

        /**
         * Handler to be called when product is added to wishlist
         * @function productWishlistAdditionHandler
         * @memberOf vca.util.addToWishlist
         * @private
         * @returns {void}
         */
        function productWishlistAdditionHandler() {
            util.toaster.show({
                isRichtextMessage: true,
                richtextMessage: msgString,
                wrapperClassToAdd: 'vca-wl-toaster',
                classToAdd: 'vca-body-02'
            });
        }

        /**
         * Bind events
         * @function bindEvents
         * @memberOf vca.util.addToWishlist
         * @private
         * @returns {void}
         */
        function bindEvents() {
            listeners.push(
                $.subscribe(baseUtil.customEvents.WISHLIST_UPDATED, syncProds),
                $.subscribe(
                    baseUtil.customEvents.WISHLIST_PRODUCT_ADD,
                    productWishlistAdditionHandler
                )
            );

            $body.on(
                util.customEvents.INTERACTION,
                CONST.SELECTORS.addToWL,
                wishlistButtonClickHandler
            );
        }

        /**
         * Unbinds all pre-existing events
         * @function teardown
         * @memberOf vca.util.addToWishlist
         * @private
         * @returns {void}
         */
        function teardown() {
            while (listeners.length) {
                $.unsubscribe(listeners.pop());
            }

            $body.off(
                util.customEvents.INTERACTION,
                CONST.SELECTORS.addToWL,
                wishlistButtonClickHandler
            );
        }

        /**
         * Initialize the utility
         * @function init
         * @memberOf vca.util.addToWishlist
         * @private
         * @param {HTMLElement} elem The utility element
         * @returns {void}
         */
        function init() {
            const $serviceMenu = $(CONST.SELECTORS.serviceMenuList);

            teardown();
            bindEvents();
            util.webStorage.set(
                CONST.wishlistUrlKey,
                $serviceMenu.data(CONST.wlPageUrl)
            );
            util.webStorage.set(
                CONST.wishlistEnabledKey,
                String($serviceMenu.data(CONST.wishlistEnabled))
            );
            // to make sure to check right state of products in WL
            syncProds();
        }

        return {
            init: init,
            teardown: teardown,
            syncProds: syncProds
        };
    })(vca.$, vca.util, base.util);
})(window.vca, window.base);

/**
 * conciergeDetail.js
 * functionality for conciergeDetail
 */

(function(vca, base) {
    'use strict';
    var CONST = {
        SELECTORS: {
            comp: '.vca-concierge-details',
            concierge: '.vca-inquire-by-phone .vca-concierge-details',
            crcLink: '.vca-crc-link',
            crcSelectorLink: '.vca-crc-selector-link'
        },
        CLASSES: {
            hide: 'vca-contact-number-hide'
        },
        ATTRIBUTES: {
            templateType: 'templateType',
            productDetail: 'product-detail',
            currencyCode: 'currencyCode',
            cookieName: 'crcClickPosition',
            crcLinkPosition: 'crcLinkPosition'
        }
    };

    /**
     * conciergeDetail utility
     * @namespace conciergeDetail
     * @memberof vca.util
     */
    vca.util.conciergeDetail = (function($, util, baseUtil) {
        var listeners = [],
            flagCountry,
            deferredData = $.Deferred(),
            $comp = null,
            $concierge = null,
            conciergeUrl = null,
            $templateType = null,
            $currencyCode = null,
            $isCountryCN = util.dataStore.isChina(),
            $crcLink = null,
            $crcSelectorLink = null;

        /**
         * Set and return profile country
         * @function setProfileCountry
         * @memberOf vca.util.conciergeDetail
         * @private
         * @param {json} data The profile data of user
         */
        function setProfileCountry(data) {
            // get profile data
            var profileStore = data || util.dataStore.getProfileStoreData();

            // check the availablity of profile data and store it
            if (
                profileStore &&
                profileStore.preferences &&
                profileStore.preferences.flagCountry
            ) {
                flagCountry = profileStore.preferences.flagCountry;

                // update the concierge elements in DOM
                updateDOM();
            }
        }

        /**
         * Save concierge data in memory
         * @function getConciergeData
         * @memberOf vca.util.conciergeDetail
         * @private
         * @returns {object} The promise object
         */
        function getConciergeData() {
            // try to get stored data and catch error in case
            try {
                var wsData = JSON.parse(util.webStorage.get(flagCountry)),
                    url = conciergeUrl + '.model.' + flagCountry + '.json';
            } catch (err) {
                console.log(err);
            }
            // check if profile data is stored in the memory
            if (wsData) {
                deferredData.resolve(wsData);
            } else {
                // make call
                util.request
                    .get(url)
                    .done(function(data) {
                        // save data in memory
                        util.webStorage.set(
                            [flagCountry],
                            JSON.stringify(data.conciergeDetails)
                        );
                        deferredData.resolve(data.conciergeDetails);
                    })
                    .fail(function() {
                        deferredData.reject();
                    });
            }

            return deferredData.promise();
        }

        /**
         * Append data in DOM elements
         * @function updateConciergeElements
         * @memberOf vca.util.conciergeDetail
         * @private
         * @param {object} conciergeData The stored profile data
         */
        function updateConciergeElements(conciergeData) {
            // for each element text
            $.each($comp, function(i) {
                var $thisEl = $comp.eq(i),
                    replacedContent = $thisEl.find('span').text(),
                    crcPhone = /{(phone)}/g,
                    weekdays = /{(weekdays)}/g,
                    weekends = /{(weekends)}/g;

                // check what to replace phone, weekdayTimings or weekendTimings
                if (crcPhone.test(replacedContent) && !!conciergeData.phone) {
                    replaceCrcData(
                        $thisEl,
                        conciergeData.phone,
                        replacedContent,
                        crcPhone
                    );
                    $thisEl.attr('href', 'tel://' + conciergeData.phone);
                } else if (
                    weekdays.test(replacedContent) &&
                    !!conciergeData.weekdayTimings
                ) {
                    replaceCrcData(
                        $thisEl,
                        conciergeData.weekdayTimings,
                        replacedContent,
                        weekdays
                    );
                } else if (
                    weekends.test(replacedContent) &&
                    !!conciergeData.weekendTimings
                ) {
                    replaceCrcData(
                        $thisEl,
                        conciergeData.weekendTimings,
                        replacedContent,
                        weekends
                    );
                }
            });
        }

        /**
         * Append data in DOM elements
         * @function replaceCrcData
         * @memberOf vca.util.conciergeDetail
         * @private
         * @param {HTMLElement, str, str, regex} $thisEl, updatedData, replacedContent, regex Element where need replacment, Content to be replaced, replacable string, regex string help in replacement
         */
        function replaceCrcData($thisEl, updatedData, replacedContent, regex) {
            replacedContent = replacedContent.replace(regex, updatedData);
            $thisEl.children('span').html(replacedContent);
            $thisEl.attr('title', replacedContent);

            // remove hide class
            $thisEl.removeClass(CONST.CLASSES.hide);
        }

        /**
         * Cache variables being used
         * @function cacheVars
         * @memberOf vca.util.conciergeDetail
         * @private
         */
        function cacheVars() {
            var $body = $('body');
            $comp = $body.find(CONST.SELECTORS.comp);
            $concierge = $body.find(CONST.SELECTORS.concierge);
            conciergeUrl = $body.data('conciergeUrl');
            $templateType = $body.data(CONST.ATTRIBUTES.templateType);
            $currencyCode = $body.data(CONST.ATTRIBUTES.currencyCode);
            $crcLink = $body.find(CONST.SELECTORS.crcLink);
            $crcSelectorLink = $body.find(CONST.SELECTORS.crcSelectorLink);
        }

        /**
         * Find the position at which the CRC link was clicked and save it in cookie
         * @function saveCRCLinkClickPosition
         * @memberOf vca.comp.conciergeDetail
         * @private
         * @returns {void}
         */
        function saveCRCLinkClickPosition() {
            let position = $crcLink.data('crcLinkPosition');

            util.cookieManager.setCookie(
                CONST.ATTRIBUTES.cookieName,
                position,
                1,
                ''
            );
        }

        /**
         * Trigger the Sensor Data analytics event on CRC click
         * @function triggerCNAnalyticsEvent
         * @memberOf vca.comp.conciergeDetail
         * @private
         * @returns {void}
         */
        function triggerCNAnalyticsEvent() {
            let buttonEl = $(this).data(CONST.ATTRIBUTES.type),
                buttonType = buttonEl ? buttonEl.type : 'N/A',
                cookieValue = util.cookieManager.getCookie(
                    CONST.ATTRIBUTES.cookieName
                ),
                defaultValue = $crcSelectorLink.data(
                    CONST.ATTRIBUTES.crcLinkPosition
                ),
                buttonPosition = cookieValue || defaultValue;

            let eventData = {
                buttonposition: buttonPosition,
                buttontype: buttonType,
                productname: 'N/A',
                productid: 'N/A',
                productref: 'N/A',
                currencycode: $currencyCode,
                productcategory: 'N/A',
                productprice: 'N/A',
                productcollection: 'N/A',
                productvertical: 'N/A'
            };
            baseUtil.analytics.pushToSensorsData('CallCenter', eventData);
            util.cookieManager.deleteCookie(CONST.ATTRIBUTES.cookieName);
        }

        /**
         * Bind events
         * @function bindEvents
         * @memberOf vca.util.conciergeDetail
         * @private
         * @returns {void}
         */
        function bindEvents() {
            // Handle Concierge analytics while on header menu.
            if ($concierge) {
                $concierge.on(util.customEvents.INTERACTION, function() {
                    vca.util.crcDataTracking.handleCrcPhoneClick('top');
                });
            }

            $crcLink.on(
                util.customEvents.INTERACTION,
                saveCRCLinkClickPosition
            );

            // Check if country is China and template is not PDP
            if (
                $isCountryCN &&
                $templateType != CONST.ATTRIBUTES.productDetail
            ) {
                $comp.on(
                    util.customEvents.INTERACTION,
                    triggerCNAnalyticsEvent
                );
            }

            if (!flagCountry) {
                // event subscribers
                listeners.push(
                    $.subscribe(
                        baseUtil.customEvents.PROFILE_UPDATED,
                        setProfileCountry
                    )
                );
            }
        }

        /**
         * Unbinds all pre-existing events
         * @function teardown
         * @memberOf vca.util.conciergeDetail
         * @private
         * @returns {void}
         */
        function teardown() {
            while (listeners.length) {
                $.unsubscribe(listeners.pop());
            }
        }

        /**
         * Update DOM elements
         * @function updateDOM
         * @memberOf vca.util.conciergeDetail
         * @private
         */
        function updateDOM() {
            if (conciergeUrl == '#') {
                return;
            }

            getConciergeData().done(function(data) {
                updateConciergeElements(data);
            });
        }

        /**
         * Initialise instance of conciergeDetail
         * @function init
         * @memberOf vca.util.conciergeDetail
         * @private
         */
        function init() {
            // cache all the variables
            cacheVars();

            // fetch user country from profile
            setProfileCountry();

            if (!flagCountry) {
                // Unbinds all pre-existing events
                teardown();
            }

            // Bind events
            bindEvents();
        }

        return {
            init: init
        };
    })(vca.$, vca.util, base.util);
})(window.vca, window.base);

/**
 * @file queryString.js
 * @fileOverview Utility for queryString functions.
 */
(function(vca, util) {
    'use strict';

    /**
     * queryString utility
     * @memberof vca.util
     */
    util.queryString = (function() {
        /**
         * Creates the query string json object
         * @memberof vca.util.queryString
         * @private
         * @param {string} url The url
         * @returns {JSON} The json object
         */
        function createObj(url) {
            var queryString = (url
                ? url.split('?')[1]
                : window.location.search.slice(1)
            ).split('#')[0];

            var pairs = queryString.split('&');

            var result = {};
            pairs.forEach(function(pair) {
                pair = pair.split('=');
                result[pair[0]] = decodeURIComponent(pair[1] || '');
            });

            return JSON.parse(JSON.stringify(result));
        }

        // function zzz() {
        //     location.search
        //         .slice(1)
        //         .split('&')
        //         .map(p => p.split('='))
        //         .reduce((obj, pair) => {
        //             const [key, value] = pair.map(decodeURIComponent);
        //             return { ...obj, [key]: value };
        //         }, {});
        // }

        // function aaa(str) {
        //     var obj = {};
        //     str.replace(/([^=&]+)=([^&]*)/g, function(m, key, value) {
        //         obj[decodeURIComponent(key)] = decodeURIComponent(value);
        //     });
        // }

        // function getQueryVariable(variable) {
        //     var query = window.location.search.substring(1);
        //     var vars = query.split('&');
        //     for (var i = 0; i < vars.length; i++) {
        //         var pair = vars[i].split('=');
        //         if (pair[0] == variable) {
        //             return pair[1];
        //         }
        //     }
        //     return false;
        // }

        // function getParameterByName(url, name) {
        //     var results = new RegExp('[?&]' + name + '=([^&#]*)').exec(url);

        //     if (results == null) {
        //         return null;
        //     }

        //     return decodeURI(results[1]) || 0;
        // }

        // /**
        //  * Returns the query string parameters as json object from a given url string
        //  * @memberof vca.util.queryString
        //  * @function get
        //  * @private
        //  * @param {string} key The query string key
        //  * @returns {string|JSON} returns value of key or the json
        //  */
        // function getValueFromUrl(key) {
        //     // creating the json object of the query string
        //     createObj();

        //     // if key, return its value
        //     // else return the json object
        //     return key ? qpResult[key] : qpResult;
        // }

        /******************************************************************/

        /**
         * Returns the query string parameters as json object
         * @memberof vca.util.queryString
         * @function get
         * @private
         * @param {string} key The query string key
         * @returns {string|JSON} returns value of key or the json
         */
        function get(key) {
            // creating the json object of the query string
            var obj = createObj();

            // if key, return its value
            // else return the json object
            return key ? obj[key] : obj;
        }

        return {
            get: get
        };
    })();
})(vca, vca.util);

/**
 * loadMoreBtn.js
 * functionality for content load more btn utility
 */
(function(w, vca) {
    'use strict';

    const CONST = {
        SELECTORS: {
            loadMore: '.vca-load-more-cta',
            loadMoreCont: '.vca-loadMore-wraper'
        },
        CSS_CLASS: {
            disabled: 'vca-disabled',
            hide: 'vca-hide'
        }
    };

    /**
     * content load more btn utility
     * @namespace loadMoreBtn
     * @memberof vca.util
     */
    vca.util.loadMoreBtn = (function($, util) {
        const $body = $('body');

        /**
         * Success handler
         * @function successHandler
         * @memberOf vca.util.loadMoreBtn
         * @private
         * @returns {void}
         */
        function successHandler(e, result) {
            const $loadMoreBtn = $(e.target || e.currentTarget),
                listSelector = $loadMoreBtn.data('listSelector'),
                $listData = $(result)
                    .find(listSelector)
                    .children(); // extract the content list from the server response

            // replacing btn with content, because the content itself contains the results along with the loadMoreBtn
            if ($loadMoreBtn.closest(CONST.SELECTORS.loadMoreCont).length) {
                $loadMoreBtn.closest(CONST.SELECTORS.loadMoreCont).replaceWith($listData);
            } else {
                $loadMoreBtn.replaceWith($listData);
            }
            
        }

        /**
         * Function to fetch new records on click action.
         * @function loadMoreClickHandler
         * @memberOf vca.util.loadMoreBtn
         * @private
         * @returns {void}
         */
        function loadMoreClickHandler(e) {
            e.preventDefault();

            const $loadMoreBtn = $(e.target || e.currentTarget),
                url = $loadMoreBtn.attr('href');

            util.request.get(url).done(function(result, status, xhr) {
                if (status === 'success' && xhr.status === 200) {
                    successHandler(e, result);
                }
            });
        }

        /**
         * Bind events
         * @function bindEvents
         * @memberOf vca.util.loadMoreBtn
         * @private
         * @returns {void}
         */
        function bindEvents() {
            $body.on(
                util.customEvents.INTERACTION,
                CONST.SELECTORS.loadMore,
                loadMoreClickHandler
            );
        }

        /**
         * Initialize the utility
         * @function init
         * @memberOf vca.util.loadMoreBtn
         * @private
         * @returns {void}
         */
        function init() {
            bindEvents();
        }

        return {
            init: init
        };
    })(vca.$, vca.util);
})(window, window.vca);

/**
 * videoPlayer.js
 * functionality for video player utility
 */
(function($, util, baseUtil) {
    'use strict';

    const SELECTORS = {
            videoTag: '.vca-video-tag',
            hiddenUnmuteBtn: '.vca-video-unmute-btn',
            playIcn: '.vca-play-pause-icn'
        },
        CLASS = {
            hide: 'vca-hide'
        },
        EVENTS = {
            play: 'play',
            ended: 'ended',
            pause: 'pause',
            timeupdate: 'timeupdate'
        },
        TIMEOUT = 1000,
        watched_0 = 0,
        watched_15 = 15,
        watched_25 = 25,
        watched_40 = 40,
        watched_50 = 50,
        watched_65 = 65,
        watched_75 = 75,
        watched_90 = 90,
        watched_100 = 100;

    let isCountryCN = util.dataStore.isChina();

    /**
     * Constructor function for  VideoPlayer
     * @memberOf vca.util
     */
    function VideoPlayer(elem) {
        this.$video = $(elem);
        this.init.call(this);
    }

    VideoPlayer.prototype = {
        listeners: [],

        // These variables needed to prevent double call of percentages from happening.
        not_watched_25: true,
        not_watched_50: true,
        not_watched_75: true,
        not_watched_100: true,
        initialPlay: true,

        /**
         * Start autoplay videos
         * @function autoplayIfReqd
         * @memberOf vca.util.videoPlayer.VideoPlayer#autoplayIfReqd
         * @private
         * @returns {void}
         */
        autoplayIfReqd: function() {
            let v = this.$video,
                muted = v.prop('muted') ? true : false,
                autoplay = v.prop('autoplay') ? true : false,
                isIOS = baseUtil.deviceDetection.isIOS();

            if (autoplay) {
                // v[0].currentTime = 0.01;
                v[0].muted = true;

                let videoPlayed = v[0].play();
                if (videoPlayed !== undefined) {
                    this.togglePlayIcon(true);
                    videoPlayed
                        .then(function() {
                            if (!isIOS && !muted) {
                                //why? reference - https://developers.google.com/web/updates/2017/09/autoplay-policy-changes

                                $(SELECTORS.hiddenUnmuteBtn)
                                    .on(util.customEvents.INTERACTION, function(
                                        e
                                    ) {
                                        e.preventDefault();
                                    })
                                    .trigger(util.customEvents.INTERACTION);
                            }
                        })
                        .catch(function(error) {
                            console.log(error);
                        });
                }
            }
        },

        /**
         * Initialise video source depending upon media
         * @function initialiseSource
         * @memberOf vca.util.videoPlayer.VideoPlayer#initialiseSource
         * @private
         * @returns {void}
         */
        initialiseSource: function() {
            let vid = this.$video[0],
                desktopVideoSrc = vid.dataset.desktopSrc,
                mobileVideoSrc = vid.dataset.mobileSrc,
                desktopVideoPoster = vid.dataset.desktopPoster,
                mobileVideoPoster = vid.dataset.mobilePoster;

            if (
                (desktopVideoPoster && mobileVideoPoster) ||
                mobileVideoPoster
            ) {
                if (util.matchmedia.narrow.matches && mobileVideoPoster) {
                    vid.poster = mobileVideoPoster;
                } else {
                    vid.poster = desktopVideoPoster;
                }
            }

            if (desktopVideoSrc && mobileVideoSrc) {
                if (util.matchmedia.narrow.matches && mobileVideoSrc) {
                    vid.src = mobileVideoSrc;
                } else {
                    vid.src = desktopVideoSrc;
                }
            }
        },

        /**
         * Video do not start from initial if change orientation
         * @function resumePlay
         * @memberOf vca.util.videoPlayer.VideoPlayer#loadVideo
         * @private
         * @returns {void}
         */
        resumePlay: function() {
            this.initialPlay = false;
        },

        /**
         * Video load and play functionality
         * @function loadVideo
         * @memberOf vca.util.videoPlayer.VideoPlayer#loadVideo
         * @private
         * @returns {void}
         */
        loadVideo: function() {
            let isIOS = baseUtil.deviceDetection.isIOS(),
                vid = this.$video,
                self = this;
            if (this.initialPlay) {
                vid[0].addEventListener(
                    'loadedmetadata',
                    function() {
                        vid[0].currentTime = 0.01;
                    },
                    false
                );

                self.initialiseSource();

                if (isIOS) {
                    vid[0].load();
                    vid[0].play();
                    util.throttle(function() {
                        vid[0].currentTime = 0.01;
                        vid[0].pause();
                        self.autoplayIfReqd();
                    }, TIMEOUT)();
                } else {
                    self.autoplayIfReqd();
                }
            }
        },

        /**
         * Video player tracking
         * @function videoPlayerTracking
         * @memberOf vca.util.videoPlayer.VideoPlayer#videoPlayerTracking
         * @private
         * @param {jQuery} vid The video object
         * @param {Number} videoPercent The video completion in percentage
         * @returns {void}
         */
        videoPlayerTracking: function(vid, videoPercent) {
            if (vid) {
                let title = vid.attr('title'),
                    videoTrackingEventObj = {},
                    sensorVideoTrackingObj = {};

                videoTrackingEventObj = {
                    event: 'video_tracking',
                    video_name: title,
                    video_status: videoPercent
                };

                sensorVideoTrackingObj = {
                    videostatus: videoPercent,
                    videoname: title
                };

                baseUtil.analytics.pushDataToDataLayer(videoTrackingEventObj);

                if (isCountryCN) {
                    baseUtil.analytics.pushToSensorsData(
                        'VideoProgress',
                        sensorVideoTrackingObj
                    );
                }
            }
        },

        /**
         * Video player completion stages like [25, 50, 75]
         * @function videoCompletionStages
         * @memberOf vca.util.videoPlayer.VideoPlayer#videoCompletionStages
         * @private
         * @returns {void}
         */
        videoCompletionStages: function() {
            let vid = this.$video,
                isLoopEnabled = vid[0].loop,
                currentTime = vid[0].currentTime,
                duration = vid[0].duration,
                percentage_watched = parseInt(
                    ((currentTime / duration) * 100).toFixed()
                );

            if (
                this.not_watched_25 &&
                percentage_watched > watched_15 &&
                percentage_watched <= watched_25
            ) {
                this.videoPlayerTracking.call(this, vid, watched_25);
                this.not_watched_25 = false;
            }

            if (
                this.not_watched_50 &&
                percentage_watched > watched_40 &&
                percentage_watched <= watched_50
            ) {
                this.videoPlayerTracking.call(this, vid, watched_50);
                this.not_watched_50 = false;
            }

            if (
                this.not_watched_75 &&
                percentage_watched > watched_65 &&
                percentage_watched <= watched_75
            ) {
                this.videoPlayerTracking.call(this, vid, watched_75);
                this.not_watched_75 = false;
            }

            if (
                isLoopEnabled &&
                this.not_watched_100 &&
                percentage_watched > watched_90 &&
                percentage_watched <= watched_100
            ) {
                this.videoPlayerTracking.call(this, vid, watched_100);
                this.not_watched_100 = false;
            }
        },

        /**
         * Video ends on ended event
         * @function videoPlayerEnded
         * @memberOf vca.util.videoPlayer.VideoPlayer#videoPlayerEnded
         * @private
         * @returns {void}
         */
        videoPlayerEnded: function() {
            this.not_watched_25 = true;
            this.not_watched_50 = true;
            this.not_watched_75 = true;
            this.not_watched_100 = true;
        },

        videoPlayerEndedTracking: function() {
            let vid = this.$video;
            this.videoPlayerTracking.call(this, vid, 100);
        },

        /**
         * Video starts on play event
         * @function videoPlayerStart
         * @memberOf vca.util.videoPlayer.VideoPlayer#videoPlayerStart
         * @private
         * @returns {void}
         */
        videoPlayerStart: function() {
            this.togglePlayIcon(true);
        },

        /**
         * Video starts on play event
         * @function videoPlayerStartTracking
         * @memberOf vca.util.videoPlayer.VideoPlayer#videoPlayerStartTracking
         * @private
         * @returns {void}
         */
        videoPlayerStartTracking: function() {
            let vid = this.$video;
            this.videoPlayerTracking.call(this, vid, watched_0);
        },

        /**
         * Toggle video play icon on play pause
         * @function togglePlayIcon
         * @memberOf vca.util.videoPlayer.VideoPlayer#togglePlayIcon
         * @private
         * @returns {void}
         */
        togglePlayIcon: function(status) {
            this.$video
                .parent()
                .find(SELECTORS.playIcn)
                .toggleClass(CLASS.hide, status);
        },

        /**
         * Video player interaction handler
         * @function videoOnInteractionHandler
         * @memberOf vca.util.videoPlayer.VideoPlayer#videoOnInteractionHandler
         * @private
         * @returns {void}
         */
        videoOnInteractionHandler: function(event) {
            let vid = this.$video;
            // toggle play/pause only when controls are enabled
            if (vid[0].controls) {
                event.preventDefault();

                // get click position
                const clickY = event.pageY - vid.offset().top,
                    height = parseFloat(vid.height());

                // avoids interference with controls
                if (clickY > 0.82 * height) return;

                // toggles play / pause
                if (vid[0].paused) {
                    vid[0].play();
                    this.togglePlayIcon(true);
                } else {
                    this.togglePlayIcon(false);
                    vid[0].pause();
                }
            }
        },

        /**
         * update video mute state with the given state
         * @function updateVideoMuteState
         * @memberOf vca.util.videoPlayer.VideoPlayer#updateVideoMuteState
         * @private
         * @returns {void}
         */
        updateVideoMuteState: function(event) {
            this.$video[0].muted = event.data.state;
        },

        /**
         * Unbind events
         * @function teardown
         * @memberOf vca.util.videoPlayer.VideoPlayer#teardown
         * @private
         * @returns {void}
         */
        teardown: function() {
            while (this.listeners.length) {
                $.unsubscribe(this.listeners.pop());
            }

            this.$video.off(EVENTS.timeupdate);

            this.$video.off(
                util.customEvents.INTERACTION,
                this.videoOnInteractionHandler
            );

            this.$video.off(
                util.customEvents.INTERACTION,
                SELECTORS.hiddenUnmuteBtn,
                this.updateVideoMuteState
            );
        },

        /**
         * Bind events
         * @function bindEvents
         * @memberOf vca.util.videoPlayer.VideoPlayer#bindEvents
         * @private
         * @returns {void}
         */
        bindEvents: function() {
            let self = this,
                autoPlay = this.$video.data('videoautoplay');
            self.$video.on(EVENTS.play, self.videoPlayerStart.bind(self));
            self.$video.on(EVENTS.ended, self.videoPlayerEnded.bind(self));

            if (autoPlay == false) {
                self.$video.on(
                    EVENTS.play,
                    self.videoPlayerStartTracking.bind(self)
                );
                self.$video.on(
                    EVENTS.ended,
                    self.videoPlayerEndedTracking.bind(self)
                );
                self.$video.on(
                    EVENTS.timeupdate,
                    self.videoCompletionStages.bind(self)
                );
            }

            if (autoPlay == true) {
                self.$video
                    .parent()
                    .on(
                        util.customEvents.INTERACTION,
                        SELECTORS.playIcn,
                        self.videoCompletionStages.bind(self)
                    );
            }

            this.$video.on(
                util.customEvents.INTERACTION,
                this.videoOnInteractionHandler.bind(this)
            );

            this.$video
                .parent()
                .on(
                    util.customEvents.INTERACTION,
                    SELECTORS.playIcn,
                    this.videoOnInteractionHandler.bind(this)
                );

            this.$video.on(
                util.customEvents.TOUCHEND,
                this.videoOnInteractionHandler.bind(this)
            );

            this.$video
                .parent()
                .on(
                    util.customEvents.TOUCHEND,
                    SELECTORS.playIcn,
                    this.videoOnInteractionHandler.bind(this)
                );

            this.$video.on(
                util.customEvents.INTERACTION,
                SELECTORS.hiddenUnmuteBtn,
                { state: true },
                this.updateVideoMuteState
            );

            // event subscribers
            this.listeners.push(
                $.subscribe(
                    util.customEvents.RESIZED,
                    this.resumePlay.bind(this)
                )
            );

            // event subscribers
            this.listeners.push(
                $.subscribe(
                    util.customEvents.RESIZED,
                    this.loadVideo.bind(this)
                )
            );
        },

        /**
         * Initialise a  element.
         * @memberOf vca.util.videoPlayer.VideoPlayer#init
         * @function init
         * @private
         * @returns {void}
         */
        init: function() {
            this.teardown();
            this.bindEvents();
            this.loadVideo();
        }
    };

    /**
     * Video player utility
     * @namespace videoPlayer
     * @memberof vca.util
     */
    util.videoPlayer = (function() {
        /**
         * Initialize the utility
         * @function init
         * @memberOf vca.util.videoPlayer
         * @public
         * @return {void}
         */
        function init() {
            let $videoElems = $(SELECTORS.videoTag);

            $videoElems.each(function(i) {
                new VideoPlayer($videoElems.eq(i));
            });
        }

        return {
            init: init
        };
    })();
})(vca.$, vca.util, base.util);

/**
 * toaster.js
 * functionality for the toaster utility
 */
(function(vca) {
    'use strict';

    var CONST = {
        SELECTORS: {
            toaster: '.vca-toaster',
            toasterClose: '.vca-t-close',
            toasterMsg: '.vca-t-msg'
        },
        CLASSES: {
            toasterHidden: 'vca-t-hidden'
        },
        HIDE_NOTIFICATION_TIMEOUT: 3000
    };

    /**
     * toaster utility
     * @namespace toaster
     * @memberof vca.util
     */
    vca.util.toaster = (function($, util) {
        var listeners = [],
            $body = $('body'),
            $toaster = null,
            $toasterMsg = null,
            _defaultSettings = {};

        /**
         * Apply toaster settings
         * @function applyToasterSettings
         * @memberOf vca.util.toaster
         * @private
         * @returns {void}
         */
        function applyToasterSettings(customSettings) {
            _defaultSettings = {
                // state of response
                isSuccess: true,

                // default success message, could be overridden in customSettings.successText if reqd
                successText: $toasterMsg.data('defaultSuccessMsg'),

                // default failure message, could be overridden in customSettings.failureText if reqd
                failureText: $toasterMsg.data('defaultFailureMsg'),

                // class to add to the toaster wrapper, if any
                wrapperClassToAdd: '',

                // class to add to the toaster msg, if any
                classToAdd: '',

                // default timeout to hide the notification
                timeout: CONST.HIDE_NOTIFICATION_TIMEOUT,

                // if after toaster hide, we require to reload the page
                reload: false,

                // if toaster msg is rich text, means custom html also included
                isRichtextMessage: false,

                // if toaster msg is rich text then richtext msg string
                richtextMessage: ''
            };

            return $.extend(_defaultSettings, customSettings);
        }

        /**
         * Activate the toaster
         * @function show
         * @memberOf vca.util.toaster
         * @private
         * @returns {void}
         */
        function show(customSettings) {
            var settings = applyToasterSettings(customSettings);

            // apply text/class to the toaster
            if (settings.richtextMessage) {
                $toasterMsg
                    .text('')
                    .html(settings.richtextMessage)
                    .addClass(settings.classToAdd);
            } else {
                $toasterMsg
                    .text(
                        settings.isSuccess
                            ? settings.successText
                            : settings.failureText
                    )
                    .addClass(settings.classToAdd);
            }
            // show toaster
            $toaster
                .removeClass(CONST.CLASSES.toasterHidden)
                .addClass(settings.wrapperClassToAdd);

            // hide toaster, after delay
            util.throttle(function() {
                // hide the toaster
                $toaster
                    .addClass(CONST.CLASSES.toasterHidden)
                    .removeClass(settings.wrapperClassToAdd);
                $toasterMsg.text('').removeClass(settings.classToAdd);

                if (settings.reload) {
                    // reload the page
                    window.location.reload();
                }
            }, settings.timeout)();
        }

        /**
         * Notification close click handler
         * @function toasterCloseBtnHandler
         * @memberOf vca.util.toaster
         * @private
         * @param {event} e The click event
         * @returns {void}
         */
        function toasterCloseBtnHandler(e) {
            e.preventDefault();

            $toaster
                .addClass(CONST.CLASSES.toasterHidden)
                .removeClass(settings.wrapperClassToAdd);
        }

        /**
         * Bind events
         * @function bindEvents
         * @memberOf vca.util.toaster
         * @private
         * @returns {void}
         */
        function bindEvents() {
            $body.on(
                util.customEvents.INTERACTION,
                CONST.SELECTORS.toasterClose,
                toasterCloseBtnHandler
            );
        }

        /**
         * Unbinds all pre-existing events
         * @function teardown
         * @memberOf vca.util.toaster
         * @private
         * @returns {void}
         */
        function teardown() {
            while (listeners.length) {
                $.unsubscribe(listeners.pop());
            }

            $body.off(
                util.customEvents.INTERACTION,
                CONST.SELECTORS.toasterClose,
                toasterCloseBtnHandler
            );
        }

        /**
         * Updates variables being used.
         * @function cacheVars
         * @memberOf vca.util.toaster
         * @private
         * @returns {void}
         */
        function cacheVars() {
            $toaster = $body.find(CONST.SELECTORS.toaster);
            $toasterMsg = $toaster.find(CONST.SELECTORS.toasterMsg);
        }

        /**
         * Initialize the utility
         * @function init
         * @memberOf vca.util.toaster
         * @private
         * @param {HTMLElement} elem The utility element
         * @returns {void}
         */
        function init() {
            cacheVars();
            teardown();
            bindEvents();
        }

        return {
            init: init,
            teardown: teardown,
            show: show
        };
    })(vca.$, vca.util);
})(window.vca);

/**
 * leaf.js
 * functionality for the leaf utility
 */
(function(vca, base) {
    'use strict';

    const CONST = {
        SELECTORS: {
            leafSearch: '.vca-leaf-search',
            leafPlayAgain: '.vca-leaf-playagain',
            leafLuck: '.vca-leaf-luck',
            leafPLP: '.vca-leaf-plp',
            leafText: '.vca-leaf-text',
            leafOverlay: '.vca-leaf-overlay',
            leafBanner: '.vca-leaf-banner'
        },
        CSS_CLASS: {
            hide: 'vca-hide',
            active: 'vca-leaf-active',
            leafSearch: 'vca-leaf-search',
            leafPLP: 'vca-leaf-plp',
            leafOverlayActive: 'vca-leaf-overlay-active',
            leafBannerHide: 'vca-leaf-banner-hidden'
        },
        ATTRIBUTES: {
            delay: 'delay',
            href: 'href',
            links: 'links',
            leafType: 'leafType'
        },
        DATA_KEY: {
            luckLinks: 'luckLinks',
            visitedLinks: 'visitedLinks',
            luckState: 'luckState',
            luckTrackingEvent: 'luck_feature',
            hideLuckTimeout: 'hideLuckTimeout'
        },
        HIDE_NOTIFICATION_TIMEOUT: 6,
        REDIRECT_TIMEOUT: 1000
    };

    /**
     * leaf utility for LUCK feature CTA on search and PLP
     * @namespace leaf
     * @memberof vca.util
     */
    vca.util.leaf = (function($, util, baseUtil) {
        let $leafSearch = null,
            $leafPlayAgain = null,
            $leafPLP = null,
            $leafLuck = null,
            leafLuckEnabled = null,
            playAgainEnabled = null,
            $leafOverlay = null,
            $isPLPactive = false,
            $isPlayAgainActive = false,
            $body = $('body'),
            plpdelay = 0,
            luckTextDelay = 3000,
            $leafBanner = null,
            isCountryCN = util.dataStore.isChina(),
            scrollPos = 0;

        /**
         * Luck Leaf hide show on scroll
         * @function initScrollBehavior
         * @memberOf vca.util.leaf
         * @private
         * @param {event} scroll event
         * @returns {void}
         */
        function initScrollBehavior() {
            let elemPosition = document.body.getBoundingClientRect().top;
            if (elemPosition > scrollPos) {
                $leafPLP.hasClass(CONST.CSS_CLASS.active)
                    ? $leafPLP.removeClass(CONST.CSS_CLASS.active)
                    : '';
                $leafPlayAgain.hasClass(CONST.CSS_CLASS.active)
                    ? $leafPlayAgain.removeClass(CONST.CSS_CLASS.active)
                    : '';
            } else {
                $leafPLP.hasClass(CONST.CSS_CLASS.active)
                    ? ''
                    : $leafPLP.addClass(CONST.CSS_CLASS.active);
                $leafPlayAgain.hasClass(CONST.CSS_CLASS.active)
                    ? ''
                    : $leafPlayAgain.addClass(CONST.CSS_CLASS.active);
            }
            scrollPos = elemPosition;
        }

        /**
         * Luck Leaf click handler
         * @function triggerLeafClickHandler
         * @memberOf vca.util.leaf
         * @private
         * @param {event} e The click event
         * @returns {void}
         */
        function triggerLeafClickHandler(e) {
            setLoaderEffect();
            e.preventDefault();
            util.throttle(function() {
                const $currentTarget = $(e.currentTarget || e.target),
                    visitedLink = $currentTarget.attr(CONST.ATTRIBUTES.href);
                let allLinks = [],
                    linkString = '';
                if ($currentTarget.hasClass(CONST.CSS_CLASS.leafSearch)) {
                    linkString = $leafSearch.data(CONST.ATTRIBUTES.links) || '';
                } else if ($currentTarget.hasClass(CONST.CSS_CLASS.leafPLP)) {
                    linkString = $leafPLP.data(CONST.ATTRIBUTES.links) || '';
                }
                allLinks = linkString.split(',');
                clearLinks(CONST.DATA_KEY.visitedLinks);
                saveLinks(allLinks, CONST.DATA_KEY.luckLinks);
                saveLinks(visitedLink, CONST.DATA_KEY.visitedLinks);
                setLuckState();
                luckEventTracking(visitedLink);
                window.location.href = visitedLink;
            }, CONST.REDIRECT_TIMEOUT)();
        }

        /**
         * Play Again Leaf click handler
         * @function triggerPlayAgainClickHandler
         * @memberOf vca.util.leaf
         * @private
         * @param {event} e The click event
         * @returns {void}
         */
        function triggerPlayAgainClickHandler(e) {
            setLoaderEffect();
            e.preventDefault();
            util.throttle(function() {
                const $currentTarget = $(e.currentTarget || e.target),
                    visitedLink = $currentTarget.attr(CONST.ATTRIBUTES.href);
                setLuckState();
                saveLinks(visitedLink, CONST.DATA_KEY.visitedLinks);
                luckEventTracking(visitedLink);
                window.location.href = visitedLink;
            }, CONST.REDIRECT_TIMEOUT)();
        }

        /**
         * Activate the leaf for search,PLP,PlayAgain
         * @function show
         * @memberOf vca.util.leaf
         * @private
         * @returns {void}
         */
        function showLuckCTA() {
            initPlayAgain();
            initPLPCTA();
            initSearchCTA();
        }

        /**
         * Activate the play again luck leaf
         * @function initPlayAgain
         * @memberOf vca.util.leaf
         * @private
         * @returns {void}
         */
        function initPlayAgain() {
            let isPlayAgain = util.webStorage.get(CONST.DATA_KEY.luckState);
            if (isPlayAgain) {
                displayPlayAgainCTA();
            } else {
                $leafPlayAgain.addClass(CONST.CSS_CLASS.hide);
                clearLinks(CONST.DATA_KEY.luckLinks);
                clearLinks(CONST.DATA_KEY.visitedLinks);
            }
            util.webStorage.remove(CONST.DATA_KEY.luckState);
        }

        /**
         * Activate the search luck leaf
         * @function initSearchCTA
         * @memberOf vca.util.leaf
         * @private
         * @returns {void}
         */
        function initSearchCTA() {
            let allLinks = [],
                linkString = '',
                selectedLink = '';
            linkString = $leafSearch.data(CONST.ATTRIBUTES.links) || '';
            allLinks = linkString.split(',');
            selectedLink = getRandomLink(allLinks);
            //if play again or PLP Luck CTA is active, do not display Find Your Luck CTA in search bar
            if (selectedLink !== '' && !$isPLPactive && !$isPlayAgainActive) {
                $leafSearch.attr('href', selectedLink);
                $leafSearch.parent().removeClass(CONST.CSS_CLASS.hide);
            }
        }

        /**
         * Activate the PLP luck leaf
         * @function initPLPCTA
         * @memberOf vca.util.leaf
         * @private
         * @returns {void}
         */
        function initPLPCTA() {
            let allLinks = [],
                linkString = '',
                selectedLink = '';
            linkString = $leafPLP.data(CONST.ATTRIBUTES.links) || '';
            allLinks = linkString.split(',');
            selectedLink = getRandomLink(allLinks);
            //if play again is active, do not display Find Your Luck CTA on PLP
            if (selectedLink !== '' && !$isPlayAgainActive) {
                $leafPLP.attr('href', selectedLink);
                $isPLPactive = true;
                $leafPLP.removeClass(CONST.CSS_CLASS.hide);
                util.throttle(function() {
                    $leafPLP.addClass(CONST.CSS_CLASS.active);
                }, plpdelay)();
                if (vca.util.matchmedia.narrow.matches) {
                    util.throttle(function() {
                        $leafPLP
                            .find(CONST.SELECTORS.leafText)
                            .addClass(CONST.CSS_CLASS.hide);
                    }, plpdelay + luckTextDelay)();
                }
            }
        }

        /**
         * Display the play again luck CTA
         * @function displayPlayAgainCTA
         * @memberOf vca.util.leaf
         * @private
         * @returns {void}
         */
        function displayPlayAgainCTA() {
            const allLinks = getStoredLinks(CONST.DATA_KEY.luckLinks) || [],
                visitedlinks = getStoredLinks(CONST.DATA_KEY.visitedLinks),
                unVisitedLinks = getUnVisitedLinks(allLinks, visitedlinks),
                selectedLink = getRandomLink(unVisitedLinks);
            if (selectedLink !== '') {
                $leafPlayAgain.attr(CONST.ATTRIBUTES.href, selectedLink);
                $leafPlayAgain.addClass(CONST.CSS_CLASS.active);
                $isPlayAgainActive = true;
                stickyMessageHandler();
            }
        }

        /**
         * Display the sticky note on target page load
         * @function stickyMessageHandler
         * @memberOf vca.util.leaf
         * @private
         * @returns {void}
         */
        function stickyMessageHandler() {
            let timeout =
                $leafOverlay.data(CONST.DATA_KEY.hideLuckTimeout) ||
                CONST.HIDE_NOTIFICATION_TIMEOUT;
            $leafBanner.removeClass(CONST.CSS_CLASS.leafBannerHide);
            // hide sticky note, after delay
            util.throttle(function() {
                // hide sticky note
                $leafBanner.addClass(CONST.CSS_CLASS.leafBannerHide);
            }, timeout * 1000)();
        }

        /**
         * Get unvisited target links
         * @function getUnVisitedLinks
         * @memberOf vca.comp.leaf
         * @private
         * @param {Array,Array} allLinks,visitedLinks
         * @returns {Float} The array of unvisited links
         */
        function getUnVisitedLinks(allLinks, visitedLinks) {
            const unvisitedlinks = allLinks.filter(function(i) {
                return this.indexOf(i) < 0;
            }, visitedLinks);

            if (unvisitedlinks.length == 0 && allLinks.length > 0) {
                clearLinks(CONST.DATA_KEY.visitedLinks);
                return allLinks;
            }
            return unvisitedlinks;
        }
        /**
         * Get random target links
         * @function getRandomLink
         * @memberOf vca.comp.leaf
         * @private
         * @param {Array} items
         * @returns {String} The unvisited link
         */
        function getRandomLink(items) {
            return items[Math.floor(Math.random() * items.length)] || '';
        }

        /**
         * Get stored links from session storage
         * @function getStoredLinks
         * @memberOf vca.comp.leaf
         * @private
         * @param {String} storage
         * @returns {Array} The array of all target links
         */
        function getStoredLinks(storage) {
            return JSON.parse(util.webStorage.get(storage)) || [];
        }

        /**
         * Save target links in session storage
         * @function saveLinks
         * @memberOf vca.comp.leaf
         * @private
         * @param {String or Array,String} visitedlink,storage
         * @returns {void}
         */
        function saveLinks(visitedlink, storage) {
            let savedlinks = getStoredLinks(storage);
            if (Array.isArray(visitedlink)) {
                savedlinks = visitedlink;
            } else {
                savedlinks.push(visitedlink);
            }

            util.webStorage.set(storage, JSON.stringify(savedlinks));
        }

        /**
         * Delete target links from session storage
         * @function clearLinks
         * @memberOf vca.comp.leaf
         * @private
         * @param {String} storage
         * @returns {void}
         */
        function clearLinks(storage) {
            util.webStorage.remove(storage);
        }

        /**
         * Set play again state in session storage
         * @function setLuckState
         * @memberOf vca.comp.leaf
         * @private
         * @returns {void}
         */
        function setLuckState() {
            util.webStorage.set(CONST.DATA_KEY.luckState, true);
        }

        /**
         * Set leaf loader
         * @function setLoaderEffect
         * @memberOf vca.comp.leaf
         * @private
         * @returns {void}
         */

        function setLoaderEffect() {
            $leafOverlay.addClass(CONST.CSS_CLASS.leafOverlayActive);
        }

        /**
         * luck event cta click tracking
         * @function luckEventTracking
         * @memberOf vca.comp.leaf
         * @private
         * @returns {void}
         */
        function luckEventTracking(url) {
            // luck cta click tracking
            if (!isCountryCN) {
                let trackingEventObj = {};

                trackingEventObj = {
                    event: CONST.DATA_KEY.luckTrackingEvent,
                    nextpage_uri: url
                };
                baseUtil.analytics.pushDataToDataLayer(trackingEventObj);
            }
        }

        /**
         * Bind events
         * @function bindEvents
         * @memberOf vca.util.leaf
         * @private
         * @returns {void}
         */
        function bindEvents() {
            if (leafLuckEnabled) {
                $body.on(
                    util.customEvents.INTERACTION,
                    CONST.SELECTORS.leafLuck,
                    triggerLeafClickHandler
                );
            }
            if (playAgainEnabled) {
                $body.on(
                    util.customEvents.INTERACTION,
                    CONST.SELECTORS.leafPlayAgain,
                    triggerPlayAgainClickHandler
                );
            }
            if (leafLuckEnabled || playAgainEnabled) {
                $(window).on(util.customEvents.SCROLL, () => {
                    util.throttleHandler(initScrollBehavior, 250);
                });
            }
        }

        /**
         * cache DOM variables being used.
         * @function cacheVars
         * @memberOf vca.util.loader
         * @private
         * @returns {void}
         */
        function cacheVars() {
            $leafSearch = $body.find(CONST.SELECTORS.leafSearch);
            $leafPlayAgain = $body.find(CONST.SELECTORS.leafPlayAgain);
            $leafPLP = $body.find(CONST.SELECTORS.leafPLP);
            plpdelay = $leafPLP.data(CONST.ATTRIBUTES.delay);
            $leafBanner = $body.find(CONST.SELECTORS.leafBanner);
            $leafOverlay = $body.find(CONST.SELECTORS.leafOverlay);
            $leafLuck = $body.find(CONST.SELECTORS.leafLuck);
            leafLuckEnabled = $leafLuck.data(CONST.ATTRIBUTES.leafType);
            playAgainEnabled = $leafPlayAgain.data(CONST.ATTRIBUTES.leafType);
        }

        /**
         * Initialize the utility
         * @function init
         * @memberOf vca.util.loader
         * @returns {void}
         */
        function init() {
            cacheVars();
            bindEvents();
            showLuckCTA();
        }

        return {
            init: init
        };
    })(vca.$, vca.util, base.util);
})(window.vca, window.base);

/**
 * pageTransition.js
 * functionality for page transitions utility
 */
(function(vca) {
    'use strict';
    const CONST = {
        CSS_CLASS: {
            loading: 'vca-ajax-loading',
            progressing: 'vca-progressing'
        }
    };

    /**
     * page transitions utility
     * @namespace pageTransition
     * @memberof vca.util
     */
    vca.util.pageTransition = (function($) {
        /**
         * initialize native
         * @function initNative
         * @memberOf vca.util.pageTransition
         * @private
         * @returns {void}
         */
        function initNative() {
            window.addEventListener('beforeunload', function(e) {
                const $activeElement = $(e.target.activeElement);
                const isProgress = $activeElement.hasClass(CONST.CSS_CLASS.progressing);
                const isMailto = $activeElement.is('[href^=mailto:]');
                const isTel = $activeElement.is('[href^=tel:]');

                if (!isProgress && !isMailto && !isTel) {
                    $('main').addClass(CONST.CSS_CLASS.loading);
                }
            });
        }

        // /**
        //  * initialize barba2
        //  * @function initBarba2
        //  * @memberOf vca.util.pageTransition
        //  * @private
        //  * @returns {void}
        //  */
        // function initBarba2() {
        //     w.barba.hooks.before(function(data) {
        //         $('body').addClass('vca-ajax-loading');
        //         $('.vca-slider-overlay').click();
        //         console.log(data);
        //     });
        //     w.barba.hooks.after(function(data) {
        //         $('body').removeClass('vca-ajax-loading');
        //         console.log(data);
        //     });
        //     w.barba.init({
        //         prevent: function(obj) {
        //             // console.log(el);
        //             return (
        //                 obj.el.classList &&
        //                 obj.el.classList.contains('no-barba')
        //             );
        //         },
        //         debug: true,
        //         transitions: [
        //             {
        //                 name: 'vca',
        //                 leave: function(data) {
        //                     var done = this.async();
        //                     TweenMax.to(data.current.container, 1, {
        //                         opacity: 1,
        //                         onComplete: done
        //                     });
        //                 },
        //                 enter: function(data) {
        //                     var done = this.async();
        //                     TweenMax.from(data.next.container, 1, {
        //                         opacity: 1,
        //                         onComplete: done
        //                     });
        //                 }
        //             }
        //         ]
        //     });
        // }

        // /**
        //  * initialize barba1
        //  * @function initBarba1
        //  * @memberOf vca.util.pageTransition
        //  * @private
        //  * @returns {void}
        //  */
        // function initBarba1() {
        //     var transEffect = Barba.BaseTransition.extend({
        //         fadeInNewcontent: function(nc) {
        //             nc.hide();
        //             var _this = this;
        //             $(this.oldContainer)
        //                 .fadeOut(1000)
        //                 .promise()
        //                 .done(() => {
        //                     nc.css('visibility', 'visible');
        //                     nc.fadeIn(1000, function() {
        //                         _this.done();
        //                     });
        //                 });
        //         },
        //         start: function() {
        //             this.newContainerLoading.then(function() {
        //                 return this.fadeInNewcontent($(this.newContainer));
        //             });
        //         }
        //     });
        //     Barba.Pjax.getTransition = function() {
        //         return transEffect;
        //     };
        //     Barba.Pjax.start();
        // }
        /**
         * Initialize the utility
         * @function init
         * @memberOf vca.util.pageTransition
         * @private
         * @returns {void}
         */
        function init() {
            // initBarba1();
            // initBarba2();
            initNative();
        }
        return {
            init: init
        };
    })(vca.$);
})(vca);

/**
 * marketPopin.js
 * functionality for market Pop in
 */
(function(w, vca) {
    'use strict';
    const CONST = {
        SELECTORS: {
            clsComp: '.vca-cls',
            frag: '.vca-mar-pop-frg',
            ligWrap: '.vca-lightbox-wrapper',
            ligCont: '.vca-lightbox-content',
            ligHead: '.vca-lb-header-wrapper',
            marketPopin: '.vca-market-popin',
            ddlMain: '.vca-custom-select-main'
        },
        CLASSES: {
            custClass: 'vca-mplightbox',
            contHeight: 'vca-cont-hight',
            hide: 'vca-hide'
        }
    };

    /**
     * marketPopin utility
     * @namespace marketPopin
     * @memberof vca.util
     */
    vca.util.marketPopin = (function($, util) {
        let maxAge = null,
            cookieName = 'showpopin',
            feCookieName = 'marketPopin',
            cookiePath = null,
            $body = $('body'),
            listeners = [],
            $mpfPath = $body.find(CONST.SELECTORS.frag),
            mpfOverlay = $mpfPath.data('href'),
            $ligWrap = $body.find(CONST.SELECTORS.ligWrap);

        /**
         * initMarketPopin function
         * @memberof vca.util.marketPopin
         * @private
         * @param {HTMLElement} elem The component element
         * @returns {void}
         */
        function initMarketPopin() {
            util.customSelect.init();
            let $ddlMainMarketPopin = $(CONST.SELECTORS.marketPopin).find(
                    CONST.SELECTORS.ddlMain
                ),
                customSelectCountryCode = $(CONST.SELECTORS.marketPopin)
                    .find(CONST.SELECTORS.clsComp)
                    .data('countryCode'),
                customSelectLangCode = $(CONST.SELECTORS.marketPopin)
                    .find(CONST.SELECTORS.clsComp)
                    .data('languageCode');
            // setting country code as EN if the country code is WW as we dont have any code against ww code in dropdown
            if (customSelectCountryCode == 'WW') {
                customSelectCountryCode = 'EN';
            }
            $.each($ddlMainMarketPopin, function(i) {
                let $main = $ddlMainMarketPopin.eq(i),
                    customSelectInst = $main.data('customSelectInst'),
                    valueToUpdate = null;

                if (Boolean(customSelectInst)) {
                    // set country
                    if (customSelectInst.type === 'country') {
                        valueToUpdate = customSelectCountryCode + '-';
                    }

                    // set language
                    if (customSelectInst.type === 'language') {
                        valueToUpdate =
                            customSelectCountryCode +
                            '-' +
                            customSelectLangCode;
                    }

                    // set custom dropdown option
                    customSelectInst.setOption(valueToUpdate);
                }
            });
        }

        /**
         * Initialize the component
         * @function init
         * @memberOf vca.util.marketPopin
         * @private
         * @param {HTMLElement} elem The component element
         * @returns {void}
         */
        function init() {
            if (util.wcmmode.isEditMode || !mpfOverlay || mpfOverlay === '#') {
                return;
            }

            if (util.cookieManager.getCookie(cookieName)) {
                if (!util.cookieManager.getCookie(feCookieName)) {
                    util.cookieManager.setCookie(
                        feCookieName,
                        'true',
                        maxAge,
                        cookiePath
                    );

                    vca.util.lightbox.openUrlInLightbox(mpfOverlay, {
                        customCssClass: 'vca-mplightbox',
                        header: 'Market Popin',
                        cacheburst: false
                    });

                    $ligWrap
                        .find(CONST.SELECTORS.ligHead)
                        .addClass(CONST.CLASSES.hide);

                    $ligWrap
                        .find(CONST.SELECTORS.ligCont)
                        .addClass(CONST.CLASSES.contHeight);
                }
            }

            listeners.push(
                $.subscribe(util.customEvents.LB_OPENED, initMarketPopin)
            );
        }

        return {
            init: init
        };
    })(vca.$, vca.util);
})(window, window.vca);

/*global vca*/

/**
 * ccProduct.js
 * functionality for the ccProduct utility
 */
(function(vca, $, util) {
    'use strict';

    const CONST = {
        SELECTORS: {
            card: '.vca-cc-product',
            price: '.vca-ccp-price'
        },
        CLASSES: {
            hide: 'vca-hide'
        }
    };

    /**
     * Constructor for CCProduct
     * @memberof vca.util.ccProduct
     * @private
     * @constructor
     * @param {HTMLElement} elem The component element
     */
    function CCProduct(elem) {
        this.$comp = $(elem);
        this.listeners = [];
        this.gRef = null;

        this.initialize.apply(this);
    }

    CCProduct.prototype = {
        /**
         * Update info
         * @function updateCardInfo
         * @memberOf vca.util.ccProduct.CCProduct#
         * @private
         * @param {json} data The product data
         */
        updateCardInfo: function(data) {
            let newPriceVal;

            try {
                if (data.articleType === 'model') {
                    newPriceVal = this.$price
                        .data('fromPriceLabel')
                        .replace('{}', data.formattedPrice);
                } else {
                    newPriceVal = data.formattedPrice;
                }
                newPriceVal = this.getPriceWithTaxLabel(data);
            } catch (e) {
                newPriceVal = '-';
            }

            this.$price.html(newPriceVal);
            this.isPriceUpdated = true;
        },

        /**
         * It will return the price with respective tax label attached.
         * @function getPriceWithTaxLabel
         * @memberOf vca.util.ccProduct.CCProduct#
         * @private
         */
        getPriceWithTaxLabel: function(data) {
            const includingTaxLabel = this.$price.data('inclTaxLabel') || '',
                excludingTaxLabel = this.$price.data('exclTaxLabel') || '';
            let priceVal = '';

            let taxLabel = data.tax ? includingTaxLabel : excludingTaxLabel;

            if (util.dataStore.getLangCode === 'ar') {
                priceVal = priceVal.concat(taxLabel, ' ', data.formattedPrice);
            } else {
                priceVal = priceVal.concat(data.formattedPrice, ' ', taxLabel);
            }
            return priceVal;
        },

        /**
         * Start basic flow
         * @function start
         * @memberOf vca.util.ccProduct.CCProduct#
         * @private
         */
        start: function() {
            util.productCache.registerCard(this);
        },

        /**
         * Cache variables being used
         * @function cacheVars
         * @memberOf vca.util.ccProduct.CCProduct#
         * @private
         */
        cacheVars: function() {
            this.$price = this.$comp.find(CONST.SELECTORS.price);
            this.gRef = this.$comp.data('globalRef');
            this.isPriceUpdated = false;
        },

        /**
         * Initialise ccProduct
         * @function initialize
         * @memberOf vca.util.ccProduct.CCProduct#
         * @private
         */
        initialize: function() {
            this.cacheVars();

            this.start();
        }
    };

    /**
     * ccProduct utility
     * @namespace ccProduct
     * @memberof vca.util
     */
    vca.util.ccProduct = (function() {
        var name = 'ccProductInst';

        /**
         * Initializes & returns the instance of ccProduct
         * @function init
         * @memberOf vca.util.ccProduct
         * @private
         * @param {Array<HTMLElement>} $ccProductsList The wrapper of cards
         */
        function init($ccProductsList) {
            var $el =
                $ccProductsList && $ccProductsList.length
                    ? $ccProductsList.find(CONST.SELECTORS.card)
                    : $(CONST.SELECTORS.card);

            // console.log('ccProductInst', $el.length, $el);

            $.each($el, function(_i, elem) {
                var $elem = $(elem),
                    inst = null;

                if (!$elem.data(name)) {
                    inst = new CCProduct($elem);
                    $elem.data(name, inst);
                }
            });
        }

        return {
            init: init
        };
    })();
})(window.vca, vca.$, vca.util);

/*global vca*/

/**
 * productListTracking.js
 * functionality for the productListTracking utility
 */
(function(vca, $, util, baseUtil) {
    'use strict';
    const CONST = {
        SELECTORS: {
            productCard: '.vca-product-track',
            productsContainer: '.vca-product-track-container',
            elementInView: '.is-in-view',
            product: '.vca-srl-ref-link',
            productWrapper: '.vca-srl-product-tile'
        },
        ATTRIBUTES: {
            trackingProduct: 'tracking-product',
            isSelleble: 'is-sellable',
            brand: 'VCA',
            currencyCode: 'currency-code',
            title: 'title',
            templateType: 'templateType',
            pageUri: 'page-uri',
            productPosition: 'productPosition'
        },
        EVENTS: {
            view: 'view_item_list',
            click: 'select_item'
        },
        CLASSES: {
            isInView: 'is-in-view',
            isVisited: 'is-visited'
        },
        STORAGE_KEYS: {
            productIndex: 'productIndex',
            pageType: 'pageType',
            positionInPage: 'positionInPage'
        }
    };

    /**
     * productListTracking utility
     * @namespace productListTracking
     * @memberof vca.util
     */
    vca.util.productListTracking = (function() {
        let $body = $('body'),
            pageType = '';

        /**
         * track the product view and product click when visible on screen
         * @function getTheDataAttributes
         * @memberOf vca.util.productListTracking
         * @private
         * @returns {object}
         * @param { element,index,productPosition }  - Target Element
         */

        function getTheDataAttributes(element, index, productPosition) {
            let trackingProduct =
                $(element).data(CONST.ATTRIBUTES.trackingProduct) || {};

            if (typeof trackingProduct === 'string') {
                // converted tracking data string to object
                trackingProduct = vca.util.parseTrackingData.convertDataToObject(
                    trackingProduct
                );
            }

            const {
                    materialStrap,
                    line,
                    materialCase,
                    collection,
                    ref,
                    materialJewelry,
                    isavailable,
                    price,
                    name,
                    variant,
                    id,
                    category,
                    specialEdition,
                    dial
                } = trackingProduct,
                isSelleble = $(element).data(CONST.ATTRIBUTES.isSelleble),
                pageType =
                    $body
                        .data(CONST.ATTRIBUTES.templateType)
                        .split('-')
                        .join(' ') || 'N/A',
                pageUri = $(element).data(CONST.ATTRIBUTES.pageUri) || 'N/A',
                positionInPage = productPosition || 'product push',
                itemListName = pageType + ': ' + positionInPage,
                itemListId = pageType + ' - ' + itemListName + ' - ' + pageUri,
                isAvailable =
                    isavailable == 'true' ? 'in stock' : 'out of stock';

            return {
                item_id: id || 'N/A',
                item_name: name || 'N/A',
                item_brand: CONST.ATTRIBUTES.brand || 'N/A',
                item_category: category || 'N/A',
                item_variant: variant || 'N/A',
                price: price || 'N/A',
                item_collection: collection || 'N/A',
                item_line: line || 'N/A',
                quantity: 1,
                item_size: 'N/A',
                item_sellable: isSelleble || 'N/A',
                item_material_case: materialCase || 'N/A',
                item_material_jewelry: materialJewelry || 'N/A',
                item_material_strap: materialStrap || 'N/A',
                item_material_leather: 'N/A',
                item_special_edition: specialEdition || 'N/A',
                item_dial: dial || 'N/A',
                item_engraved: 'N/A',
                item_embossed: 'N/A',
                item_adjusted: 'N/A',
                item_personalized: 'N/A',
                item_available: isAvailable || 'N/A',
                item_reference: ref || 'N/A',
                item_list_name: itemListName,
                item_list_id: itemListId,
                index: index + 1 || 'N/A'
            };
        }

        /**
         * track the product view and product click when visible on screen
         * @function trackProductGridSection
         * @memberOf vca.util.productListTracking
         * @private
         * @returns {void}
         * @param {elements,eventType,index,productPosition}
         */

        function trackProductGridSection(
            elements,
            eventType,
            index,
            productPosition
        ) {
            let itemDetails = [],
                currencyCode =
                    $body.data(CONST.ATTRIBUTES.currencyCode) || 'N/A';

            if (eventType == CONST.EVENTS.view) {
                $(elements)
                    .find(CONST.SELECTORS.productCard)
                    .each(function(_i, element) {
                        let item = getTheDataAttributes(
                            element,
                            _i,
                            productPosition
                        );
                        itemDetails.push(item);
                    });
            } else {
                if (eventType == CONST.EVENTS.click) {
                    storeProductIndexPageType(index, pageType);
                    const item = getTheDataAttributes(
                        elements,
                        index,
                        productPosition
                    );
                    itemDetails.push(item);
                }
            }

            let trackingEventObj = {
                event: eventType,
                ecommerce: {
                    currency: currencyCode,
                    items: itemDetails
                }
            };
            baseUtil.analytics.pushDataToDataLayer(trackingEventObj);
        }

        /**
         *  Observer Callback Function
         * @function observerCallback
         * @memberOf vca.util.productListTracking
         * @private
         * @returns {void}
         * @param {entries, observer}
         */

        function inViewObserverCallback(entries) {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const ele = entry.target;
                    $(ele).addClass(CONST.CLASSES.isInView);
                }
            });
            let itemDetails = [],
                currencyCode =
                    $body.data(CONST.ATTRIBUTES.currencyCode) || 'N/A';

            // needed all the elements at once which are inView, not just the single elements
            $body
                .find(CONST.SELECTORS.elementInView)
                .each(function(_, element) {
                    const i = $(this)
                        .parents(CONST.SELECTORS.productsContainer)
                        .find(CONST.SELECTORS.productCard)
                        .index(this);
                    const productPosition = $(this)
                        .parents(CONST.SELECTORS.productsContainer)
                        .data(CONST.ATTRIBUTES.productPosition);
                    let item = getTheDataAttributes(
                        element,
                        i,
                        productPosition
                    );

                    itemDetails.push(item);

                    $(this)
                        .removeClass(CONST.CLASSES.isInView)
                        .addClass(CONST.CLASSES.isVisited);
                });

            if (itemDetails.length > 0) {
                let trackingEventObj = {
                    event: CONST.EVENTS.view,
                    ecommerce: {
                        currency: currencyCode,
                        items: itemDetails
                    }
                };
                baseUtil.analytics.pushDataToDataLayer(trackingEventObj);
            }
        }

        /**
         *  Observer Function to target the element
         * @function isInViewObserver
         * @memberOf vca.util.productListTracking
         * @private
         * @returns {observer} observer
         * @param {void}
         */
        function isInViewObserver() {
            let observerOptions = {
                rootMargin: '0px',
                threshold: 1
            };

            var observer = new IntersectionObserver(
                inViewObserverCallback,
                observerOptions
            );

            return observer;
        }

        /**
         *  Tracking the product card when it's in view 100%
         * @function trackingCardWhenInView
         * @memberOf vca.util.productListTracking
         * @private
         * @returns {observer} observer
         * @param {void}
         */
        function trackingCardWhenInView() {
            const observer = isInViewObserver();
            $body.find(CONST.SELECTORS.productCard).each((i, ele) => {
                if (ele) {
                    observer.observe(ele);
                }
            });
        }

        /**
         * storeing product index and page type in session storage
         * @function storeProductIndexPageType
         * @memberOf vca.util.productListTracking
         * @private
         * @param { index,pageType }  - Target Element index and page template
         * @returns {void}
         */
        function storeProductIndexPageType(index, pageType) {
            util.webStorage.set(CONST.STORAGE_KEYS.productIndex, index + 1);
            util.webStorage.set(CONST.STORAGE_KEYS.pageType, pageType);
        }

        /**
         *  storeing product position type in session storage
         * @function storeProductPosition
         * @memberOf vca.util.productListTracking
         * @private
         * @param { productPosition }  - Target Element product position on product detail page
         * @returns {void}
         */
        function storeProductPosition(productPosition) {
            util.webStorage.set(
                CONST.STORAGE_KEYS.positionInPage,
                productPosition
            );
        }

        /**
         * Bind events
         * @function bindEvents
         * @memberOf vca.util.productListTracking
         * @private
         * @returns {void}
         */
        function bindEvents() {
            // when product container comes in the viewport
            util.throttle(function() {
                trackingCardWhenInView();
            }, 100)();
            $body.on(
                util.customEvents.INTERACTION,
                CONST.SELECTORS.product,
                function() {
                    const index = $(CONST.SELECTORS.product).index(this);
                    storeProductIndexPageType(index, pageType);
                }
            );

            $body.on(
                util.customEvents.INTERACTION,
                CONST.SELECTORS.productCard,
                function() {
                    const index = $(this)
                        .parents(CONST.SELECTORS.productsContainer)
                        .find(CONST.SELECTORS.productCard)
                        .index(this);
                    const productPosition = $(this)
                        .parents(CONST.SELECTORS.productsContainer)
                        .data(CONST.ATTRIBUTES.productPosition);
                    storeProductPosition(productPosition);

                    trackProductGridSection(
                        this,
                        CONST.EVENTS.click,
                        index,
                        productPosition
                    );
                }
            );
        }

        /**
         * Cache variables being used.
         * @function cacheVars
         * @memberOf vca.util.productListTracking
         * @private
         * @returns {void}
         */
        function cacheVars() {
            pageType = $body.data(CONST.ATTRIBUTES.templateType)
                ? $body.data(CONST.ATTRIBUTES.templateType).replace(/-/g, ' ')
                : 'N/A';
        }

        /**
         * Initializes & returns the instance of productListTracking
         * @function init
         * @memberOf vca.util.productListTracking
         * @private
         */
        function init() {
            cacheVars();
            bindEvents();
        }

        return {
            init: init
        };
    })(window.vca, vca.$, vca.util, base.util);
})(window.vca, vca.$, vca.util, base.util);

/**
 * forms.js
 * functionality for forms
 */

(function(vca) {
    'use strict';

    /**
     * forms utility
     * @namespace forms
     * @memberof vca.util
     */
    vca.util.forms = (function($) {
        /**
         * getFormData instance of forms
         * @function getFormData
         * @memberOf vca.util.forms
         * @private
         * @param {Object} $form form object
         * @returns {json} Form json
         */
        function getFormData($form) {
            // cache all the variables
            let formObjects = {};
            const form = $form.serializeArray();

            $.each(form, function(i, v) {
                formObjects[v.name] = v.value;
            });

            return formObjects;
        }

        return {
            getFormData: getFormData
        };
    })(vca.$);
})(window.vca);

/**
 * threesixty.js
 * functionality for threesixty view utility
 */
(function(vca, base) {
    'use strict';

    const CONST = {
        SELECTORS: {
            comp: '.vca-product',
            threesixtyItemLink: '.vca-pdp-threesixty-item-link',
            threesixtyFullScreen: '.vca-threesixty-fullscreen',
            closeIcon: '.vca-icn-close'
        },
        CLASSES: {
            hide: 'vca-hide'
        }
    };

    /**
     * threesixty utility
     * @namespace threesixty
     * @memberof vca.util
     */
    vca.util.threesixty = (function($, util, baseUtil) {
        let $comp = null,
            $closeIcon = null,
            $threesixtyItemLink = null,
            $threesixtyFullScreen = null,
            isCountryCN = util.dataStore.isChina();
        /**
         * ThreesixtyFullScreen Show click event handler
         * @function showThreesixtyFullScreen
         * @memberOf vca.util.threesixty
         * @private
         * @returns {void}
         */
        function showThreesixtyFullScreen() {
            $threesixtyFullScreen.removeClass(CONST.CLASSES.hide);

            // PDP 360 feature sensor tracking
            if (isCountryCN) {
                baseUtil.analytics.pushToSensorsData('Pdp360');
            } else {
                let trackingEventObj = {};

                trackingEventObj = {
                    event: 'pdp_360'
                };
                //gtm tacking
                baseUtil.analytics.pushDataToDataLayer(trackingEventObj);
            }
        }

        /**
         * ThreesixtyFullScreen close click event handler
         * @function hideThreesixtyFullScreen
         * @memberOf vca.util.threesixty
         * @private
         * @returns {void}
         */
        function hideThreesixtyFullScreen() {
            $threesixtyFullScreen.addClass(CONST.CLASSES.hide);
        }

        /**
         * Handler for cache intiail selectors
         * @function cacheVars
         * @private
         * @memberOf vca.util.threesixty
         */
        function cacheVars() {
            $comp = $(CONST.SELECTORS.comp);
            $threesixtyFullScreen = $comp.find(
                CONST.SELECTORS.threesixtyFullScreen
            );
            $threesixtyItemLink = $comp.find(
                CONST.SELECTORS.threesixtyItemLink
            );
            $closeIcon = $threesixtyFullScreen.find(CONST.SELECTORS.closeIcon);
        }

        /**
         * Bind events
         * @function bindEvents
         * @memberOf vca.util.threesixty
         * @private
         * @returns {void}
         */
        function bindEvents() {
            $threesixtyItemLink.on(
                util.customEvents.INTERACTION,
                showThreesixtyFullScreen
            );
            $closeIcon.on(
                util.customEvents.INTERACTION,
                hideThreesixtyFullScreen
            );
        }

        /**
         * Unbinds all pre-existing events
         * @function teardown
         * @memberOf vca.util.threesixty
         * @private
         * @returns {void}
         */
        function teardown() {
            $threesixtyItemLink.off(
                util.customEvents.INTERACTION,
                showThreesixtyFullScreen
            );
            $closeIcon.off(
                util.customEvents.INTERACTION,
                hideThreesixtyFullScreen
            );
        }

        /**
         * Initialize the utility
         * @function init
         * @memberOf vca.util.threesixty
         * @private
         * @returns {void}
         */
        function init() {
            cacheVars();
            teardown();
            bindEvents();
        }

        return {
            init: init
        };
    })(vca.$, vca.util, base.util);
})(window.vca, window.base);

/* global vca */
/* reference link https://stackoverflow.com/a/15016605
/**
 * base64Str.js
 * @fileOverview Provides a utility function to decode base64 string.
 */
(function(vca, $, util) {
    'use strict';

    /**
     * Utility for performing decode base64 string
     * @memberof vca.util
     */
    util.base64Str = (function() {
        
        /**
         * Method to decode base64 string
         * @function decodeBase64
         * @memberOf vca.util.base64Str
         * @private
         * @param {String} str The encoded string
         * @returns {String} decoded string
         */
        function decodeBase64(str) {
            let striObj = {},
                allStrKeys = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
                strCharCode = String.fromCharCode,
                strLen = str.length,
                decodeStr = '',
                charKey,
                size = 0,
                b = 0,
                i, x, a;
            
            for (i = 0; i < 64; i++) {
                striObj[allStrKeys.charAt(i)] = i;
            }

            for (x = 0; x < strLen; x++) {
                charKey = striObj[str.charAt(x)];
                b = (b<<6) + charKey;
                size += 6;
                
                while (size >= 8) {
                    ((a = (b >>> (size-=8))&0xff) || (x<(strLen-2))) && (decodeStr+=strCharCode(a));
                }
            }

            return decodeStr;
        }

        return {
            decodeBase64: decodeBase64
        };
    })();
})(vca, vca.$, vca.util);

/* global vca */
/**
 * grab component js
 * Usage:
 * Use for showing grab and grabbing icon on mouse up and down respective
 */

vca.util.grab = (function($, util) {
    let $body = $('body.vca-body'),
        $grabElements = null;
    const CONST = {
        SELECTORS: {
            grab: '.vca-grab'
        },
        CLASS: {
            grab: 'vca-grab',
            grabbing: 'vca-grabbing'
        }
    };

    /**
     * Initialise grab util
     * @function initCarousel
     * @public
     * @param {HTMLElement} $grabElem element
     * @memberof vca.util.grab
     */
    var initGrab = function($grabElem) {
        if ($grabElem.length) {
            $grabElem.each(function(index, element) {
                $(element)
                    .mousedown(function() {
                        $(this)
                            .removeClass(CONST.CLASS.grab)
                            .addClass(CONST.CLASS.grabbing);
                    })
                    .mouseup(function() {
                        $(this)
                            .removeClass(CONST.CLASS.grabbing)
                            .addClass(CONST.CLASS.grab);
                    });
            });
        }
    };

    /**
     * Contextual init grab
     * @function contextualInit
     * @public
     * @param {Object} $elem - DOM
     * @memberof vca.util.grab
     */
    var contextualInit = function($elem) {
        if (!util.wcmmode.isEditMode) {
            if ($elem.length) {
                initGrab($elem);
            }
        }
    };

    /**
     * Init grab
     * @function init
     * @public
     * @param
     * @memberof vca.util.grab
     */
    var init = function() {
        if (!util.wcmmode.isEditMode) {
            $grabElements = $body.find(CONST.SELECTORS.grab);
            initGrab($grabElements);
        }
    };

    return {
        init: init,
        contextualInit: contextualInit
    };
})(vca.$, vca.util);

/**
 * removeLoader.js
 * functionality for the removeLoader utility
 */
(function(vca) {
    'use strict';

    const CONST = {
        CLASS: {
            loading: 'vca-ajax-loading'
        }
    };

    /**
     * removeLoader utility
     * @namespace removeLoader
     * @memberof vca.util
     */
    vca.util.removeLoader = (function($, util) {
        const $main = $('main');

        /**
         * Initialize the utility method to remove loading
         * @function init
         * @memberOf vca.util.removeLoader
         * @private
         * @returns {void}
         */
        function init() {
            util.throttle(function() {
                $main.removeClass(CONST.CLASS.loading);
            }, 0)();
        }

        return {
            init: init
        };
    })(vca.$, vca.util);
})(window.vca);

/* global vca */

/**
 * globalTracking.js
 * @fileOverview utility to handle global tracking functionality
 */
(function (util, base) {
    'use strict';
    const CONST = {
        sfmcId: 'sfmc_id',
        promoViewStr: 'rcms_eepromoview',
        regexToRemoveTags : /<[^>]+>|\n/g,
        SELECTORS: {
            trackingEvent: '.vca-tracking-event',
            promoLink: '.rcms_eepromoclick',
            promoView: '.rcms_eepromoview',
            sizeGuideLink: '[data-tracking-event="sizeGuideDownload"], [data-event="sizeGuideDownload"], a.vca-gi-watch-wrapper'
        },
        ATTRIBUTES: {
            pgtype: 'pgtype',
            promoId: 'tracking-promo-id',
            promoName: 'tracking-promo-name',
            promoCreative: 'tracking-promo-creative',
            promoPosition: 'tracking-promo-position',
            sizeGuide: 'sizeguide',
            currency: 'tracking-currency'
        }
    };
    /**
     * globalTracking util
     * @namespace globalTracking
     * @memberof vca.util
     */
    util.globalTracking = (function ($, util, baseUtil) {
        let $body = $('body'),
            $homepage = $('body.vca-template-home-page'),
            isCountryCN = util.dataStore.isChina();
        /**
         * Handle CRM ID Tracking From Url Param
         * @method crmIdTrackingFromUrl
         * @memberof vca.util
         */
        const crmIdTrackingFromUrl = function () {
            const sfmcId = util.queryString.get(CONST.sfmcId);
            if (sfmcId) {
                let trackingEventObj = {
                    sfmc_id: sfmcId
                };
                baseUtil.analytics.pushDataToDataLayer(trackingEventObj);
            }
        };

        /**
         * Method to push the tracking data into datalayer
         * @function dataTracking
         * @memberOf vca.util
         * @private
         * @returns {void}
         */
        function dataTracking() {
            let linkData = $(this).data('tracking-event'),
                trackingEventObj = {},
                linkEvent = '';

            if (linkData) linkEvent = linkData.replace(/\s/g, '');

            trackingEventObj = {
                event: linkEvent
            };

            baseUtil.analytics.pushDataToDataLayer(trackingEventObj);
        }

        /**
         * Method to push promotion view/click tracking event data to GTM
         * @function promoGTMTracking
         * @memberOf vca.util
         * @private
         * @param { Object } $this clicked/viewed promotion Dom element
         * @param { String } eventName name of the event
         * @returns {void}
         */
        function promoGTMTracking($this, eventName) {
            const promotionId = $this.data(CONST.ATTRIBUTES.promoId),
                promotion_name = $this.data(CONST.ATTRIBUTES.promoName),
                creative_name = $this.data(CONST.ATTRIBUTES.promoCreative),
                creative_slot = $this.data(CONST.ATTRIBUTES.promoPosition),
                page_type = $this.data(CONST.ATTRIBUTES.pgtype) || 'N/A',
                currency = $this.data(CONST.ATTRIBUTES.currency) || 'N/A'


            const promotion_id = page_type + ' - ' + promotionId
            const trackingEventObj = {
                event: eventName,
                ecommerce: {
                    currency: currency,
                    items: [{
                        promotion_id: promotion_id ? promotion_id.replace(CONST.regexToRemoveTags, '') : 'N/A',
                        promotion_name: promotion_name ? promotion_name.replace(CONST.regexToRemoveTags, '') : 'N/A',
                        creative_name: creative_name || 'N/A',
                        creative_slot: creative_slot || 'N/A',
                        location_id: 'homepage'
                    }]
                }
            };

            baseUtil.analytics.pushDataToDataLayer(trackingEventObj);
        }

        /**
         * Method to handle promo View Tracking
         * @function promoGTMViewTrackingHandler
         * @memberOf vca.util
         * @private
         * @param {Object} elementPos gives position params for viewed promotion
         * @returns {void}
         */
        function promoGTMViewTrackingHandler(elementPos) {
            $(CONST.SELECTORS.promoView).each(function (index, el) {
                let promoBottomPos = el.getBoundingClientRect().bottom;
                if (promoBottomPos === elementPos.bottom) {
                    promoGTMTracking($(el), 'view_promotion');
                }
            })
        }

        /**
         * Method to subscribe promotion View event
         * @function promoGTMViewTracking
         * @memberOf vca.util
         * @private
         * @returns {void}
         */
        function promoGTMViewTracking() {
            const promoView = $(CONST.SELECTORS.promoView);
            if (promoView.length > 0) {
                promoView.each(function(i, promo) {
                    util.io.isElementInView(CONST.promoViewStr, promo);
                })
                $.subscribe(
                    util.customEvents.IO_ELEM_IN +
                    ':' +
                    CONST.promoViewStr,
                    function (_element){
                        promoGTMViewTrackingHandler(_element);
                    }
                );
            }
        }

        /**
         * Method to push promotion view/click tracking event data to sensors
         * @function promoSensorsTracking
         * @memberOf vca.util
         * @private
         * @param { Object } $this clicked/viewed promotion Dom element
         * @param { String } eventName name of the event
         * @returns {void}
         */
        function promoSensorsTracking($this, eventName) {
            const prmId = $this.data(CONST.ATTRIBUTES.promoId),
                prmName = $this.data(CONST.ATTRIBUTES.promoName),
                prmCreative = $this.data(CONST.ATTRIBUTES.promoCreative),
                prmPosition = $this.data(CONST.ATTRIBUTES.promoPosition),
                trackingEventObj = {
                    prmid: prmId ? prmId.replace(CONST.regexToRemoveTags, '') : 'NA',
                    prmname: prmName ? prmName.replace(CONST.regexToRemoveTags, '') : 'NA',
                    prmcreative: prmCreative || 'NA',
                    prmposition: prmPosition || 'NA',
                };

            baseUtil.analytics.pushToSensorsData(eventName, trackingEventObj);
        }

        /**
         * Method to handle promo View Tracking
         * @function promoViewTrackingHandler
         * @memberOf vca.util
         * @private
         * @param {Object} elementPos gives position params for viewed promotion
         * @returns {void}
         */
        function promoViewTrackingHandler(elementPos) {
            $(CONST.SELECTORS.promoView).each(function () {
                let promoBottomPos = $(this)[0].getBoundingClientRect().bottom;
                if (promoBottomPos == elementPos.bottom) {
                    promoSensorsTracking($(this), 'PromotionView');
                }
            })
        }

        /**
         * Method to subscribe promotion View event
         * @function promoSensorsViewTracking
         * @memberOf vca.util
         * @private
         * @returns {void}
         */
        function promoSensorsViewTracking() {
            util.io.isElementInView(
                CONST.promoViewStr,
                document.querySelector(CONST.SELECTORS.promoView)
            );
            $.subscribe(
                util.customEvents.IO_ELEM_IN +
                ':' +
                CONST.promoViewStr,
                function (_element){
                    promoViewTrackingHandler(_element);
                }
            );
        }

        /**
         * track size Guide download link
         * @function trackSizeGuide
         * @memberOf vca.util
         * @private
         * @returns {void}
         */
        function trackSizeGuide() {
            const href = $(this).attr('href').replaceAll('-', '').toLowerCase();
            if (href.indexOf(CONST.ATTRIBUTES.sizeGuide) > -1){
                if (isCountryCN){
                    //sensors tracking
                    baseUtil.analytics.pushToSensorsData('DownloadSizeGuide');
                } else {
                    let trackingEventObj = {};

                    trackingEventObj = {
                        event: 'download_size_guide'
                    };
                    //gtm tacking
                    baseUtil.analytics.pushDataToDataLayer(trackingEventObj);
                }
            }
        }

        /**
         * Bind events
         * @function bindEvents
         * @memberOf vca.util
         * @private
         * @returns {void}
         */
        function bindEvents() {
            crmIdTrackingFromUrl();
            $body.on(
                util.customEvents.INTERACTION,
                CONST.SELECTORS.trackingEvent,
                dataTracking
            );

            // size guide link tracking
            $body.on(
                util.customEvents.INTERACTION,
                CONST.SELECTORS.sizeGuideLink,
                trackSizeGuide
            );

            if (isCountryCN) {
                $homepage.on(
                    util.customEvents.INTERACTION,
                    CONST.SELECTORS.promoLink,
                    function () {
                        promoSensorsTracking($(this), 'PromotionClick');
                    }
                );
            } else {
                $homepage.on(
                    util.customEvents.INTERACTION,
                    CONST.SELECTORS.promoLink,
                    function () {
                        promoGTMTracking($(this), 'select_promotion');
                    }
                );
            }
        }

        /**
         * Initialise instance of globalTracking
         * @function init
         * @memberOf vca.util
         * @private
         */
        function init() {
            bindEvents();
            if (
                $homepage.length !== 0 &&
                isCountryCN
            ) {
                promoSensorsViewTracking();
            } else if (!isCountryCN) {
                promoGTMViewTracking()
            }

        }
        init();
        return {
            init: init
        };
    })(vca.$, vca.util, base.util);
})(vca.util, window.base);

/* global vca */
/* reference link https://stackoverflow.com/a/15016605
/**
 * crypto.js
 * @fileOverview Provides a utility function to encode string to SHA256.
 */
(function(vca, $, util) {
    'use strict';

    /**
     * Utility for performing encryption of string to SHA256
     * @memberof vca.util
     */
    util.crypto = (function() {
        /**
         * Method to encrypt string to SHA256
         * @function encryptToSHA256
         * @memberOf vca.util.crypto
         * @private
         * @param {String} message String to encrypt
         * @returns {String} encrypted string
         */
        async function encryptToSHA256(message) {
            // encode as UTF-8
            const msgBuffer = new TextEncoder().encode(message);

            // hash the message
            const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);

            // convert ArrayBuffer to Array
            const hashArray = Array.from(new Uint8Array(hashBuffer));

            // convert bytes to hex string
            const hashHex = hashArray
                .map(b => b.toString(16).padStart(2, '0'))
                .join('');
            return hashHex;
        }

        return {
            encryptToSHA256: encryptToSHA256
        };
    })();
})(vca, vca.$, vca.util);

/**
 * seeMoreLess.js
 * @fileOverview Provides a utility for seeMoreLess related stuff.
 *
 * Reference - https://www.w3.org/TR/wai-aria-practices/examples/dialog-modal/dialog.html
 */
(function (vca) {
    'use strict';

    /**
     * focus utility
     * @memberof vca.util
     */
    vca.util.seeMoreLess = (function () {
        let $ellipsis = '...';

        /**
         * @function shortenText
         * @memberOf vca.util.seeMoreLess
         * @private
         * @param {string} text - DOM object string
         * @param {number} max - max value till show more is shown
         */
        function shortenText(text, max) {
            return text && text.length > max
                ? text
                    .slice(0, max)
                    .split(' ')
                    .slice(0, -1)
                    .join(' ')
                : text;
        }

        /**
         * * splitValue function cuts the string to contain only the number of characters
         * mentioned while authoring in artist highlight component. This function takes into considration only
         * the actaul sentance letters and not the html tags while counting
         * them to match the index value.
         * @function splitValue
         * @memberOf vca.util.seeMoreLess
         * @private
         * @param {object} contentArgObject - DOM object
         * @param {string} contentArgObject.value - DOM object string
         * @param {number} contentArgObject.maxChar - index value till show more is shown
         * @param {string} contentArgObject.seeMore - see more text string
         * @param {string} contentArgObject.seeLess - see less text string
         * @param {string} contentArgObject.seeMoreTitle - see more title string
         * @param {string} contentArgObject.seeLessTitle - see less title string
         * @param {string} contentArgObject.moreellipses - more ellipses class
         * @param {string} contentArgObject.morecontent - DOM object trim string
         * @param {string} contentArgObject.seeMoreClass - see more class
         * @param {string} contentArgObject.seeLessClass - see less class
         * @param {string} contentArgObject.seeMoreIcon - see more icon
         * @param {string} contentArgObject.seeLessIcon - see less icon
         */

        function splitValue({
            value,
            maxChar,
            seeMore,
            seeLess,
            seeMoreTitle,
            seeLessTitle,
            moreellipses,
            morecontent,
            seeMoreClass,
            seeLessClass,
            seeMoreIcon,
            seeLessIcon
        }) {
            let realIndex = 0,
                ishtmlElement = false,
                toSplit = 0,
                looper = value.split('');
            for (let i = 0; i < looper.length; i++) {
                if (looper[i] === '<') {
                    ishtmlElement = true;
                } else if (looper[i] === '>') {
                    ishtmlElement = false;
                } else if (
                    looper[i] === '&' &&
                    looper[i + 1] === 'n' &&
                    looper[i + 2] === 'b'
                ) {
                    i = i + 4;
                    continue;
                } else if (ishtmlElement) {
                    continue;
                } else {
                    realIndex++;
                }
                if (realIndex === parseInt(maxChar)) {
                    toSplit = ++i;
                    break;
                }
            }

            if (!toSplit) {
                return 0;
            }

            let trimedStr = value.trim(),
                minimizedText = trimedStr.substring(0, toSplit),
                minimizedTextWithCompleteStr = shortenText(
                    minimizedText,
                    toSplit
                );

            return (
                trimedStr.substring(0, minimizedTextWithCompleteStr.length) +
                '<span class=' +
                moreellipses +
                '>' +
                $ellipsis +
                '</span>' +
                '<a class="' +
                seeMoreClass +
                '" title="' +
                seeMoreTitle +
                '">' +
                seeMore +
                seeMoreIcon +
                '</a>' +
                '<div class=' +
                morecontent +
                '>' +
                trimedStr.substring(minimizedTextWithCompleteStr.length) +
                '<a class="' +
                seeLessClass +
                '" title="' +
                seeLessTitle +
                '">' +
                seeLess +
                seeLessIcon +
                '</a>' +
                '</div>'
            );
        }

        /**
         * @function updateParagraphContent
         * @memberOf vca.util.seeMoreLess
         * @param {object} contentArgObject - DOM object string
         * @private
         * @returns {void}
         */
        function updateParagraphContent(contentArgObject) {
            let innerText = contentArgObject.element.html(),
                contentArg = Object.assign({}, contentArgObject, {
                    value: innerText
                }),
                splitVal = splitValue(contentArg);

            if (splitVal && (innerText.length > contentArgObject.maxChar)) {
                contentArgObject.element.html(splitVal);
            }
        }

        return {
            updateParagraphContent
        };
    })(vca.$);
})(vca, vca.util);

/**
 * careAdvisorLink.js
 * functionality for the careAdvisorLink
 */
(function(vca) {
    'use strict';

    /**
     * careAdvisorLink component
     * @namespace careAdvisorLink
     * @memberof vca.util
     */
    vca.util.careAdvisorLink = (function($, util) {
        const CONST = {
            SELECTORS: {
                careAdvisorTextInput: '.vca-care-advisor-text-input',
                careAdvisorSendCTA: '.vca-input-append-button-send'
            },
            DATA_ATTRIBUTE: {
                messageKey: 'messageForCareAdvisor',
                placeholderList: 'careAdvisorPlaceholderList'
            },
            timeOutForTypeWriter: 100,
            timeOutForNextPlaceHolder: 2000,
            restartAnimationAfter: 2000,
            timeOutForBlinker: 500,
            totalBlinkCounter: 6
        };

        let $comp = null,
            $careAdvisorTextInput = null,
            $careAdvisorSendCTA = null,
            $chatBotInitialTextInput = null,
            careAdvisorPlaceHolderList,
            blinkCounter = 0,
            $body = $('body');

        /**
         * Cache variables being used.
         * @function cacheVars
         * @memberOf vca.util.careAdvisorLink
         * @private
         * @param {HTMLElement} elem The component element
         * @returns {void}
         */
        function cacheVars() {
            $comp = $body;
            $careAdvisorTextInput = $comp.find(
                CONST.SELECTORS.careAdvisorTextInput
            );
            $careAdvisorSendCTA = $comp.find(
                CONST.SELECTORS.careAdvisorSendCTA
            );
            $chatBotInitialTextInput = $careAdvisorTextInput
                ? $careAdvisorTextInput[0]
                : null;
        }

        /**
         * Function to send Message to chatbot if user clicks on the appended send CTA icon in text input.
         * @function onClickHandler
         * @memberOf vca.util.careAdvisorLink
         * @private
         * @param {HTMLElement} elem The component element
         * @returns {void}
         */
        function onClickHandler() {
            $chatBotInitialTextInput.value.length > 0 &&
                sendMessageToChatbot($chatBotInitialTextInput.value);
        }

        /**
         * Function to send Message to chatbot if enter key is pressed
         * @function handleEnterPress
         * @memberOf vca.util.careAdvisorLink
         * @private
         * @returns {void}
         */
        function handleEnterPress(event) {
            // check if enter is clicked
            let key = event.charCode || event.keyCode;

            // Enter
            if (key === 13 && $chatBotInitialTextInput.value.length > 0) {
                sendMessageToChatbot($chatBotInitialTextInput.value);
            }
        }

        /**
         * Function to store message in local storage and redirect to chatbot page
         * @function sendMessageToChatbot
         * @memberOf vca.util.careAdvisorLink
         * @private
         * @returns {void}
         */
        function sendMessageToChatbot(message) {
            vca.util.webStorage.set(CONST.DATA_ATTRIBUTE.messageKey, message);

            let url = $chatBotInitialTextInput.dataset.careAdvisorPagePath;

            if ($chatBotInitialTextInput.dataset.careAdvisorTargetWindow) {
                window.open(url);
            } else {
                window.location.href = url;
            }
        }

        /**
         * Bind events
         * @function bindEvents
         * @memberOf vca.util.careAdvisorLink
         * @private
         * @returns {void}
         */
        function bindEvents() {
            $careAdvisorSendCTA.on(
                util.customEvents.INTERACTION,
                onClickHandler
            );
            $careAdvisorTextInput.on(util.customEvents.KEYUP, handleEnterPress);
        }

        /**
         * Function to cause some delay in order to create cursor blink effect
         */
        function delay() {
            util.throttle(function() {
                blinker();
            }, CONST.timeOutForBlinker)();
        }

        /**
         * Common Uitl to set the Care Advisor Input Text- placeholder Attribute
         * @param {string} placeHolderText Text to set for placeholder attribute
         */
        function setCareAdvisorTextInputPlaceHolder(placeHolderText) {
            $careAdvisorTextInput.attr('placeholder', placeHolderText);
        }

        /**
         * To create the Cursor Blinking effect for Typewriting
         */
        function blinker() {
            if (blinkCounter < CONST.totalBlinkCounter) {
                if (blinkCounter % 2 != 0) {
                    setCareAdvisorTextInputPlaceHolder(
                        $careAdvisorTextInput.textContent + ' | '
                    );
                } else {
                    let curText = $careAdvisorTextInput.textContent.substring(
                        0,
                        $careAdvisorTextInput.textContent.length
                    );
                    setCareAdvisorTextInputPlaceHolder(curText);
                }
                delay();
            }
            blinkCounter++;
        }

        /**
         * TypeWriter Function to animate the Care Advisor Placeholder from the List
         * @param {string} text Phrase from the AEM authored placeholder list
         * @param {number} index To track the phrase letters
         * @param {function} fnCallback Callback function to call after each letter printing
         */
        function typeWriter(text, index, fnCallback) {
            if (index < text.length) {
                $careAdvisorTextInput.textContent = text.substring(
                    0,
                    index + 1
                );

                setCareAdvisorTextInputPlaceHolder(
                    $careAdvisorTextInput.textContent + ' | '
                );

                util.throttle(function() {
                    typeWriter(text, index + 1, fnCallback);
                }, CONST.timeOutForTypeWriter)();
            } else if (typeof fnCallback == 'function') {
                blinkCounter = 0;
                blinker();
                util.throttle(fnCallback, CONST.timeOutForNextPlaceHolder)();
            }
        }
        /**
         * To start/restart animation after each timeout with the new phrase from list
         * @param {number} index
         */
        function startPhraseAnimation(index) {
            if (typeof careAdvisorPlaceHolderList[index] == 'undefined') {
                util.throttle(function() {
                    startPhraseAnimation(0); //restart animation
                }, CONST.restartAnimationAfter)();
            }

            if (
                careAdvisorPlaceHolderList[index] &&
                index < careAdvisorPlaceHolderList[index].length
            ) {
                typeWriter(careAdvisorPlaceHolderList[index], 0, function() {
                    startPhraseAnimation(index + 1); //start next phrase
                });
            }
        }

        /**
         * Load dynamic placeholder for Care Advisor Textbox with Typewriting behaviour
         * @function loadDynamicPlaceholder
         * @memberOf vca.util.careAdvisorLink
         * @private
         * @returns {void}
         */
        function loadDynamicPlaceholder() {
            careAdvisorPlaceHolderList = $careAdvisorTextInput.data(
                CONST.DATA_ATTRIBUTE.placeholderList
            );

            if (careAdvisorPlaceHolderList) {
                careAdvisorPlaceHolderList = careAdvisorPlaceHolderList
                    .substr(1, careAdvisorPlaceHolderList.length)
                    .split('#')
                    .filter(ele => ele);

                startPhraseAnimation(0);
            }
        }

        /**
         * Initialize the component
         * @function init
         * @memberOf vca.util.careAdvisorLink
         * @private
         * @param {HTMLElement} elem The component element
         * @returns {void}
         */
        function init() {
            cacheVars();
            bindEvents();
            loadDynamicPlaceholder();
        }

        return {
            init: init
        };
    })(vca.$, vca.util);
})(window.vca);

/**
 * parseTrackingData.js
 * @fileOverview Provides a utility for parseTrackingData related stuff.
 *
 * Reference - https://www.w3.org/TR/wai-aria-practices/examples/dialog-modal/dialog.html
 */
(function(vca) {
    'use strict';

    /**
     * @memberof vca.util
     */
    vca.util.parseTrackingData = (function() {
        /**
         * @function convertDataToObject
         * @memberOf vca.util.parseTrackingData
         * @param {object} data - string
         * @private
         * @returns {convertedData} - Object
         */
        function convertDataToObject(data) {
            let convertedData;
            let dataToString = data.toString();
            let dataReplaceQuotes = dataToString.replace(/'/g, '"');

            dataReplaceQuotes = dataToString.replace(/[{}]/g, '');

            convertedData = dataReplaceQuotes
                .split(',')
                .reduce(function(obj, str) {
                    let strParts = str.split(':');

                    if (strParts[0] && strParts[1]) {
                        let strParts1 = strParts[0].replace(/'/g, '');
                        let strParts2 = strParts[1].replace(/'/g, '');
                        obj[strParts1] = strParts2.trim(); //<-- Get rid of extra spaces at beginning of value strings
                    }
                    return obj;
                }, {});
            return convertedData;
        }

        return {
            convertDataToObject
        };
    })(vca.$);
})(vca, vca.util);

/**
 * crcDataTracking.js
 * functionality for the crcDataTracking utility
 *
 */
(function(vca, base) {
    'use strict';

    /**
     * functionality for the crcDataTracking utility
     * @memberof vca.util
     */
    vca.util.crcDataTracking = (function($, util, baseUtil) {
        /**
         * Handle the analytics on click
         * @function handleCrcPhoneClick
         * @memberOf vca.util.crcDataTracking
         * @private
         * @returns {void}
         */
        function handleCrcPhoneClick(buttonPosition) {
            baseUtil.analytics.pushDataToDataLayer({
                event: 'call_center',
                button_position: buttonPosition,
                button_type: 'phone number'
            });
        }

        return {
            handleCrcPhoneClick
        };
    })(vca.$, vca.util, base.util);
})(window.vca, window.base);

/**
 * stickyCheckout.js
 * utility functionality for sticky checkout
 */

(function(vca) {
    'use strict';

    const CONST = {
            SELECTORS: {
                checkoutElem: '.base-on-delivery-info-form',
                stickyCheckoutWrapper: '.vca-sticky-checkout'
            },
            CLASSES: {
                hide: 'vca-hide'
            }
        },
        THROTTLE_TIMEOUT = 250;

    /**
     * stickyCheckout utility
     * @namespace stickyCheckout
     * @memberof vca.util
     */
    vca.util.stickyCheckout = (function($, util) {
        let $body = $('body'),
            $checkoutElem = null,
            $stickyCheckoutWrapper = null,
            onCheckoutPage = null,
            isNarrow = vca.util.matchmedia.narrow.matches,
            checkoutElemHeight = null;


        /**
         * initialize the sticky checkout elements
         * @function initCheckoutElements
         * @memberOf vca.util.stickyCheckout
         * @private
         * @returns {void}
         */
        function initCheckoutElements() {
            checkoutElemHeight = $checkoutElem.outerHeight();
            $stickyCheckoutWrapper.removeClass(CONST.CLASSES.hide);
        }

        /**
         * initialize the sticky checkout behavior
         * @function initStickyCheckoutBehavior
         * @memberOf vca.util.stickyCheckout
         * @private
         * @returns {void}
         */
        function initStickyCheckoutBehavior(){
            const elParentBottom = $checkoutElem.offset().top + checkoutElemHeight,
                winBottom = $(window).scrollTop() + $(window).height();

            if (winBottom < elParentBottom) {
                $stickyCheckoutWrapper.removeClass(CONST.CLASSES.hide);
            } else {
                $stickyCheckoutWrapper.addClass(CONST.CLASSES.hide);
            }
        }

        /**
         * Bind events
         * @function bindEvents
         * @memberOf vca.util.stickyCheckout
         * @private
         * @returns {void}
         */
        function bindEvents() {
            if (onCheckoutPage && isNarrow){
                util.throttle(initCheckoutElements, THROTTLE_TIMEOUT)();

                $(window).on(util.customEvents.SCROLL, function() {
                    util.throttleHandler(initStickyCheckoutBehavior, THROTTLE_TIMEOUT);
                });
            }
        }

        /**
         * Cache variables being used
         * @function cacheVars
         * @memberOf vca.util.stickyCheckout
         * @private
         * * @returns {void}
         */
        function cacheVars() {
            $checkoutElem = $body.find(CONST.SELECTORS.checkoutElem);
            $stickyCheckoutWrapper = $body.find(CONST.SELECTORS.stickyCheckoutWrapper);
            onCheckoutPage = $body.find(CONST.SELECTORS.stickyCheckoutWrapper).length;
        }

        /**
         * Initialise instance of sticky
         * @function init
         * @memberOf vca.util.stickyCheckout
         * @private
         */
        function init() {
            cacheVars();
            bindEvents();
        }

        init();

    })(vca.$, vca.util);
})(window.vca);
/*global vca*/

/**
 * ccBemVideo.js
 * functionality for the bemVideo in popup player utility
 */
(function(vca) {
    'use strict';

    const CONST = {
        SELECTORS: {
            videoCta: '.vca-ccv-video',
            videoHTML: '.vca-js-template-video-player',
            videoCloseBtn: '.vca-video-pupup-close-btn'
        },
        CLASSES: {
            videoBlockWrapper: 'vca-video-popup'
        }
    };

    /**
     * ccBemVideo Util
     * @namespace ccBemVideo
     * @memberof vca.util
     */
    vca.util.ccBemVideo = (function($, util) {
        let $body = $('body'),
            configObject = null;

        /**
         * play video click event handler
         * @function playVideoClickHandler
         * @memberOf vca.util.ccBemVideo
         * @private
         * @param {Event} e The click event
         * @returns {void}
         */
        function playVideoClickHandler(e) {
            let $thisElem = $(e.target || e.currentTarget),
                $currentelement = $thisElem.hasClass(CONST.SELECTORS.videoCta)
                    ? $thisElem
                    : $thisElem.closest(CONST.SELECTORS.videoCta),
                $videoHTMLBlock = $currentelement.find(
                    CONST.SELECTORS.videoHTML
                ),
                $videoHTML = $videoHTMLBlock.html();
            $videoHTML && vca.util.lightbox.openContentInLightBox($videoHTML, configObject);
        }

        /**
         * close lightbox handler
         * @function closeLightBox
         * @memberOf vca.util.ccBemVideo
         * @private
         * @returns {void}
         */
        function closeLightBox() {
            vca.util.lightbox.closeLightbox();
        }

        /**
         * get lightbox config
         * @function getlightboxConfig
         * @memberOf vca.util.ccBemVideo
         * @private
         * * @returns {Object}
         */
        function getlightboxConfig() {
            let lightBoxObject = {
                mould: 'default',
                customCssClass: CONST.CLASSES.videoBlockWrapper,
                cacheburst: false
            };

            return lightBoxObject;
        }

        /**
         * Bind events
         * @function bindEvents
         * @memberOf vca.util.ccBemVideo
         * @private
         * @returns {void}
         */
        function bindEvents() {
            $body.on(
                util.customEvents.INTERACTION,
                CONST.SELECTORS.videoCta,
                playVideoClickHandler
            );

            $body.on(
                util.customEvents.INTERACTION,
                CONST.SELECTORS.videoCloseBtn,
                closeLightBox
            );
        }

        /**
         * cache DOM variables being used.
         * @function cacheVars
         * @memberOf vca.util.ccBemVideo
         * @private
         * @returns {void}
         */
        function cacheVars() {
            configObject = getlightboxConfig();
        }

        /**
         * Initialize the utility
         * @function init
         * @memberOf vca.util.ccBemVideo
         * @returns {void}
         */
        function init() {
            cacheVars();
            bindEvents();
        }

        return {
            init: init
        };
    })(vca.$, vca.util);
})(vca);

/**
 * neteaseQyuiCrcChat.js
 * utility functionality for Netease Qyui CRC Live Chat
 */

(function(vca) {
    'use strict';

    const CONST = {
        SELECTORS: {
            netEaseQyuiEle: '#neteaseqiyu'
        },
        ATTRIBUTE: {
            currentUserSessionStatus: 'data-user-status',
            netEaseQyuikfScriptLink: 'data-netease-qyuikf-script-link',
            netEaseQyuiSdkTemplateId: 'data-netease-sdk-id',
            netEaseQyuiGroupId: 'data-netease-sdk-id',
            chinaLocalLanguageCode: 'data-china-local-langcode'
        },
        CLASSES: {
            hide: 'vca-hide'
        },
        DATA: {
            paramType: 'crm_param',
            brandKey: 'brand',
            brandValue: 'VCA'
        },
        NETEASE_QYUI_CHAT_SERVELET: '.netease-token.json'
    };

    /**
     * neteaseQyuiCrcChat utility
     * @namespace neteaseQyuiCrcChat
     * @memberof vca.util
     */
    vca.util.neteaseQyuiCrcChat = (function($, util, baseUtil) {
        let $body = null,
            $netEaseQyuiElem = null,
            netEaseQyuikfScriptLink = null,
            netEaseQyuiSdkTemplateId = null,
            netEaseQyuiGroupId = null,
            responseCrcUid = null,
            emptyUidForAnonymouseUser = '',
            chinaLocalLanguageCode = null,
            chinaLangCode = null;

        /**
         * Check login state handler
         * @function isLoggedIn
         * @memberOf vca.comp.neteaseQyuiCrcChat
         * @private
         * @returns {boolean}
         */
        function isLoggedIn() {
            var profileData = util.dataStore.getProfileStoreData(),
                loggedInState = profileData.logInStatus;

            return loggedInState;
        }

        /**
         * Get the netease qyui uid for loggedin user.
         * @function getUidForLoggedInUserNetEaseQyui
         * @memberOf vca.comp.neteaseQyuiCrcChat
         * @private
         * @returns {void}
         */
        function getUidForLoggedInUserNetEaseQyui() {
            const pageURL = util.dataStore.getCurrentPagePathWithoutSelector(),
                urlToRequest = pageURL + CONST.NETEASE_QYUI_CHAT_SERVELET;
            try {
                util.request.get(urlToRequest).done(data => {
                    responseCrcUid = data.uid;
                    responseCrcUid && isNeteaseQyuiReady(responseCrcUid);
                });
            } catch (err) {
                console.log('Netease Live CRC Chat Err', err);
            }
        }

        /**
         * Netease Qyui common script to embed chatbox in DOM
         * @function commonNeteaseScriptHandler
         * @memberOf vca.util.neteaseQyuiCrcChat
         * @private
         * @returns {void}
         */
        function commonNeteaseScriptHandler() {
            (function(w, d, n, a, j) {
                w[n] =
                    w[n] ||
                    function() {
                        (w[n].a = w[n].a || []).push(arguments);
                    };
                j = d.createElement('script');
                j.async = true;
                j.src = netEaseQyuikfScriptLink + netEaseQyuiSdkTemplateId;
                d.body.appendChild(j);
            })(window, document, 'ysf');
        }

        /**
         * Logoff Netease Qyui Live Chat handler
         * @function logoffNeteaseLiveChatHandler
         * @memberOf vca.util.neteaseQyuiCrcChat
         * @private
         * @returns {void}
         */
        function logoffNeteaseLiveChatHandler() {
            commonNeteaseScriptHandler();
            ysf('logoff');
        }

        /**
         * add ysf configurations before showing chat box
         * @function isNeteaseQyuiReady
         * @memberOf vca.util.neteaseQyuiCrcChat
         * @private
         * @param { String } uid UID required for netease qyui ysf config
         * @returns {void}
         */
        function isNeteaseQyuiReady(userUid) {
            chinaLangCode =
                chinaLocalLanguageCode == 'zh'
                    ? 'zh-cn'
                    : chinaLocalLanguageCode;

            commonNeteaseScriptHandler();
            ysf('config', {
                uid: !userUid ? '' : userUid,
                groupid: netEaseQyuiGroupId,
                data: JSON.stringify([
                    {
                        type: CONST.DATA.paramType,
                        key: CONST.DATA.brandKey,
                        value: CONST.DATA.brandValue
                    }
                ]),
                language: chinaLangCode
            });
        }

        /**
         * Bind events
         * @function bindEvents
         * @memberOf vca.util.neteaseQyuiCrcChat
         * @private
         * @returns {void}
         */
        function bindEvents() {
            if (isLoggedIn()) {
                getUidForLoggedInUserNetEaseQyui();
            } else {
                isNeteaseQyuiReady(emptyUidForAnonymouseUser);
            }
        }

        /**
         * Cache variables being used
         * @function cacheVars
         * @memberOf vca.util.neteaseQyuiCrcChat
         * @private
         * * @returns {void}
         */
        function cacheVars() {
            $body = $('body');

            $netEaseQyuiElem = $body.find(CONST.SELECTORS.netEaseQyuiEle);

            netEaseQyuikfScriptLink = $netEaseQyuiElem.attr(
                CONST.ATTRIBUTE.netEaseQyuikfScriptLink
            );

            netEaseQyuiSdkTemplateId = $netEaseQyuiElem.attr(
                CONST.ATTRIBUTE.netEaseQyuiSdkTemplateId
            );

            netEaseQyuiGroupId = $netEaseQyuiElem.attr(
                CONST.ATTRIBUTE.netEaseQyuiGroupId
            );

            chinaLocalLanguageCode = $netEaseQyuiElem.attr(
                CONST.ATTRIBUTE.chinaLocalLanguageCode
            );

            // subscribe to login/logout status changes
            $.subscribe(
                baseUtil.customEvents.PROFILE_LOGINSTATUS_CHANGED,
                loginStatus => {
                    if (loginStatus == 'false') {
                        logoffNeteaseLiveChatHandler();
                    }
                }
            );
        }

        /**
         * Initialise instance of neteaseQyuiCrcChat
         * @function init
         * @memberOf vca.util.neteaseQyuiCrcChat
         * @private
         */
        function init() {
            cacheVars();
            bindEvents();
        }

        init();
    })(vca.$, vca.util, base.util);
})(window.vca);

/**
 * emailSubscription.js
 * functionality for the email subscription component
 */
(function(w, vca) {
    'use strict';

    var CONST = {
        SELECTORS: {
            form: '.vca-es-form',
            emailInput: '.vca-es-form-input',
            submit: '.vca-es-form-submit-btn',
            formErr: '.vca-es-form-input-error',
            emailSelector: '#vca-newsletter-form_email',
            lightboxWrapper: '.vca-lightbox-wrapper'
        },
        CSS_CLASS: {
            hide: 'vca-hide',
            lbPosition: 'vca-lb-'
        },
        DOM_PROP: {
            disabled: 'disabled'
        }
    };

    /**
     * email subscription component
     * @namespace emailSubscription
     * @memberof vca.comp
     */
    vca.comp.emailSubscription = (function($, util) {
        var $body = $('body'),
            $comp = null,
            $emailInput = null,
            $submit = null,
            $formErr = null;

        /**
         * Updates variables being used.
         * @function cacheVars
         * @memberOf vca.comp.emailSubscription
         * @private
         * @param {HTMLElement} elem The component element
         * @returns {void}
         */
        function cacheVars(elem) {
            $comp = $(elem);
            $emailInput = $comp.find(CONST.SELECTORS.emailInput);
            $submit = $comp.find(CONST.SELECTORS.submit);
            $formErr = $comp.find(CONST.SELECTORS.formErr);
        }

        /**
         * Function binded to on key up on input box.
         * and updates the submit dom (disabled/enabled) accrodingly
         * @function validateEmail
         * @memberOf vca.comp.emailSubscription
         * @private
         * @returns {void}
         */
        function validateEmail() {
            $formErr.addClass(CONST.CSS_CLASS.hide);
        }

        /**
         * open personalisation overlay
         * @memberOf vca.comp.emailSubscription
         * param: {e} event
         * @private
         * @returns {void}
         */
        function openPersonalisationOverlay(e) {
            e.preventDefault();
            var $currentEl = $(e.currentTarget || e.target),
                urlForOverlay = $currentEl.data('href'),
                lightboxMould = $currentEl.data('lightbox-mould'),
                $lightboxWrapper = $body.find(CONST.SELECTORS.lightboxWrapper);

            if (vca.util.lightbox.getLightboxStatus()) {
                vca.util.lightbox.closeLightbox();
            }

            vca.util.lightbox.openUrlInLightbox(urlForOverlay, 'large');

            $lightboxWrapper.addClass(
                CONST.CSS_CLASS.lbPosition + lightboxMould
            );
        }

        /**
         * Open account subscription page url
         * @memberOf vca.comp.emailSubscription
         * @private
         */
        function redirectUrl(e) {
            e.preventDefault();

            let $currentEl = $(e.currentTarget || e.target),
                urlForOverlay = $currentEl.data('loggedSubscription');

            window.location.replace(urlForOverlay);
        }

        /**
         * Function to handle submit action of form.
         * @function onSubmitHandler
         * @memberOf vca.comp.emailSubscription
         * @private
         * @param {object} e is the default event object assiciated with submit button.
         * @returns {void}
         */
        function onSubmitHandler(e) {
            var email = $emailInput.val().toLowerCase();

            var profileData = util.dataStore.getProfileStoreData();

            //  not loggedin
            //  1. click on button /  open nl form
            //  2. click on button after filling email / open NL form with filled email

            //  logged in
            //  1. click on button without filling email / open the account/subscription page
            //  2. click on button after filling email with email same as profile email / open the account/subscription page
            //  3. click on button after filling email with email diff as profile email / open nl form with email filled that user entered

            e.preventDefault();

            if (profileData && !profileData.logInStatus) {
                if (email) {
                    if (util.validator.isValidEmail(email)) {
                        openPersonalisationOverlay(e);

                        return true;
                    }

                    $formErr.removeClass(CONST.CSS_CLASS.hide);

                    return false;
                } else {
                    openPersonalisationOverlay(e);
                }
            } else {
                if (email) {
                    if (util.validator.isValidEmail(email)) {
                        if (email === profileData.email.toLowerCase()) {
                            redirectUrl(e);
                        } else {
                            openPersonalisationOverlay(e);
                            return true;
                        }
                    } else {
                        $formErr.removeClass(CONST.CSS_CLASS.hide);
                    }
                } else {
                    redirectUrl(e);
                }
                return false;
            }
        }

        /**
         * Bind events
         * @function bindEvents
         * @memberOf vca.comp.emailSubscription
         * @private
         * @returns {void}
         */
        function bindEvents() {
            // event handlers
            $submit.on(util.customEvents.INTERACTION, onSubmitHandler);
        }

        /**
         * Unbinds all pre-existing events
         * @function teardown
         * @memberOf vca.comp.emailSubscription
         * @private
         * @returns {void}
         */
        function teardown() {
            $emailInput.off(util.customEvents.KEYUP);
            $submit.off(util.customEvents.INTERACTION);
        }

        /**
         * Initialize the component
         * @function init
         * @memberOf vca.comp.emailSubscription
         * @private
         * @param {HTMLElement} elem The component element
         * @returns {void}
         */
        function init(elem) {
            cacheVars(elem);
            teardown();
            bindEvents();
            // call the validation function on component load
            validateEmail();
        }

        return {
            init: init
        };
    })(vca.$, vca.util);
})(window, window.vca);

/**
 * asianDeclination.js
 * functionality for the asianDeclination component
 */
(function(vca) {
    'use strict';

    var CONST = {
        SELECTORS: {
            lightBoxWrapper: '.vca-ad-lightbox-wrapper',
            weChatButton: '.vca-we-chat-button',
            footer: '.vca-footer'
        },
        CSS_CLASSES: {
            hide: 'vca-hide'
        }
    };

    /**
     * asianDeclination component
     * @namespace asianDeclination
     * @memberof vca.comp
     */
    vca.comp.asianDeclination = (function($, util) {
        var $comp = null,
            $weChatButton = null,
            $lightBoxWrapper = null,
            $body = null;

        /**
         * Show light box
         * @function addLightBox
         * @memberOf vca.comp.asianDeclination
         * @private
         * @returns {void}
         */
        function addLightBox() {
            $lightBoxWrapper.removeClass(CONST.CSS_CLASSES.hide);
        }

        /**
         * Hide light box
         * @function removeLightBox
         * @memberOf vca.comp.asianDeclination
         * @private
         * @returns {void}
         */
        function removeLightBox(event) {
            var $currentTarget = $(event.target);
            var isFooterPresent =
                $currentTarget.closest(CONST.SELECTORS.footer).length > 0;
            if (!isFooterPresent) {
                $lightBoxWrapper.addClass(CONST.CSS_CLASSES.hide);
            }
        }

        /**
         * Bind events
         * @function bindEvents
         * @memberOf vca.comp.asianDeclination
         * @private
         * @returns {void}
         */
        function bindEvents() {
            // event handlers
            $weChatButton.on(util.customEvents.INTERACTION, addLightBox);
            $body.on(util.customEvents.INTERACTION, removeLightBox);
        }

        /**
         * Cache variables being used.
         * @function cacheVars
         * @memberOf vca.comp.asianDeclination
         * @private
         * @param {HTMLElement} elem The component element
         * @returns {void}
         */
        function cacheVars(elem) {
            $comp = $(elem);
            $weChatButton = $comp.find(CONST.SELECTORS.weChatButton);
            $lightBoxWrapper = $comp.find(CONST.SELECTORS.lightBoxWrapper);
            $body = $comp.parents('body');
        }

        /**
         * Initialize the component
         * @function init
         * @memberOf vca.comp.asianDeclination
         * @private
         * @param {HTMLElement} elem The component element
         * @returns {void}
         */
        function init(elem) {
            cacheVars(elem);
            bindEvents();
        }

        return {
            init: init
        };
    })(vca.$, vca.util);
})(window.vca);

/**
 * footerNavigationLinks.js
 * functionality for the footerNavigationLinks component
 */
(function(vca, base) {
    'use strict';

    /**
     * footerNavigationLinks component
     * @namespace footerNavigationLinks
     * @memberof vca.comp
     */
    vca.comp.footerNavigationLinks = (function($, util, baseUtil) {
        var CONST = {
            SELECTORS: {
                toggleClickElem: '.vca-toggle-sitemap',
                siteMapWrapper: '.vca-sitemap',
                sitemapHeading: '.vca-sitemap-heading',
                navigationLinks: '.vca-active-sitemap',
                siteMapLink: '.vca-sitemap-tabs-link',
                sitemapText: '.vca-footer-links-link.vca-toggle-sitemap',
                listView: '.rcms_eelistview, .rcms_eelistclick',
                baseRecaptchaV2: '.base-recaptchav2',
                vcaMain: '.vca-main',
                vcaFooterTrackingLinks: '.vca-footer .vca-nl [data-tracking-action]',
                vcaSocialTrackingLinks: '.vca-footer .vca-ss [data-tracking-action]'
            },
            CSS_CLASSES: {
                navigationLinks: 'vca-active-sitemap'
            },
            ATTRIBUTES: {
                templateType: 'templateType',
                title: 'title'
            }
        };

        var $comp = null,
            $toggleClickElem = null,
            $sitemapHeading = null,
            $body = $('html,body'),
            sitemapText = null,
            scrollTime = 500,
            $baseRecaptchaV2 = null,
            $vcaFooterTrackingLinks = null,
            $vcaSocialTrackingLinks = null,
            isCountryCN = util.dataStore.isChina();

        /**
         * Toggle event handler
         * @function toggleHandler
         * @memberOf vca.comp.footerNavigationLinks
         * @private
         * @returns {void}
         */
        function toggleHandler() {
            $comp.toggleClass(CONST.CSS_CLASSES.navigationLinks);

            $body.animate(
                {
                    scrollTop: $(document).height() - $(window).height()
                },
                scrollTime
            );
        }

        /**
         * Element value
         * @function sitemapHeading
         * @memberOf vca.comp.footerNavigationLinks
         * @private
         * @returns {void}
         */
        function sitemapHeading() {
            // set the value of sitemap text
            $sitemapHeading.text(sitemapText);
        }

        /**
         * Element value
         * @function toggleTabIndexes
         * @memberOf vca.comp.footerNavigationLinks
         * @private
         * @returns {void}
         */
        function toggleTabIndexes() {
            $(CONST.SELECTORS.siteMapLink).each(function() {
                var tabIndex = $(this).attr('tabindex');
                if (tabIndex === '-1') {
                    $(this).attr('tabindex', '0');
                } else {
                    $(this).attr('tabindex', '-1');
                }
            });
        }

        /**
         * Element value
         * @function handleEnterPress
         * @memberOf vca.comp.footerNavigationLinks
         * @private
         * @returns {void}
         */
        function handleEnterPress(event) {
            // check if enter is clicked
            let key = event.charCode || event.keyCode;

            // Enter or Space
            if (key === 13 || key === 32) {
                toggleHandler();
                sitemapHeading();
                toggleTabIndexes();

                //focus on first link inside sitemap if sitemap is active
                if ($(CONST.SELECTORS.navigationLinks).length) {
                    $(CONST.SELECTORS.siteMapWrapper)
                        .find(CONST.SELECTORS.siteMapLink)
                        .first()
                        .focus();
                }
                return false;
            }
        }

        function analyticsCall() {
            let trackingEventObj = {},
                cheetahid = vca.util.queryString.get('chid');

            // Analytics for login and register
            trackingEventObj = {
                cheetahid: cheetahid
            };
            if (cheetahid != undefined) {
                baseUtil.analytics.pushDataToDataLayer(trackingEventObj);
            }
        }

        /**
         * Method to push Footerlink event to sensorsdata
         * @function footerLinkTracking
         * @memberOf vca.comp.footerNavigationLinks
         * @private
         * @param { Object } $this FooterLink Dom element
         * @param { String } eventName Title of the event
         * @returns {void}
         */
        function footerLinkTracking($this, eventName) {
            let trackingEventObj = {};

            if (eventName === 'FooterLink'){
                trackingEventObj = {
                    link: $this.attr(CONST.ATTRIBUTES.title),
                    sublink: 'NA'
                }
            } else {
                trackingEventObj = {
                    link: $this.attr(CONST.ATTRIBUTES.title)
                }
            }

            baseUtil.analytics.pushToSensorsData(eventName, trackingEventObj);
        }

        /**
         * Bind events
         * @function bindEvents
         * @memberOf vca.comp.footerNavigationLinks
         * @private
         * @returns {void}
         */
        function bindEvents() {
            // event handlers
            $toggleClickElem.on(util.customEvents.INTERACTION, toggleHandler);
            $toggleClickElem.on(util.customEvents.INTERACTION, sitemapHeading);
            $toggleClickElem.on(
                util.customEvents.INTERACTION,
                toggleTabIndexes
            );
            $toggleClickElem.on(util.customEvents.KEYUP, handleEnterPress);

            // Check for china only
            if (isCountryCN) {
                $vcaFooterTrackingLinks.on(
                    util.customEvents.INTERACTION,
                    function(){
                        footerLinkTracking($(this), 'FooterLink');
                    }
                );
                $vcaSocialTrackingLinks.on(
                    util.customEvents.INTERACTION,
                    function(){
                        footerLinkTracking($(this), 'SocialLink');
                    }
                );
            }
        }

        /**
         * Cache variables being used.
         * @function cacheVars
         * @memberOf vca.comp.footerNavigationLinks
         * @private
         * @param {HTMLElement} elem The component element
         * @returns {void}
         */
        function cacheVars(elem) {
            $comp = $(elem);
            $toggleClickElem = $comp.find(CONST.SELECTORS.toggleClickElem);
            $sitemapHeading = $(CONST.SELECTORS.sitemapHeading);

            // get the value of sitemap text
            sitemapText = $comp.find(CONST.SELECTORS.sitemapText).text();
            $baseRecaptchaV2 = $(CONST.SELECTORS.vcaMain).find(
                CONST.SELECTORS.baseRecaptchaV2
            );
            $vcaFooterTrackingLinks = $body.find(
                CONST.SELECTORS.vcaFooterTrackingLinks
            );
            $vcaSocialTrackingLinks = $body.find(
                CONST.SELECTORS.vcaSocialTrackingLinks
            );
        }

        /**
         * Initialize the component
         * @function init
         * @memberOf vca.comp.footerNavigationLinks
         * @private
         * @param {HTMLElement} elem The component element
         * @returns {void}
         */
        function init(elem) {
            cacheVars(elem);
            bindEvents();
            analyticsCall();

            if (
                $baseRecaptchaV2.length > 0 &&
                !$baseRecaptchaV2.find('iframe').length
            ) {
                base.comp.captcha.recaptchav2.init($baseRecaptchaV2);
            }
        }

        return {
            init: init
        };
    })(vca.$, vca.util, base.util);
})(window.vca, window.base);

/**
 * notificationBar.js
 * functionality for the notification bar component
 */
(function(w, vca) {
    'use strict';

    var CONST = {
        SELECTORS: {
            btn: '.vca-nb-btn'
        },
        CSS_CLASS: {
            hide: 'vca-hide',
            visible: 'vca-nb-visible',
            notificationBarEnabled: 'vca-nb-active'
        }
    };

    /**
     * notification bar component
     * @namespace notificationBar
     * @memberof vca.comp
     */
    vca.comp.notificationBar = (function($, util) {
        var $comp = null,
            maxAge = null,
            cookieName = 'hideNotification',
            cookiePath = null,
            $closeBtn = null,
            $body = $('body');

        /**
         * Cache variables being used.
         * @function cacheVars
         * @memberOf vca.comp.notificationBar
         * @private
         * @param {HTMLElement} elem The component element
         * @returns {void}
         */
        function cacheVars(elem) {
            $comp = $(elem);
            maxAge = $comp[0].dataset.maxage;
            cookiePath = $comp[0].dataset.cookiePath;
            $closeBtn = $comp.find(CONST.SELECTORS.btn);
        }

        /**
         * Function to dismiss the notification bar on click action of the button.
         * @function onClickHandler
         * @memberOf vca.comp.notificationBar
         * @private
         * @returns {void}
         */
        function onClickHandler() {
            // explicitly remove class display flex from container for the
            // generic class vca-hide to have an effect on it.
            $comp
                .addClass(CONST.CSS_CLASS.hide)
                .removeClass(CONST.CSS_CLASS.visible);

            util.cookieManager.setCookie(
                cookieName,
                'true',
                maxAge,
                cookiePath
            );
            updateNotificationBodyClass();
            $.publish(util.customEvents.NB_HIDDEN);
        }

        /**
         * Add and remove nb active class on body tag
         * @function updateNotificationBodyClass
         * @memberOf vca.comp.notificationBar
         * @private
         * @returns {void}
         */
        function updateNotificationBodyClass(status) {
            if (status) {
                $body.hasClass(CONST.CSS_CLASS.notificationBarEnabled)
                    ? ''
                    : $body.addClass(CONST.CSS_CLASS.notificationBarEnabled);
                return;
            } else {
                $body.removeClass(CONST.CSS_CLASS.notificationBarEnabled);
            }
        }

        /**
         * Bind events
         * @function bindEvents
         * @memberOf vca.comp.notificationBar
         * @private
         * @returns {void}
         */
        function bindEvents() {
            // event handlers
            $closeBtn.on(util.customEvents.INTERACTION, onClickHandler);
        }

        /**
         * Initialize the component
         * @function init
         * @memberOf vca.comp.notificationBar
         * @private
         * @param {HTMLElement} elem The component element
         * @returns {void}
         */
        function init(elem) {
            cacheVars(elem);
            bindEvents();

            if (util.cookieManager.getCookie(cookieName)) {
                $comp
                    .addClass(CONST.CSS_CLASS.hide)
                    .removeClass(CONST.CSS_CLASS.visible);
                updateNotificationBodyClass();
            } else {
                $comp
                    .addClass(CONST.CSS_CLASS.visible)
                    .removeClass(CONST.CSS_CLASS.hide);
                updateNotificationBodyClass(true);
            }
        }

        return {
            init: init
        };
    })(vca.$, vca.util);
})(window, window.vca);

/**
 * contactus.js
 * functionality for the contactus component
 */
(function(vca, base) {
    'use strict';

    const CONST = {
        SELECTORS: {
            contactusBlock: '.vca-contact-wrapper',
            sendMessage: '.vca-narrow-only',
            sendMessageText: '.vca-contact-us-link',
            closeForm: '.vca-icn-close',
            imptxt: '.vca-contact-us-imptxt',
            backButton: '.vca-icn-arrow-right',
            formWrapper: '.vca-contact-us-form-inner',
            confirmWrapper: '.vca-contactus-confirm',
            confirmWrapperBody: '.vca-contactus-confirm-body',
            implicitText: '.vca-contact-us-Implicit-text',
            mandatoryText: '.vca-contact-us-mandatory-text',
            headingText: '.vca-contact-us-form-heading',
            heroWrapper: '.vca-contact-us-hero',
            crcPhoneCta: '.vca-contact-us-call a.vca-concierge-details'
        },
        CSS_CLASSES: {
            showContactForm: 'vca-show-contact-form',
            hide: 'vca-hide'
        },
        SAFE_HEIGHT: 250
    };

    /**
     * contactus component
     * @namespace contactus
     * @memberof vca.comp
     */
    vca.comp.contactus = (function($, util, baseUtil) {
        let $comp = null,
            element = null,
            $sendMessageBlock = null,
            $sendMessage = null,
            $contactusWrapper = null,
            $imptxt = null,
            $closeButton = null,
            $backButton = null,
            $formWrapper = null,
            $confirmWrapper = null,
            $confirmWrapperBody = null,
            $mandatoryText = null,
            $implicitText = null,
            $headingText = null,
            $heroWrapper = null,
            $window = $(window),
            $formHeight = null,
            thankyouMsg = null,
            userName = null,
            isCountryCN = util.dataStore.isChina(),
            $crcPhoneCta = null;

        /**
         * Show light box
         * @function addLightBox
         * @memberOf vca.comp.contactus
         * @private
         * @returns {void}
         */
        function showContactUsForm() {
            manageFormHeight();
            $heroWrapper.addClass(CONST.CSS_CLASSES.hide);
            $comp.addClass(CONST.CSS_CLASSES.showContactForm);
        }

        /**
         * showConfirmation
         * @function showConfirmation
         * @private
         * @param {Object} form Form element
         * @memberof vca.comp.contactus
         * @returns {void}
         */
        function showConfirmation(form) {
            $imptxt.addClass(CONST.CSS_CLASSES.hide);
            $formWrapper.addClass(CONST.CSS_CLASSES.hide);
            $mandatoryText.addClass(CONST.CSS_CLASSES.hide);
            $implicitText.addClass(CONST.CSS_CLASSES.hide);
            $headingText.addClass(CONST.CSS_CLASSES.hide);

            // User name update in thank you msg content update along with scroll

            try {
                const formData = util.forms.getFormData(form);
                const salutation = $formWrapper
                    .find('input[value="' + formData.salutation + '"]')
                    .siblings('label')
                    .text();
                const firstName = formData.first_name1;
                const lastName = formData.last_name1;

                // This might need update in future, for other locales, where the format is different like "Salutation LAST_NAME FirstName".
                userName = salutation + ' ' + firstName + ' ' + lastName;
            } catch (e) {
                userName = '';
            }

            thankyouMsg = $confirmWrapperBody.text();
            thankyouMsg = thankyouMsg.replace('{0}', userName);
            $confirmWrapperBody.text(thankyouMsg);

            $confirmWrapper.removeClass(CONST.CSS_CLASSES.hide);
        }

        /**
         * contactUs form success Tracking call
         * @function successanalyticsCall
         * @memberOf vca.comp.contactus
         * @private
         */
        async function successanalyticsCall(form) {
            let trackingEventObj = {};
            const formData = util.forms.getFormData(form);
            let encryptedEmail = await util.crypto.encryptToSHA256(
                formData.email_address
            );

            // Analytics for form success
            trackingEventObj = {
                event: 'contact_requested',
                topic_selected: formData.topic,
                user_email: encryptedEmail
            };

            baseUtil.analytics.pushDataToDataLayer(trackingEventObj);

            if (isCountryCN) {
                try {
                    const formData = util.forms.getFormData(form);

                    let encryptedEmail = await util.crypto.encryptToSHA256(
                        formData.email_address
                    );

                    baseUtil.analytics.pushToSensorsData('ContactRequest', {
                        purpose: formData.topic,
                        useremail: encryptedEmail
                    });
                } catch (e) {
                    console.log('ERROR @ getFormData =>', e);
                }
            }
        }
        /**
         * Form reinit
         * @function formInitHandler
         * @private
         * @param {Object} form Form element
         * @param {boolean} success Response true/false
         * @memberOf vca.comp.contactus
         */
        function formInitHandler(form, success) {
            if ($comp.find(form).length) {
                if (success) {
                    showConfirmation(form);
                    successanalyticsCall(form);
                } else {
                    cacheVars(element);
                    base.comp.forms.init($(form));
                }
                util.scrollTo.position(0, 500);
            }
        }

        /**
         * Hide light box
         * @function removeLightBox
         * @memberOf vca.comp.contactus
         * @private
         * @returns {void}
         */
        function hideContactUsForm() {
            manageFormHeight();
            $heroWrapper.removeClass(CONST.CSS_CLASSES.hide);
            $comp.removeClass(CONST.CSS_CLASSES.showContactForm);
        }

        /**
         * Bind events
         * @function manageFormHeight
         * @memberOf vca.comp.contactus
         * @private
         * @returns {void}
         */
        function manageFormHeight() {
            util.throttle(function() {
                if ($comp.hasClass(CONST.CSS_CLASSES.showContactForm))
                    $comp.height($formHeight + CONST.SAFE_HEIGHT);
                else $comp.height('auto');
            }, 10)();
        }

        /**
         * Bind events
         * @function bindEvents
         * @memberOf vca.comp.contactus
         * @private
         * @returns {void}
         */
        function bindEvents() {
            // event handlers
            $sendMessage.on(util.customEvents.INTERACTION, showContactUsForm);
            $closeButton.on(util.customEvents.INTERACTION, hideContactUsForm);
            $backButton.on(util.customEvents.INTERACTION, hideContactUsForm);
            // Handle Concierge analytics while on contact us page.
            if ($crcPhoneCta) {
                $crcPhoneCta.on(util.customEvents.INTERACTION, function() {
                    vca.util.crcDataTracking.handleCrcPhoneClick('content');
                });
            }

            // window resize handler
            $window
                .resize(function() {
                    manageFormHeight();
                })
                .resize();
        }

        /**
         * Cache variables being used.
         * @function cacheVars
         * @memberOf vca.comp.contactus
         * @private
         * @param {HTMLElement} elem The component element
         * @returns {void}
         */
        function cacheVars(elem) {
            $comp = $(elem);
            $imptxt = $comp.find(CONST.SELECTORS.imptxt);
            $contactusWrapper = $comp.find(CONST.SELECTORS.contactusBlock);
            $heroWrapper = $comp.find(CONST.SELECTORS.heroWrapper);
            $formWrapper = $contactusWrapper.find(CONST.SELECTORS.formWrapper);

            $confirmWrapper = $contactusWrapper.find(
                CONST.SELECTORS.confirmWrapper
            );
            $confirmWrapperBody = $contactusWrapper.find(
                CONST.SELECTORS.confirmWrapperBody
            );
            $mandatoryText = $contactusWrapper.find(
                CONST.SELECTORS.mandatoryText
            );
            $implicitText = $contactusWrapper.find(
                CONST.SELECTORS.implicitText
            );
            $headingText = $contactusWrapper.find(CONST.SELECTORS.headingText);
            $sendMessageBlock = $comp.find(CONST.SELECTORS.sendMessage);
            $sendMessage = $sendMessageBlock.find(
                CONST.SELECTORS.sendMessageText
            );
            $closeButton = $comp.find(CONST.SELECTORS.closeForm);
            $backButton = $comp.find(CONST.SELECTORS.backButton);
            $formHeight = $formWrapper.innerHeight();
            $crcPhoneCta = $comp.find(CONST.SELECTORS.crcPhoneCta);
        }

        /**
         * Initialize the component
         * @function init
         * @memberOf vca.comp.contactus
         * @private
         * @param {HTMLElement} elem The component element
         * @returns {void}
         */
        function init(elem) {
            element = elem;
            cacheVars(elem);
            bindEvents();
            $.subscribe('base:forms:success', formInitHandler);
        }

        return {
            init: init
        };
    })(vca.$, vca.util, base.util);
})(window.vca, window.base);

/**
 * newsLetter.js
 * functionality for the newsLetter component
 */
(function(vca, base) {
    'use strict';

    /**
     * newsLetter component
     * @namespace newsLetter
     * @memberof vca.comp
     */
    vca.comp.newsLetter = (function($, util, baseUtil) {
        var CONST = {
            SELECTORS: {
                form: '.base-forms-wrapper',
                emailInput: '.vca-es-form-input',
                emailPlaceholder: '#vca-newsletter-form_email_address',
                description: '.vca-newsletters-description',
                newsLetterForm: '.vca-newsletters-form',
                baseServerSideError: '.base-forms-server-side-error',
                newletterConfirm: '.vca-newsletters-confirm',
                nlEaError: '.vca-nl-ea-error',
                nlLoginLink: '.vca-nl-login',
                nlLightboxContent: '.vca-lightbox-content',
                nlBaseResponce: '.base-forms-response-vca-newsletter-form'
            },
            CSS_CLASSES: {
                hide: 'vca-hide',
                newslettersubscription: 'rcms_newslettersubscription'
            },
            DATA_ATTR: {
                countryCode: 'countryCode',
                languageCode: 'languageCode',
                pgtype: 'pgtype',
                pgtypemsn: 'pgtypemsn',
                currencyCode: 'currencyCode',
                ecommerceBuyer: 'isEcommerceBuyer'
            },
            CONTENT: {
                pgtype: 'homepage'
            }
        };

        var $comp = null,
            $body,
            $form,
            $nlLightboxContent = null,
            $emailVal = null,
            $description = null,
            $newsLetterForm = null,
            $newletterConfirm = null,
            redirectionPath = null,
            profileData = null,
            isCountryCN = util.dataStore.isChina();

        /**
         * Set the email id to newletter form.
         * @function setEmail
         * @memberOf vca.comp.newsLetter
         * @private
         * @returns {void}
         */
        function setEmail() {
            $(CONST.SELECTORS.emailPlaceholder).val($emailVal);
        }

        /**
         * showConfirmation
         * @function showConfirmation
         * @private
         * @memberof vca.comp.newsLetter
         */
        function showConfirmation() {
            profileData = util.dataStore.getProfileStoreData();
            $newsLetterForm.addClass(CONST.CSS_CLASSES.hide);
            $description.addClass(CONST.CSS_CLASSES.hide);
            $body.addClass(CONST.CSS_CLASSES.newslettersubscription);
            if (profileData && profileData.logInStatus) {
                $newletterConfirm.removeClass(CONST.CSS_CLASSES.hide);
            } else if (profileData && !profileData.logInStatus) {
                existingAccountError();
            }
        }

        /**
         * Existing Account Error
         * @function existingAccountError
         * @private
         * @param {Object} form Form element
         * @memberof vca.comp.newsLetter
         */
        function existingAccountError() {
            if ($comp.find(CONST.SELECTORS.nlBaseResponce)) {
                $comp
                    .find(CONST.SELECTORS.baseServerSideError)
                    .addClass(CONST.CSS_CLASSES.hide);
                $comp
                    .find(CONST.SELECTORS.nlEaError)
                    .removeClass(CONST.CSS_CLASSES.hide);

                $comp
                    .find(CONST.SELECTORS.nlLoginLink)
                    .on(util.customEvents.INTERACTION, openLoginPanel);

                $nlLightboxContent.scrollTop(0);
            }
        }

        /**
         * Function on clicking
         * @function openLoginPanel
         * @private
         * @memberof vca.comp.newsLetter
         */
        function openLoginPanel() {
            vca.util.lightbox.closeLightbox();
            vca.comp.profile.triggerProfileLink();
            redirectionPath = $comp
                .find(CONST.SELECTORS.nlLoginLink)
                .data('linkUrl');
            util.webStorage.set('nlExistingAccountsLoginFlag', redirectionPath);
            $.subscribe(
                util.customEvents.LB_CLOSED,
                vca.comp.account.removeNlEaaLoginFlag
            );
        }

        /**
         * Form reinit
         * @function formInitHandler
         * @private
         * @param {Object} form Form element
         * @param {boolean} success Response true/false
         * @param {String}  message Response message
         * @param {Object} data Response Object
         * @memberOf vca.comp.newsletters
         */
        function formInitHandler(form, success) {
            if (!success) {
                base.comp.init($(form));
            }
            showConfirmation();
            analyticsEventCall();
        }

        /**
         * newsletters form success Tracking call
         * @function analyticsEventCall
         * @memberOf vca.comp.newsletters
         * @private
         */
        async function analyticsEventCall() {
            let trackingEventObj = {};
            let encryptedEmail = await util.crypto.encryptToSHA256($emailVal);

            // Analytics for form success
            trackingEventObj = {
                event: 'newsletter_subscription',
                user_email: encryptedEmail
            };
            baseUtil.analytics.pushDataToDataLayer(trackingEventObj);

            if (isCountryCN) {
                let encryptedEmail = await util.crypto.encryptToSHA256(
                    $emailVal
                );

                baseUtil.analytics.pushToSensorsData('newsletterSubscription', {
                    useremail: encryptedEmail
                });
            }
        }

        /**
         * teardown the event subscriptions
         * @function teardown
         * @memberOf vca.comp.newsletters
         * @private
         */
        function teardown() {
            $.unsubscribe('base:forms:success');
        }

        /**
         * bind the event subscriptions
         * @function bindEvents
         * @memberOf vca.comp.newsletters
         * @private
         */
        function bindEvents() {
            $.subscribe('base:forms:success', formInitHandler);
        }

        /**
         * newsletters Tracking
         * @function analyticsCall
         * @memberOf vca.comp.newsletters
         * @private
         * @param {HTMLElement} elem The component element
         * @returns {void}
         */
        async function analyticsCall() {
            let trackingEventObj = {},
                countryCode = $comp.data(CONST.DATA_ATTR.countryCode),
                languageCode = $comp.data(CONST.DATA_ATTR.languageCode),
                pgtype = CONST.CONTENT.pgtype,
                currencyCode = $comp.data(CONST.DATA_ATTR.currencyCode),
                ecommerceBuyer = $comp.data(CONST.DATA_ATTR.ecommerceBuyer),
                pagePath,
                cheetahid = vca.util.queryString.get('chid'),
                profileManager = base.util.profileManager,
                profileStoreData = profileManager.getProfileStoreData(),
                userStatus = profileStoreData.logInStatus
                    ? 'logged'
                    : 'notLogged',
                userId = profileStoreData.userId || 'N/A',
                encryptedEmail = '';

            if (profileStoreData.email) {
                encryptedEmail = await vca.util.crypto.encryptToSHA256(profileStoreData.email);
            }

            pagePath =
                '/' +
                countryCode +
                '/' +
                languageCode +
                '/pop-in/newsletter/step1';

            // Analytics for newsletters
            trackingEventObj = {
                event: 'page_view',
                page: pagePath,
                user_status: userStatus || 'N/A',
                user_id: userId || 'N/A',
                ecommerce_buyer: ecommerceBuyer,
                ecommerce_client_type: profileStoreData.logInStatus
                    ? 'web_client'
                    : 'N/A',
                pg_type: pgtype || 'N/A',
                pg_country: countryCode || 'N/A',
                pg_language: languageCode || 'N/A',
                user_email: encryptedEmail || 'N/A',
                currency: currencyCode || tracking[0].ssncurrency || 'N/A'
            };

            if (cheetahid != undefined) {
                Object.assign(trackingEventObj, {
                    cheetahid: cheetahid
                });
            }
            baseUtil.analytics.pushDataToDataLayer(trackingEventObj);
        }

        /**
         * Cache variables being used.
         * @function cacheVars
         * @memberOf vca.comp.newsLetter
         * @private
         * @param {HTMLElement} elem The component element
         * @returns {void}
         */
        function cacheVars(elem) {
            $comp = $(elem);
            $nlLightboxContent = $('body').find(
                CONST.SELECTORS.nlLightboxContent
            );
            $description = $('body').find(CONST.SELECTORS.description);
            $newsLetterForm = $('body').find(CONST.SELECTORS.newsLetterForm);
            $newletterConfirm = $('body').find(
                CONST.SELECTORS.newletterConfirm
            );
            $form = $comp.find('form');
            $emailVal = $(CONST.SELECTORS.emailInput).val();
            $body = $('body');
        }

        /**
         * Initialize the component
         * @function init
         * @memberOf vca.comp.newsLetter
         * @private
         * @param {HTMLElement} elem The component element
         * @returns {void}
         */
        function init(elem) {
            cacheVars(elem);
            teardown();
            setEmail();
            //newsletters form
            base.comp.forms.init($form);
            base.util.initialise(base.$('.vca-newsletters'));
            bindEvents();
            analyticsCall();
        }

        return {
            init: init
        };
    })(vca.$, vca.util, base.util);
})(window.vca, window.base);

/**
 * multipleCollectionBlock.js
 * functionality for the multipleCollectionBlock component
 */
(function(vca) {
    'use strict';

    /**
     * multipleCollectionBlock component
     * @namespace multipleCollectionBlock
     * @memberof vca.comp
     */
    vca.comp.multipleCollectionBlock = (function($, util) {
        var CONST = {
            SELECTORS: {
                carousel: '.vca-mc-carousel',
                carouselChildren: '.vca-cc-small:not(.slick-cloned)'
            },
            CSS_CLASSES: {
                slickActive: 'slick-initialized'
            },
            DEFAULT_SLICK_SETTINGS: {
                arrows: false,
                dots: true,
                centerMode: true,
                adaptiveHeight: true,
                infinite: true,
                slidesToShow: 1,
                slidesToScroll: 1,
                variableWidth: true
            }
        };

        var $comp = null,
            $carousel = null,
            $window = $(window),
            $carouselChildren = null;

        /**
         * Carousel reinit
         * @function slickHandler
         * @private
         * @memberOf vca.comp.multipleCollectionBlock
         */
        function slickUslickCarousel() {
            var child = $carouselChildren.length;

            if ($window.width() > 700 && child <= 2) {
                if ($carousel.hasClass(CONST.CSS_CLASSES.slickActive)) {
                    $carousel.slick('unslick');
                }
            } else {
                if (!$carousel.hasClass(CONST.CSS_CLASSES.slickActive)) {
                    vca.util.carousel.contextualInit(
                        CONST.DEFAULT_SLICK_SETTINGS
                    );
                }
            }
        }

        /**
         * Bind events
         * @function bindEvents
         * @memberOf vca.comp.multipleCollectionBlock
         * @private
         * @returns {void}
         */
        function bindEvents() {
            // bind event on window resize
            $.subscribe(util.customEvents.RESIZED, slickUslickCarousel);
        }

        /**
         * Cache variables being used.
         * @function cacheVars
         * @memberOf vca.comp.multipleCollectionBlock
         * @private
         * @param {HTMLElement} elem The component element
         * @returns {void}
         */
        function cacheVars(elem) {
            $comp = $(elem);
            $carousel = $comp.find(CONST.SELECTORS.carousel);
            $carouselChildren = $comp.find(CONST.SELECTORS.carouselChildren);
        }

        /**
         * Initialize the component
         * @function init
         * @memberOf vca.comp.multipleCollectionBlock
         * @private
         * @param {HTMLElement} elem The component element
         * @returns {void}
         */
        function init(elem) {
            cacheVars(elem);
            bindEvents();
            slickUslickCarousel();
        }

        return {
            init: init
        };
    })(vca.$, vca.util);
})(window.vca);

/**
 * qrCodePopup.js
 * functionality for QR Code Popup
 */

(function(vca) {
    'use strict';
    var CONST = {
        SELECTORS: {
            comp: '.vca-qrc-link',
            temp: '.vca-qrc-temp'
        }
    };

    /**
     * qrCodePopup component
     * @namespace qrCodePopup
     * @memberof vca.comp
     */
    vca.comp.qrCodePopup = (function($, util) {
        var $body = $('body'),
            $temp = null,
            $comp = null,
            $html = null,
            configObject = null;

        /**
         * Create an config object for lightbox
         * @function lightboxObj
         * @memberOf vca.comp.qrCodePopup
         * @private
         * @returns {object} The lightbox object
         */
        function lightboxObj() {
            var newObject = {
                lightboxMould: $comp.data('lightbox-mould') || 'center',
                customCssClass: $comp.data('custom-class') || '',
                headerText: $comp.data('lightbox-header') || '',
                cacheburst: $comp.data('cache-burst') || false};

            return newObject;
        }

        /**
         * Open lightbox
         * @function openLightbox
         * @memberOf vca.comp.qrCodePopup
         * @private
         * @param {Event} e The click event
         */
        function openLightbox(e) {
            if (e) {
                // Execute lightbox util method to open lightbox with html and list of parameters as an object
                util.lightbox.openContentInLightBox($html,configObject);
            } 
        }

        /**
         * Bind events
         * @function bindEvents
         * @memberOf vca.util.tabs
         * @private
         * @returns {void}
         */
        function bindEvents() {
            $body.on(
                util.customEvents.INTERACTION,
                CONST.SELECTORS.comp,
                openLightbox
            );
        }

        /**
         * Cache variables being used
         * @function cacheVars
         * @memberOf vca.comp.qrCodePopup
         * @private
         */
        function cacheVars() {
            $comp = $body.find(CONST.SELECTORS.comp);
            $temp = $body.find(CONST.SELECTORS.temp);
            $html = $temp.html();

            // Create an config object for lightbox
            configObject = lightboxObj();
        }


        /**
         * Initialise instance of qrCodePopup
         * @function init
         * @memberOf vca.util.qrCodePopup
         * @private
         */
        function init() {
            cacheVars();
            bindEvents();
        }

        return {
            init: init
        };
    })(vca.$, vca.util);
})(window.vca);

/**
 * bemIllustration.js
 * functionality for BEM
 */

(function(vca, $, util) {
    'use strict';
    const CONST = {
        SELECTORS: {
            carouselImg: '.vca-transform-image-tag',
            carouselWrapper: '.vca-mc-carousel',
            carouselIllImg: '.vca-ill-img',
            captionText: '.vca-cap-text',
            dossierCardContent: '.vca-dossier-card:not(.vca-dossier-card-full-width) .vca-card-content',
            dossierCardArticles: '.vca-article-count',
            dossierCardSubTitle: '.vca-card-sub-title',
            dossierCardTitle: '.vca-card-title',
            dossierCardDescription: '.vca-card-description',
            sliderImage: '.slick-slide img'
        },
        CSS_CLASSES: {
            bemCarouselImg: 'vca-bem-mul-img-car',
            maxHeight: 'vca-mulill-mh',
            hide: 'vca-hide',
            showCaption: 'vca-show-caption-now',
            layLoading: 'lazyloading'
        },
        recursionThresholdTimeInSecs: 90,
        throttleFrequency: 3500
    };

    /**
     * Constructor for CCProduct
     * @memberof vca.util.ccProduct
     * @private
     * @constructor
     * @param {HTMLElement} elem The component element
     */
    function BEMIllustration(elem) {
        this.$comp = $(elem);
        this.listeners = [];
        this.$imgCarousel = null;
        this.$carouselWrapper = null;
        this.startTimerAt = null;
        this.minHeightLimit = 200;
        this.maxHeightLimit = null;

        this.initialize.apply(this);
    }

    BEMIllustration.prototype = {
        /*
        TODO: commenting these methodd as of current need doesnt required but might be useful in future. Will cleanup later when it confrimed
        */
        /**
         * It update the height of all image elements under imgCarousel
         * @method fixCarouselHeight
         * @memberOf vca.comp.bemIllustration.BEMIllustration#
         * @private
         * @returns {void}
         */
        // fixCarouselHeight: function() {
        //     let minHeight = 0,
        //         heightArr = [],
        //         breakOut = false,
        //         currentTimmerAt = new Date(),
        //         timerAt = null,
        //         self = this;
        //     timerAt =
        //         (currentTimmerAt.getTime() - this.startTimerAt.getTime()) /
        //         1000;

        //     if (timerAt > CONST.recursionThresholdTimeInSecs) {
        //         return false;
        //     }
        //     this.$imgCarousel.each(function(i, elem) {
        //         let currentImgHeight = $(elem).height();
        //         if (currentImgHeight <= 1) {
        //             util.throttle(function() {
        //                 self.fixCarouselHeight();
        //             }, CONST.throttleFrequency)();
        //             breakOut = true;
        //             return false;
        //         } else {
        //             if (
        //                 (heightArr.length && heightArr[0] > currentImgHeight) ||
        //                 !heightArr.length
        //             ) {
        //                 heightArr.push(currentImgHeight);
        //             }
        //         }
        //     });
        //     if (breakOut) {
        //         breakOut = false;
        //         return false;
        //     }
        //     minHeight = Math.min.apply(null, heightArr);
        //     minHeight =
        //         minHeight < this.minHeightLimit
        //             ? this.minHeightLimit
        //             : minHeight > this.maxHeightLimit
        //             ? this.maxHeightLimit
        //             : minHeight;
        //     this.$imgCarousel
        //         .css('height', minHeight)
        //         .addClass(CONST.CSS_CLASSES.bemCarouselImg);
        //     this.$carouselWrapper.removeClass(CONST.CSS_CLASSES.maxHeight);
        //     this.updateCaptionWidth();
        // },

        /**
         * Update caption block width base on resized image height
         * @method updateCaptionWidth
         * @memberOf vca.comp.bemIllustration.BEMIllustration#updateCaptionWidth
         * @private
         * @returns {void}
         */
        updateCaptionWidth: function() {
            this.$imgCarousel.each(function(i, elem) {
                let $captionElem = $(elem)
                    .closest(CONST.SELECTORS.carouselIllImg)
                    .find(CONST.SELECTORS.captionText);
                if (!util.wcmmode.isEditMode) {
                    let currentImgWidth = $(elem).width();
                    $captionElem
                        .width(currentImgWidth)
                        .addClass(CONST.CSS_CLASSES.showCaption);
                } else {
                    $captionElem
                        .width('100%')
                        .addClass(CONST.CSS_CLASSES.showCaption);
                }
            });
            this.$comp
                .find(CONST.SELECTORS.captionText)
                .removeClass(CONST.CSS_CLASSES.hide);
        },

        /*
        TODO: commenting these methodd as of current need doesnt required but might be useful in future. Will cleanup later when it confrimed
        */

        /**
         * first check if all carousel images are uploaded and then update there heights
         * @method onImageLoadSetHeight
         * @memberOf vca.comp.bemIllustration.BEMIllustration#onImageLoadSetHeight
         * @private
         * @returns {void}
         */

        // onImageLoadSetHeight: function() {
        //     let deferreds = [],
        //         self = this;
        //     this.$imgCarousel.each(function() {
        //         if (!this.complete) {
        //             let deferred = $.Deferred();
        //             $(this).one('load', deferred.resolve);
        //             deferreds.push(deferred);
        //         }
        //     });
        //     $.when.apply($, deferreds).done(function() {
        //         /* things to do when all carousel images loaded */
        //         self.startTimerAt = new Date();
        //         self.fixCarouselHeight();
        //     });
        //     this.updateCaptionWidth();
        // },

        /**
         * update maxheight based on matchmedia
         * @method updateMinMaxHeights
         * @memberOf vca.comp.bemIllustration.BEMIllustration#updateMinMaxHeights
         * @private
         * @returns {void}
         */
        updateMinMaxHeights: function() {
            if (util.matchmedia.narrow.matches) {
                this.maxHeightLimit = 315;
            } else if (util.matchmedia.tablet.matches) {
                this.maxHeightLimit = 380;
            } else if (util.matchmedia.wide.matches) {
                this.maxHeightLimit = 460;
            } else if (util.matchmedia.superWide.matches) {
                this.maxHeightLimit = 460;
            }
        },

        /**
         * throttled handler to update caption width
         * @method throttledUpdateCaptionWidth
         * @memberOf vca.comp.bemIllustration.BEMIllustration#throttledUpdateCaptionWidth
         * @private
         * @returns {void}
         */
        throttledUpdateCaptionWidth: function() {
            const self = this;
            util.throttle(function() {
                self.updateCaptionWidth();
            }, CONST.throttleFrequency)();
        },
        /**
         * callback handler on window resize, update carousel on resize
         * @method updateCarouselOnResize
         * @memberOf vca.comp.bemIllustration.BEMIllustration#updateCarouselOnResize
         * @private
         * @returns {void}
         */
        updateCarouselOnResize: function() {
            this.updateMinMaxHeights();
            /*
            TODO: commenting these methodd as of current need doesnt required but might be useful in future. Will cleanup later when it confrimed
            */
            // this.onImageLoadSetHeight();

            this.throttledUpdateCaptionWidth();
        },

        /**
         * start method, initial instruction for this util
         * @method start
         * @memberOf vca.comp.bemIllustration.BEMIllustration#start
         * @private
         * @returns {void}
         */
        start: function() {
            /*
            TODO: commenting these methodd as of current need doesnt required but might be useful in future. Will cleanup later when it confrimed
            */
            // this.onImageLoadSetHeight();
            this.throttledUpdateCaptionWidth();
        },

        /**
         * Bind events
         * @method bindEvents
         * @memberOf vca.comp.bemIllustration.BEMIllustration#bindEvents
         * @private
         * @returns {void}
         */
        bindEvents: function() {
            // bind event on window resize
            this.listeners.push(
                $.subscribe(
                    util.customEvents.RESIZED,
                    this.updateCarouselOnResize.bind(this)
                )
            );
            this.listeners.push(
                $.subscribe(
                    util.customEvents.SLICK_INIT,
                    this.throttledUpdateCaptionWidth.bind(this)
                )
            );
            // To handle the lazyloaded images
            $(CONST.SELECTORS.sliderImage).on('load', event => {
                if (event.target.classList.contains(CONST.CSS_CLASSES.layLoading)) {
                    this.throttledUpdateCaptionWidth();
                }
            });
        },

        /**
         * Unbind events
         * @function teardown
         * @memberOf vca.comp.bemIllustration.BEMIllustration#teardown
         * @private
         * @returns {void}
         */
        teardown: function() {
            while (this.listeners.length) {
                $.unsubscribe(this.listeners.pop());
            }
        },

        /**
         * Cache variables being used
         * @method cacheVars
         * @memberOf vca.comp.bemIllustration.BEMIllustration#cacheVars
         * @private
         */
        cacheVars: function() {
            this.$imgCarousel = this.$comp.find(CONST.SELECTORS.carouselImg);
            this.$carouselWrapper = this.$comp.find(
                CONST.SELECTORS.carouselWrapper
            );
        },

        /**
         * Initialise bemIllustration
         * @method initialize
         * @memberOf vca.comp.bemIllustration.BEMIllustration#initialize
         * @private
         */
        initialize: function() {
            this.teardown();
            this.cacheVars();
            this.updateMinMaxHeights();
            this.bindEvents();
            // TODO: need to remove while refectoring, once requirement freeze
            //this.start();
        }
    };

    /**
     * bemIllustration component
     * @namespace bemIllustration
     * @memberof vca.comp
     */
    vca.comp.bemIllustration = (function() {
        /**
         * Initialise instance of bem Illustration
         * @function init
         * @memberOf vca.comp.bemIllustration
         * @private
         */
        function init($bemIllustration) {
            new BEMIllustration($bemIllustration);
        }

        return {
            init: init
        };
    })();
})(window.vca, vca.$, vca.util);

/**
 * featureCover.js
 * functionality for the featureCover component
 */
(function(vca) {
    'use strict';

    var CONST = {
        SELECTORS: {
            videoPlayer: '.vca-video-tag',
            assetWrapper: '.vca-composite-asset-wrapper',
            featureCoverLink: '.vca-feature-cover-link'
        },
        ATTRIBUTES: {
            mobileFoldingCover: 'mobileFoldingCover',
            preventRedirect: 'preventRedirect'
        }
    };

    /**
     * featureCover component
     * @namespace featureCover
     * @memberof vca.comp
     */
    vca.comp.featureCover = (function($, util) {
        var $comp = null,
            $assetWrapper = null,
            $videoPlayer = null,
            $mobileFoldingCover = null,
            $featureCoverLink = null,
            $preventRedirect = null;

        /**
         * Handle click on video to toggle play/pause
         * @function videoClickHandler
         * @memberOf vca.comp.featureCover
         * @private
         * @returns {void}
         */
        const videoClickHandler = () => {
            let videoPlayerEl = $videoPlayer.get(0);
            if (!videoPlayerEl) return;

            if (videoPlayerEl.paused) {
                videoPlayerEl.play();
            } else {
                videoPlayerEl.pause();
            }
        };

        /**
         * Updates variables being used.
         * @function cacheVars
         * @memberOf vca.comp.featureCover
         * @private
         * @param {HTMLElement} elem The component element
         * @returns {void}
         */
        function cacheVars(elem) {
            $comp = $(elem);
            $mobileFoldingCover = $comp.data(
                CONST.ATTRIBUTES.mobileFoldingCover
            );
            $assetWrapper = $comp.find(CONST.SELECTORS.assetWrapper);
            $featureCoverLink = $comp.find(CONST.SELECTORS.featureCoverLink);
            $preventRedirect = $featureCoverLink.data(
                CONST.ATTRIBUTES.preventRedirect
            );
            if (
                $mobileFoldingCover &&
                $mobileFoldingCover != 'default' &&
                $preventRedirect
            ) {
                $videoPlayer = $comp.find(CONST.SELECTORS.videoPlayer);
            }
        }

        /**
         * Bind events
         * @function bindEvents
         * @memberOf vca.comp.featureCover
         * @private
         * @returns {void}
         */
        function bindEvents() {
            if ($videoPlayer) {
                $assetWrapper.on(
                    util.customEvents.INTERACTION,
                    videoClickHandler
                );
            }
        }

        /**
         * Initialize the component
         * @function init
         * @memberOf vca.comp.featureCover
         * @private
         * @param {HTMLElement} elem The component element
         * @returns {void}
         */
        function init(elem) {
            cacheVars(elem);
            bindEvents();
        }

        return {
            init: init
        };
    })(vca.$, vca.util);
})(window.vca);

/**
 * nanosites.js
 * functionality for the nanosites component
 */
(function(vca, base) {
    'use strict';

    /**
     * nanosites component
     * @namespace nanosites
     * @memberof vca.comp
     */
    vca.comp.nanosites = (function($, util, baseUtil) {
        var CONST = {
            DATA_ATTR: {
                nanositeFamily: 'nanositeFamily',
                nanositeChapter: 'nanositeChapter'
            }
        };

        var $comp = null;

        /**
         * nanosites Tracking
         * @function analyticsCall
         * @memberOf vca.comp.nanosites
         * @private
         * @returns {void}
         */
        function analyticsCall() {
            let path = window.location.pathname,
                pageName = path.split('/').pop();


            // Analytics for nanosites
            let trackingEventObj = {
                event: 'ecommerce_context',
                nanosite: pageName || 'N/A',
                nanosite_family: $comp.data(CONST.DATA_ATTR.nanositeFamily) || 'N/A',
                nanosite_chapter: $comp.data(CONST.DATA_ATTR.nanositeChapter) || 'N/A'
            };

            baseUtil.analytics.pushDataToDataLayer(trackingEventObj);
        }

        /**
         * Cache variables being used.
         * @function cacheVars
         * @memberOf vca.comp.nanosites
         * @private
         * @param {HTMLElement} elem The component element
         * @returns {void}
         */
        function cacheVars(elem) {
            $comp = $(elem);
        }

        /**
         * Initialize the component
         * @function init
         * @memberOf vca.comp.nanosites
         * @private
         * @param {HTMLElement} elem The component element
         * @returns {void}
         */
        function init(elem) {
            cacheVars(elem);
            analyticsCall();
        }

        return {
            init: init
        };
    })(vca.$, vca.util, base.util);
})(window.vca, window.base);
/**
 * searchBar.js
 * functionality for the searchBar component
 */
(function(vca, base) {
    'use strict';

    const CONST = {
        SELECTORS: {
            body: '.vca-body',
            html: 'html',
            headerWrapper: '.vca-header-wrapper',
            header: '.vca-header',
            searchBarContainer: '.vca-sb-container',
            searchBar: '.vca-search-bar',
            searchLink: '.vca-sm-search-link',
            searchCloseBtn: '.vca-sb-btn-close',
            baseSearchInput: '.base-search-input',
            baseSearchForm: '.base-search-form',
            autocompleteKeywordHeading:
                '.base-autocomplete-keyword-title:first',
            autocompleteSuggestion: '.autocomplete-suggestion'
        },
        CLASSES: {
            searchBar: 'vca-search-bar',
            searchBarActive: 'vca-sb-active',
            searchBarOpened: 'vca-sb-opened',
            searchCloseBtn: 'vca-sb-btn-close',
            baseSearchInput: 'base-search-input',
            quickLinks: 'vca-sb-quick-link',
            restrictScrolling: 'vca-restrict-scrolling',
            transparentHeader: 'vca-header-theme-background-transparent'
        }
    };

    /**
     * searchBar component
     * @namespace searchBar
     * @memberof vca.comp
     */
    vca.comp.searchBar = (function($, util, baseUtil) {
        let $comp = null,
            $html,
            $body,
            $searchInput,
            $searchLink,
            $searchForm,
            listeners = [],
            isHeaderTransparent = null,
            isIOS;

        /**
         * Toggle search bar handler
         * @function toggleSearchBarHandler
         * @memberOf vca.comp.searchBar
         * @public
         * @desc - It will toggle the search bar Visibility.
         * @returns {void}
         */
        function toggleSearchBarHandler() {
            $comp.toggleClass(
                CONST.CLASSES.searchBarActive,
                !$comp.hasClass(CONST.CLASSES.searchBarActive)
            );
            $body.toggleClass(
                CONST.CLASSES.searchBarOpened,
                !$body.hasClass(CONST.CLASSES.searchBarOpened)
            );
            $html.toggleClass(
                CONST.CLASSES.restrictScrolling,
                !$html.hasClass(CONST.CLASSES.restrictScrolling)
            );
            // toggle header background color to white when search is open and header is transparent
            if (
                isHeaderTransparent &&
                $comp.hasClass(CONST.CLASSES.searchBarActive)
            ) {
                if (
                    isIOS &&
                    (util.matchmedia.narrow.matches ||
                        util.matchmedia.tablet.matches)
                ) {
                    util.throttle(function() {
                        vca.comp.header.toggleTransparentHeaderBg(true);
                    }, 100)();
                } else {
                    vca.comp.header.toggleTransparentHeaderBg(true);
                }
            } else if (
                isHeaderTransparent &&
                !$comp.hasClass(CONST.CLASSES.searchBarActive)
            ) {
                // toggle back if current scroll position requires
                if (isScrollPosAllowTPHeader()) {
                    vca.comp.header.toggleTransparentHeaderBg(false);
                }
            }
        }

        /**
         * @function isScrollPosAllowTPHeader
         * @memberOf vca.comp.searchBar
         * @private
         * @desc - This handler returns wether current scroll position need transparent header or not
         * @returns {Boolean}
         */
        function isScrollPosAllowTPHeader() {
            const element =
                    document.scrollingElement || document.documentElement,
                scrolledPosition = element.scrollTop;
            return scrolledPosition <= vca.comp.header.getHeaderHeight();
        }

        /**
         * Search box close button click handler
         * @function closeBtnClickHandler
         * @memberOf vca.comp.searchBar
         * @private
         * @desc - It will close opened seearch bar if search box is empty otherwise it clear search input.
         * @returns {void}
         */
        function closeBtnClickHandler() {
            if ($searchInput.val()) {
                $searchInput.val('');
                return;
            }
            toggleSearchBarHandler();
        }

        /**
         * Search bar interaction event delegation handler
         * @function searchBarClickHandler
         * @memberOf vca.comp.searchBar
         * @private
         * @returns {void}
         */
        function searchBarClickHandler(event) {
            let $targetElement = $(event.target);
            if (!$targetElement.hasClass(CONST.CLASSES.quickLinks)) {
                event.preventDefault();
                /* handle close icon click*/
                if ($($targetElement).hasClass(CONST.CLASSES.searchCloseBtn)) {
                    closeBtnClickHandler(event);
                    return;
                }
                /* Close search if click outside search container*/
                if (
                    $body.hasClass(CONST.CLASSES.searchBarOpened) &&
                    !$targetElement.parents(CONST.SELECTORS.searchBarContainer)
                        .length
                ) {
                    toggleSearchBarHandler();
                    return;
                }
            }
        }

        /**
         * Close search bar handler
         * @function closeSearchBar
         * @memberOf vca.comp.searchBar
         * @public
         * @desc - It will close/hide the search bar if opened/visible.
         * @returns {void}
         */
        function closeSearchBar() {
            if ($body.hasClass(CONST.CLASSES.searchBarOpened)) {
                toggleSearchBarHandler();
            }
        }

        /**
         * autocomplete suggestions click handler
         * @function autocompleteSuggestionHandler
         * @memberOf vca.comp.searchBar
         * @private
         * @returns {void}
         */
        function autocompleteSuggestionHandler(event) {
            if (
                $(event.target).prevAll(
                    CONST.SELECTORS.autocompleteKeywordHeading
                ).length
            ) {
                if (event.target.innerText) {
                    $searchInput.val(event.target.innerText);
                    window.base.util.analytics.pushDataToDataLayer({
                        event: 'search_suggested_term',
                        term_clicked: event.target.innerText
                    });
                    $searchForm.submit();
                }
            }
        }

        /**
         * Bind events
         * @function bindEvents
         * @memberOf vca.comp.searchBar
         * @private
         * @returns {void}
         */
        function bindEvents() {
            // event handlers for search icon
            $searchLink.on(
                util.customEvents.INTERACTION,
                toggleSearchBarHandler
            );

            /* event delegation handler for searchBar comp*/
            $(document).on(
                util.customEvents.INTERACTION,
                CONST.SELECTORS.searchBar,
                searchBarClickHandler
            );

            /* Submit form on enter press */
            $searchForm.on('keyup', function(event) {
                if (event.keyCode === 13) {
                    $searchForm.submit();
                }
            });

            /* toggle search bar on ESCAPE key pressed */
            $(document).on('keydown', function(event) {
                if (event.keyCode == 27) {
                    if ($body.hasClass(CONST.CLASSES.searchBarOpened)) {
                        toggleSearchBarHandler();
                    }
                }
            });

            $(document).on(
                util.customEvents.INTERACTION,
                CONST.SELECTORS.autocompleteSuggestion,
                autocompleteSuggestionHandler
            );

            listeners.push(
                $.subscribe(util.customEvents.LB_OPENED, closeSearchBar)
            );
            listeners.push(
                $.subscribe(util.customEvents.NAV_OPENED, closeSearchBar)
            );
        }

        /**
         * Update the search box input field with the searched query param
         * @function setSearchQuery
         * @memberOf vca.comp.searchBar
         * @private
         * @returns {void}
         */
        function setSearchQuery() {
            const searchQueryParam = vca.util.queryString.get('q');
            if (searchQueryParam) {
                $(CONST.SELECTORS.baseSearchInput).val(searchQueryParam);
            }
        }

        /**
         * Initialize the component execution
         * @function start
         * @memberOf vca.comp.searchBar
         * @private
         * @returns {void}
         */
        function start() {
            setSearchQuery();
        }

        /**
         * Updates variables being used.
         * @function cacheVars
         * @memberOf vca.comp.searchBar
         * @private
         * @param {HTMLElement} elem The component element
         * @returns {void}
         */
        function cacheVars(elem) {
            $comp = $(elem);
            $html = $(CONST.SELECTORS.html);
            $body = $(CONST.SELECTORS.body);
            $searchLink = $(CONST.SELECTORS.searchLink);
            $searchForm = $(CONST.SELECTORS.baseSearchForm);
            $searchInput = $comp.find(CONST.SELECTORS.baseSearchInput);
            isHeaderTransparent = $body
                .find(CONST.SELECTORS.header)
                .hasClass(CONST.CLASSES.transparentHeader);
            isIOS = baseUtil.deviceDetection.isIOS();
        }

        /**
         * Unbinds all pre-existing events
         * @function teardown
         * @memberOf vca.comp.searchBar
         * @private
         * @returns {void}
         */
        function teardown() {
            $comp.off(util.customEvents.INTERACTION);
            $searchForm.off('keyup');
            while (listeners.length) {
                $.unsubscribe(listeners.pop());
            }
        }

        /**
         * Initialize the component
         * @function init
         * @memberOf vca.comp.searchBar
         * @private
         * @param {HTMLElement} elem The component element
         * @returns {void}
         */
        function init(elem) {
            cacheVars(elem);
            teardown();
            bindEvents();
            start();
        }

        return {
            init: init,
            toggleSearchBar: toggleSearchBarHandler,
            closeSearchBar: closeSearchBar
        };
    })(vca.$, vca.util, base.util);
})(window.vca, base);

/**
 * serviceMenu.js
 * functionality for the serviceMenu component
 */
(function(vca) {
    'use strict';
    var CONST = {
        SELECTORS: {
            list: '.vca-sm-list',
            item: '.vca-sm-item',
            account: '.vca-icn-profile'
        },
        CLASSES: {
            added: 'vca-added',
            active: 'vca-sm-active',
            hover: 'vca-sm-hover',
            hide: 'vca-hide',
            cart: 'vca-sm-minicart'
        }
    };

    /**
     * serviceMenu component
     * @namespace serviceMenu
     * @memberof vca.comp
     */
    vca.comp.serviceMenu = (function($, util) {
        var $comp = null,
            listeners = [];

        /**
         * Menu item focus handler
         * @function itemMouseEnterHandler
         * @memberOf vca.comp.serviceMenu
         * @private
         * @param {Event} e The focus event
         * @returns {void}
         */
        function itemMouseEnterHandler(e) {
            let $thisElem = $(e.currentTarget || e.target);
            if (!$thisElem.hasClass(CONST.CLASSES.added)) {
                $thisElem.addClass(CONST.CLASSES.active);
                $thisElem.addClass(CONST.CLASSES.hover);
            }
        }

        /**
         * Menu item focus out handler
         * @function itemMouseLeaveHandler
         * @memberOf vca.comp.serviceMenu
         * @private
         * @param {Event} e The focus out event
         * @returns {void}
         */
        function itemMouseLeaveHandler(e) {
            let $thisElem = $(e.currentTarget || e.target);
            $thisElem.removeClass(CONST.CLASSES.hover);
            $thisElem.removeClass(CONST.CLASSES.active);
        }

        /**
         * Cache variables being used.
         * @function cacheVars
         * @memberOf vca.comp.serviceMenu
         * @private
         * @param {HTMLElement} elem The component element
         * @returns {void}
         */
        function cacheVars(elem) {
            $comp = $(elem);
        }

        /**
         * open overlay
         * @memberOf vca.comp.serviceMenu
         * param: {e} event
         * @private
         * @returns {void}
         */
        // function openOverlay() {
        //     $body.addClass(CONST.CLASSES.lightboxOpen);
        // }

        //function initalizeAccountComps() {
        //comp.account.init(vca.$('[data-component-name="account"]'));
        // }

        /**
         * Bind events
         * @function bindEvents
         * @memberOf vca.comp.serviceMenu
         * @private
         * @returns {void}
         */
        function bindEvents() {
            // event subscribers
            // listeners.push(
            //     $.subscribe(
            //         baseUtil.customEvents.CART_UPDATED,
            //         cartUpdateHandler
            //     )
            // );

            // event handlers
            $comp.on(
                util.customEvents.MOUSE_ENTER,
                CONST.SELECTORS.item,
                itemMouseEnterHandler
            );

            $comp.on(
                util.customEvents.MOUSE_LEAVE,
                CONST.SELECTORS.item,
                itemMouseLeaveHandler
            );

            //$.subscribe('vca:lightbox:content:set', initalizeAccountComps);
        }

        /**
         * Unbinds all pre-existing events
         * @function teardown
         * @memberOf vca.comp.serviceMenu
         * @private
         * @returns {void}
         */
        function teardown() {
            while (listeners.length) {
                $.unsubscribe(listeners.pop());
            }

            // $comp.off(
            //     util.customEvents.INTERACTION,
            //     CONST.SELECTORS.infoToggleBtn,
            //     infoToggleBtnClickHandler
            // );
        }

        /**
         * Initialize the component
         * @function init
         * @memberOf vca.comp.serviceMenu
         * @private
         * @param {HTMLElement} elem The component element
         * @returns {void}
         */
        function init(elem) {
            const isTouchDevices =
                'ontouchstart' in window &&
                (util.matchmedia.narrow.matches ||
                    util.matchmedia.tablet.matches);

            // to restrict minicart to appear on touch devices
            if (isTouchDevices) {
                return;
            }

            cacheVars(elem);
            teardown();
            bindEvents();
        }

        return {
            init: init
        };
    })(vca.$, vca.util);
})(window.vca);

/**
 * miniCart.js
 * functionality for the miniCart component
 */
(function(vca, base) {
    'use strict';

    var CONST = {
        SELECTORS: {
            comp: '.vca-sm-minicart',
            close: '.vca-smm-close',
            count: '.vca-sm-count',
            sbLink: '.vca-smmc-link',
            taxInfo: '.vca-smmdti-tax',
            itemTmpl: '.vca-smm-item-tmpl',
            list: '.vca-smm-list',
            smLink: '.vca-sm-link',
            navigationFooter: '.vca-navigation-footer',
            itemTmplRecentlyViewed: '.vca-js-template-mc-rv',
            itemTmplCollection: '.vca-js-template-mc-ccd',
            noProductElem: '.vca-mini-cart-np',
            recentlyViewedElem: '.vca-smm-list-rv',
            recentlyViewedLink: '.vca-ccp-link',
            categoryElem: '.vca-smm-list-cat',
            collectionCta: '.vca-mc-np-controls',
            catergoryCard: '.vca-cc-cat-card',
            collectionCard: '.vca-cc-col-card',
            slickInitialized: '.slick-initialized',
            recentlyViewedTitle: '.vca-rv-title'
        },
        CLASSES: {
            active: 'vca-sm-active',
            hide: 'vca-hide',
            added: 'vca-added',
            interacted: 'vca-sm-interacted',
            spl: 'vca-spl-cls'
        },
        ATTRIBUTES: {
            familyCardType: 'data-family-card-type',
            dataItems: 'data-items'
        },
        PRODUCT_SLICK_SETTINGS: {
            dots: true,
            infinite: false,
            arrows: false,
            slidesToShow: 2,
            slidesToScroll: 1,
            responsive: [
                {
                    breakpoint: 900,
                    settings: {
                        dots: true
                    }
                },
                {
                    breakpoint: 899,
                    settings: 'unslick'
                }
            ]
        },
        SET_RTL: {
            rtl: true
        },
        CH_STORE: {
            productType: 'recentlyviewed',
            productCount: 12,
            category: 'category',
            collection: 'collection',
            carouselMinLength: 3
        },

        CLOSE_DURATION: 3 * 1000 // 3 seconds
    };

    /**
     * miniCart component
     * @namespace miniCart
     * @memberof vca.comp
     */
    vca.comp.miniCart = (function($, util, baseUtil) {
        var $comp = null,
            listeners = [],
            $count = null,
            $list = null,
            $sbLink = null,
            $taxInfo = null,
            tmplObj = null,
            tmplObjRecentlyViewed = null,
            tmplObjCollection = null,
            $recentlyViewedElem = null,
            $categoryElem = null,
            $collectionCta = null,
            $recentlyViewedTitle = null,
            $noProductElem = null;

        /**
         * CMS-Base cart update handler
         * @function cartUpdateHandler
         * @memberOf vca.comp.miniCart
         * @private
         * @param {JSON} data The json response from cart json call OR from the cart contexthub store
         * @returns {void}
         */
        function cartUpdateHandler(data) {
            let closeBisLightbox;

            try {
                closeBisLightbox = vca.comp.product.closeBisLightbox() || false;
            } catch (e) {
                closeBisLightbox = true;
            }

            // Safe check for close lightbox if item added to cart and lightbox is opened
            if (
                util.lightbox.getLightboxStatus() &&
                data &&
                data.entries &&
                data.entries.length &&
                closeBisLightbox
            ) {
                util.lightbox.closeLightbox();
            }

            var cartData = data || baseUtil.cartManager.getCartStoreData(),
                isDataFromServer = Boolean(cartData && cartData.payload),
                isAddedToCart = Boolean(
                    isDataFromServer && cartData.payload.productId
                ),
                totalCartItems =
                    (cartData && cartData.entries && cartData.entries.length) ||
                    0;
            // if (!isDataFromServer) {
            //     return;
            // }

            // console.log(
            //     'cartUpdateHandler',
            //     cartData,
            //     isAddedToCart,
            //     totalCartItems
            // );

            // update basic info
            // clear + add last 2 items
            // if isAddedToCart is true, create 1 item popup .. show it and then close it after 3 seconds
            // // add class vca-just-added - show confirm message + hide tax-info
            // else create basic popup with last 2 items .. which will be shown on hover
            // // remove class vca-just added - hide confirm message + show tax-info

            // clear content
            $list.empty();

            // create items from data
            var cartItems = [];
            if (totalCartItems > 2) {
                cartItems = cartData.entries
                    .slice(1)
                    .slice(-2)
                    .reverse();
            } else {
                // cartItems = cartData.entries.reverse();

                if (cartData && cartData.entries) {
                    cartItems = cartData.entries.slice().reverse();
                }
            }

            // create cart items
            $.each(cartItems, function(i) {
                baseUtil.jsTemplate.insertTemplate(
                    tmplObj.str['item'],
                    $list,
                    tmplObj.keys['item'],
                    cartItems[i]
                );
            });

            // update total item count
            $count.text(totalCartItems || '');
            $comp.attr('data-item-count', totalCartItems);

            // update shopping bag link
            updateSBLink(totalCartItems);

            if (cartData) {
                // update tax/price info
                $taxInfo
                    .find('dt')
                    .text($taxInfo.attr('data-tax-' + Boolean(cartData.tax)));
                $taxInfo.find('dd').text(cartData.totalFormattedPrice);

                // add vca-added, hide empty card from minicart
                if (isAddedToCart) {
                    util.throttle(function() {
                        $comp.addClass(CONST.CLASSES.added);
                        $noProductElem.addClass(CONST.CLASSES.hide);
                    }, 0)();
                }
            }
        }

        /**
         * Update shopping bag link
         * @function updateSBLink
         * @memberOf vca.comp.miniCart
         * @private
         * @param {HTMLElement} elem The component element
         * @returns {void}
         */
        function updateSBLink(totalCartItems) {
            const title0 = $sbLink.data('title0'),
                title1 = $sbLink.data('title1'),
                title2 = $sbLink.data('title2'),
                $added = $sbLink.find('.added'),
                $hover = $sbLink.find('.hover');

            let hoverText, addedText;

            addedText = hoverText = title0;

            if (totalCartItems <= 1) {
                // ok
                addedText = title0.replace('{0}', totalCartItems);
                hoverText = title0.replace('{0}', totalCartItems);
            } else if (totalCartItems == 2) {
                // ok
                addedText = title1.replace('{0}', totalCartItems - 1);
                hoverText = title0.replace('{0}', totalCartItems);
            } else if (totalCartItems == 3) {
                // ok
                addedText = title2.replace('{0}', totalCartItems - 1);
                hoverText = title1.replace('{0}', totalCartItems - 2);
            } else if (totalCartItems >= 4) {
                // ok
                addedText = title2.replace('{0}', totalCartItems - 1);
                hoverText = title2.replace('{0}', totalCartItems - 2);
            }

            $added.text(addedText);
            $hover.text(hoverText);
        }

        /**
         * Minicart close button handler
         * @function closeClickHandler
         * @memberOf vca.comp.miniCart
         * @private
         * @param {HTMLElement} elem The component element
         * @returns {void}
         */
        function closeClickHandler() {
            $comp
                .removeClass(CONST.CLASSES.added)
                .removeClass(CONST.CLASSES.active)
                .removeClass(CONST.CLASSES.interacted);
        }

        /**
         * Minicart click button handler
         * @function miniCartClickHandler
         * @memberOf vca.comp.miniCart
         * @private
         * @param {HTMLElement} event The click event object
         * @returns {void}
         */
        function miniCartClickHandler(event) {
            const isNavFooterCartLink = $(event.target).closest(
                CONST.SELECTORS.navigationFooter
            ).length
                ? true
                : false;
            if (util.matchmedia.narrow.matches && !isNavFooterCartLink) {
                event.preventDefault();
                $comp.addClass(CONST.CLASSES.active);
                $comp.addClass(CONST.CLASSES.interacted);
            }
        }

        /**
         * Cache variables being used.
         * @function cacheVars
         * @memberOf vca.comp.miniCart
         * @private
         * @param {HTMLElement} elem The component element
         * @returns {void}
         */
        function cacheVars(elem) {
            $comp = $(elem);
            $count = $comp.find(CONST.SELECTORS.count);
            $list = $comp.find(CONST.SELECTORS.list);
            $sbLink = $comp.find(CONST.SELECTORS.sbLink);
            $taxInfo = $comp.find(CONST.SELECTORS.taxInfo);
            $noProductElem = $comp.find(CONST.SELECTORS.noProductElem);
            $recentlyViewedElem = $comp.find(
                CONST.SELECTORS.recentlyViewedElem
            );
            $categoryElem = $comp.find(CONST.SELECTORS.categoryElem);
            $recentlyViewedTitle = $comp.find(
                CONST.SELECTORS.recentlyViewedTitle
            );
            $collectionCta = $comp.find(CONST.SELECTORS.collectionCta);
            var $itemTmpl = $comp.find(CONST.SELECTORS.itemTmpl);
            tmplObj = baseUtil.jsTemplate.getTemplateObj($itemTmpl, 'item');
            var $itemTmplRecentlyViewed = $comp.find(
                CONST.SELECTORS.itemTmplRecentlyViewed
            );
            tmplObjRecentlyViewed = baseUtil.jsTemplate.getTemplateObj(
                $itemTmplRecentlyViewed,
                'item'
            );
            var $itemTmplCollection = $comp.find(
                CONST.SELECTORS.itemTmplCollection
            );
            tmplObjCollection = baseUtil.jsTemplate.getTemplateObj(
                $itemTmplCollection,
                'item'
            );
        }

        /**
         * Bind events
         * @function bindEvents
         * @memberOf vca.comp.miniCart
         * @private
         * @returns {void}
         */
        function bindEvents() {
            // event subscribers
            listeners.push(
                $.subscribe(
                    baseUtil.customEvents.CART_UPDATED,
                    cartUpdateHandler
                )
            );
            // event subscribers
            listeners.push(
                $.subscribe(util.customEvents.RESIZED, resizeHandler)
            );

            // event handlers
            $comp.on(
                util.customEvents.INTERACTION,
                CONST.SELECTORS.close,
                closeClickHandler
            );

            $comp.on(
                util.customEvents.INTERACTION,
                CONST.SELECTORS.smLink,
                miniCartClickHandler
            );
        }

        /**
         * Unbinds all pre-existing events
         * @function teardown
         * @memberOf vca.comp.miniCart
         * @private
         * @returns {void}
         */
        function teardown() {
            while (listeners.length) {
                $.unsubscribe(listeners.pop());
            }

            // $comp.off(
            //     util.customEvents.INTERACTION,
            //     CONST.SELECTORS.infoToggleBtn,
            //     infoToggleBtnClickHandler
            // );
        }

        /**
         * Initialize the component
         * @function init
         * @memberOf vca.comp.miniCart
         * @private
         * @param {HTMLElement} elem The component element
         * @returns {void}
         */
        function init(elem) {
            cacheVars(elem);
            teardown();
            bindEvents();
            cartUpdateHandler();
            emptyMiniCart();
        }

        /**
         * Recently viewed products handler
         * @function displayRecentlyViewedProduct
         * @memberOf vca.comp.miniCart
         * @private
         * @returns {void}
         */
        function displayRecentlyViewedProduct(rvItems) {
            $.each(rvItems, function(i) {
                let $item = $('<div>');

                $item
                    .append(tmplObjRecentlyViewed.str['item'])
                    .find(CONST.SELECTORS.recentlyViewedLink)
                    .attr('href', '{{info.productPagePath}}');

                baseUtil.jsTemplate.insertTemplate(
                    $item,
                    $recentlyViewedElem,
                    tmplObjRecentlyViewed.keys['item'],
                    rvItems[i]
                );
            });

            // initialize ccProduct utility
            util.ccProduct.init($recentlyViewedElem);

            $recentlyViewedElem.removeClass(CONST.CLASSES.hide);
            $recentlyViewedTitle.removeClass(CONST.CLASSES.hide);

            // if product count more than 2 start carousel
            if (rvItems.length > 2) {
                enableRecentlyViewedCarousel();
            }
        }

        /**
         * Collection/Category Card handler
         * @function displayColectionCard
         * @memberOf vca.comp.miniCart
         * @private
         * @returns {void}
         */
        function displayColectionCard() {
            let familycard = $comp
                .find($categoryElem)
                .attr(CONST.ATTRIBUTES.familyCardType);
            let info = {
                familycard
            };
            let $item = $('<div>');

            if (familycard === CONST.CH_STORE.category) {
                $item
                    .append(tmplObjCollection.str['item'])
                    .find(CONST.SELECTORS.catergoryCard)
                    .removeClass(CONST.CLASSES.hide);
            } else if (familycard === CONST.CH_STORE.collection) {
                $item
                    .append(tmplObjCollection.str['item'])
                    .find(CONST.SELECTORS.collectionCard)
                    .removeClass(CONST.CLASSES.hide);
            } else {
                $item
                    .append(tmplObjCollection.str['item'])
                    .find(CONST.SELECTORS.catergoryCard)
                    .removeClass(CONST.CLASSES.hide);
            }

            baseUtil.jsTemplate.insertTemplate(
                $item,
                $categoryElem,
                tmplObjCollection.keys['item'],
                info
            );

            $categoryElem.removeClass(CONST.CLASSES.hide);
        }

        /**
         * empty minicart handler
         * @function emptyMiniCart
         * @memberOf vca.comp.miniCart
         * @private
         * @returns {void}
         */
        function emptyMiniCart() {
            $recentlyViewedElem.html('');
            $categoryElem.html('');
            const rvStore = ContextHub.getStore(CONST.CH_STORE.productType),
                rvItems = rvStore.recent(CONST.CH_STORE.productCount);

            //show recent viewed product
            if (rvItems.length > 0) {
                displayRecentlyViewedProduct(rvItems);

                //hide family link card if recent product available
                $collectionCta.addClass(CONST.CLASSES.hide);
            }

            //show category/collection if one or no recent view product available
            if (rvItems.length <= 1) {
                displayColectionCard();
            }

            //incase only one recentview product found show recentview + category/collection
            if (rvItems.length === 1) {
                $recentlyViewedElem.addClass(CONST.CLASSES.spl);
                $categoryElem.addClass(CONST.CLASSES.spl);
            }
        }

        /**
         * Resize handler
         * @function resizeHandler
         * @memberOf vca.comp.miniCart
         * @private
         * @returns {void}
         */
        function resizeHandler() {
            // enable related products & recently viewed carousels
            enableRecentlyViewedCarousel();
        }

        /**
         * Enable slick carousel for recently viewed products carousel
         * @function enableRecentlyViewedCarousel
         * @memberOf vca.comp.miniCart
         * @private
         * @param {HTMLElement} recentlyViewedElem The component element
         * @returns {void}
         */
        function enableRecentlyViewedCarousel() {
            const $carouselList = $recentlyViewedElem
                .not(CONST.SELECTORS.slickInitialized)
                .filter(function() {
                    return !$(this).hasClass(CONST.CLASSES.hide);
                });

            $.each($carouselList, function(i) {
                let $thisCarousel = $carouselList.eq(i),
                    carouselLength = $thisCarousel.attr(
                        CONST.ATTRIBUTES.dataItems
                    );

                if (carouselLength < CONST.CH_STORE.carouselMinLength) {
                    return;
                }

                if (util.dataStore.getLangCode === 'ar') {
                    CONST.PRODUCT_SLICK_SETTINGS = $.extend(
                        {},
                        CONST.PRODUCT_SLICK_SETTINGS,
                        CONST.SET_RTL
                    );
                }

                $thisCarousel.slick(CONST.PRODUCT_SLICK_SETTINGS);
            });
        }

        return {
            init: init
        };
    })(vca.$, vca.util, base.util);
})(window.vca, window.base);

/**
 * miniWishlist.js
 * functionality for the miniWishlist component
 */
(function(vca, base) {
    'use strict';

    var CONST = {
        SELECTORS: {
            comp: '.vca-sm-miniWishlist',
            close: '.vca-smm-close',
            count: '.vca-sm-count',
            smWishlist: '.vca-sm-wishlist'
        },
        CLASSES: {
            active: 'vca-sm-active',
            hide: 'vca-hide',
            added: 'vca-added'
        },
        DATA_ATTR: {
            countryCode: 'countryCode',
            languageCode: 'languageCode',
            pgtype: 'pgtype',
            pgtypemsn: 'pgtypemsn'
        },
        CLOSE_DURATION: 3 * 1000 // 3 seconds
    };

    /**
     * miniWishlist component
     * @namespace miniWishlist
     * @memberof vca.comp
     */
    vca.comp.miniWishlist = (function($, util, baseUtil) {
        var $comp = null,
            listeners = [],
            $count = null;
        //$smWishlist = null;

        /**
         * CMS-Base cart update handler
         * @function wlUpdateHandler
         * @memberOf vca.comp.miniWishlist
         * @private
         * @param {Array<JSON>} data The recieved data from the CMS-Base
         * @returns {void}
         */
        function wlUpdateHandler(data) {
            try {
                var wlData =
                        data || baseUtil.wishlistManager.getWishlistStoreData(),
                    totalItems = wlData
                        ? (wlData[0] &&
                              wlData[0].entries &&
                              wlData[0].entries.length) ||
                          0
                        : 0;

                // console.log(wlData[0].entries, $comp, CONST);

                // update total item count
                $count.text(totalItems || '');
                $count.toggleClass(CONST.CLASSES.hide, !totalItems);
                $comp.attr('data-item-count', totalItems);
            } catch (e) {
                console.warn('Wishlist Store Data is not available.');
            }
        }

        /**
         * wishlist Tracking
         * @function wishlistTracking
         * @memberOf vca.comp.miniWishlist
         * @private
         * @param {HTMLElement} elem The component element
         * @returns {void}
         */
        // Removed this function beacuse wishlist popin is not yet developed. We will revert it back when we will have   wishlist popin functionality
        // function wishlistTracking() {
        //     let trackingEventObj = {},
        //         countryCode = $(this).data(CONST.DATA_ATTR.countryCode),
        //         languageCode = $(this).data(CONST.DATA_ATTR.languageCode),
        //         pgtype = $(this).data(CONST.DATA_ATTR.pgtype),
        //         pagePath,
        //         cheetahid = vca.util.queryString.get('chid');

        //     pagePath =
        //         '/' + countryCode + '/' + languageCode + '/wishlist/pop-in';

        //     // Analytics for wishlist
        //     trackingEventObj = {
        //         event: 'virtualPageview',
        //         page: pagePath,
        //         pgtype: pgtype,
        //         pgtypemsn: 'wishlist',
        //         pgcountry: countryCode,
        //         pglanguage: languageCode
        //     };

        //     if (cheetahid != undefined) {
        //         Object.assign(trackingEventObj, {
        //             cheetahid: cheetahid
        //         });
        //     }

        //     baseUtil.analytics.pushDataToDataLayer(trackingEventObj);
        // }

        /**
         * Cache variables being used.
         * @function cacheVars
         * @memberOf vca.comp.miniWishlist
         * @private
         * @param {HTMLElement} elem The component element
         * @returns {void}
         */
        function cacheVars(elem) {
            $comp = $(elem);
            $count = $(CONST.SELECTORS.smWishlist).find(CONST.SELECTORS.count);
            //$smWishlist = $(CONST.SELECTORS.smWishlist);
            // $list = $comp.find(CONST.SELECTORS.list);
            // $sbLink = $comp.find(CONST.SELECTORS.sbLink);
            // $taxInfo = $comp.find(CONST.SELECTORS.taxInfo);

            // var $itemTmpl = $comp.find(CONST.SELECTORS.itemTmpl);
            // tmplObj = baseUtil.jsTemplate.getTemplateObj($itemTmpl, 'item');
        }

        /**
         * Bind events
         * @function bindEvents
         * @memberOf vca.comp.miniWishlist
         * @private
         * @returns {void}
         */
        function bindEvents() {
            // event subscribers
            listeners.push(
                $.subscribe(
                    baseUtil.customEvents.WISHLIST_UPDATED,
                    wlUpdateHandler
                )
            );
            //$smWishlist.on(util.customEvents.INTERACTION, wishlistTracking);
            // event handlers
            // $comp.on(
            //     util.customEvents.INTERACTION,
            //     CONST.SELECTORS.close,
            //     closeClickHandler
            // );
        }

        /**
         * Unbinds all pre-existing events
         * @function teardown
         * @memberOf vca.comp.miniWishlist
         * @private
         * @returns {void}
         */
        function teardown() {
            while (listeners.length) {
                $.unsubscribe(listeners.pop());
            }

            // $comp.off(
            //     util.customEvents.INTERACTION,
            //     CONST.SELECTORS.infoToggleBtn,
            //     infoToggleBtnClickHandler
            // );
        }

        /**
         * Initialize the component
         * @function init
         * @memberOf vca.comp.miniWishlist
         * @private
         * @param {HTMLElement} elem The component element
         * @returns {void}
         */
        function init(elem) {
            cacheVars(elem);
            teardown();
            bindEvents();

            wlUpdateHandler();
        }

        return {
            init: init
        };
    })(vca.$, vca.util, base.util);
})(window.vca, window.base);

/**
 * profile.js
 * functionality for the profile component
 */
(function(vca, base) {
    'use strict';

    const CONST = {
        SELECTORS: {
            comp: '.vca-sm-profile',
            profileLink: '.vca-sm-link',
            loggedProfileLink: '.vca-logged',
            lightboxProfileLink: '.vca-lightbox-trigger',
            lightboxPhoneLogin: '.vca-phonelogin',
            passwordRecoveryEp: '.vca-pr-ep',
            cnPrSuccess: '.vca-cn-pr-success',
            signupConfirmation: '.vca-signup-confirmation',
            keyText: '.base-i18n-text',
            vcaLoggedOut: '.vca-logged-out',
            vcaResetPass: '.reset-password-phone',
            vcaBody: '.vca-body'
        },
        CLASSES: {
            active: 'vca-sm-active',
            hide: 'vca-hide',
            cnPrSuccess: 'vca-cn-pr-success',
            added: 'vca-added',
            prIntroText: 'vca-pr-introtext',
            logged: 'vca-logged',
            resetpasswordi18: 'reset-password-phone-i18'
        },
        CONFIRM_KEY: 'confirmation-success'
    };
    let _count = 0;

    /**
     * profile component
     * @namespace profile
     * @memberof vca.comp
     */
    vca.comp.profile = (function($, util, baseUtil) {
        let $body = $('body'),
            $comp = null,
            listeners = [],
            prUser = null,
            prIntroText = null,
            confirmVal = null,
            confirmValFlag = false,
            $profileLink = null,
            $cnPrSuccess = null,
            $loginProfileLink = null,
            $loggedProfileLink = null,
            $passwordRecoveryEle = null,
            $i18Ele = null;

        /**
         * Start basics
         * @function cacheVars
         * @memberOf vca.comp.profile
         * @private
         * @returns {void}
         */
        function start() {
            passwordRecovery();

            // prevent multiple executions
            if (_count !== 1) {
                return;
            }

            // check for the confirmation query param
            confirmVal = util.queryString.get(CONST.CONFIRM_KEY);
            confirmValFlag = confirmVal === 'false' ? false : true;

            // open overlay by triggering the clik if success is found
            if (confirmVal && confirmValFlag) {
                triggerProfileLink();

                // Subscribe to show signup confirmation message if confirmVal is true (string)
                if (confirmVal === 'true') {
                    $.subscribe(
                        util.customEvents.LB_OPENED,
                        showSignupConfirmation
                    );
                }
            }
        }

        /**
         * Trigger Profile Link
         * @function triggerProfileLink
         * @memberOf vca.comp.profile
         * @private
         * @returns {void}
         */
        function triggerProfileLink() {
            $profileLink.trigger(util.customEvents.INTERACTION);
        }

        /**
         * Show signup confirmation message
         * @function showSignupConfirmation
         * @memberOf vca.comp.profile
         * @private
         * @returns {void}
         */
        function showSignupConfirmation() {
            if (confirmValFlag) {
                $body
                    .find(CONST.SELECTORS.signupConfirmation)
                    .removeClass(CONST.CLASSES.hide);
                confirmValFlag = false;
            }
        }

        /**
         * Update logged URL
         * @function updateUrl
         * @memberOf vca.comp.profile
         * @private
         * @returns {void}
         */
        function updateUrl(data) {
            // get profile data
            var profileData = data || util.dataStore.getProfileStoreData();
            $loginProfileLink = $body
                .find(CONST.SELECTORS.comp)
                .find(CONST.SELECTORS.lightboxProfileLink);
            $loggedProfileLink = $body.find(CONST.SELECTORS.loggedProfileLink);
            if (profileData && profileData.logInStatus == true) {
                $loginProfileLink.addClass(CONST.CLASSES.hide);
                $loggedProfileLink.removeClass(CONST.CLASSES.hide);
                $loginProfileLink.find(CONST.SELECTORS.vcaLoggedOut).addClass(CONST.CLASSES.hide);
            } else {
                $loginProfileLink.removeClass(CONST.CLASSES.hide);
                $loggedProfileLink.addClass(CONST.CLASSES.hide);
                $loginProfileLink.find(CONST.SELECTORS.vcaLoggedOut).removeClass(CONST.CLASSES.hide);
            }
        }

        /**
         * Cache variables being used.
         * @function cacheVars
         * @memberOf vca.comp.profile
         * @private
         * @param {HTMLElement} elem The component element
         * @returns {void}
         */
        function cacheVars(elem) {
            $comp = $(elem);
            $profileLink = $comp.find(CONST.SELECTORS.profileLink);
            $passwordRecoveryEle = $body
                .find(CONST.SELECTORS.passwordRecoveryEp)
                .find(CONST.SELECTORS.keyText);
            $cnPrSuccess = $body.find(CONST.SELECTORS.cnPrSuccess);
        }

        /**
         * Initilize base phoneLogin component
         * @function initPhoneLogin
         * @memberOf vca.comp.profile
         * @private
         * @returns {void}
         */
        function initPhoneLogin() {
            // Check for china only
            if (
                'cn' ===
                    String(
                        util.dataStore.getDefaultCountryCode
                    ).toLowerCase() &&
                base.comp.phoneLogin &&
                $body.find(CONST.SELECTORS.lightboxPhoneLogin).length
            ) {
                base.comp.phoneLogin.init();
                base.comp.phoneLogin.reset();
            }
        }

        /**
         * Reset the state of base phoneLogin component
         * @function resetPhoneLogin
         * @memberOf vca.comp.profile
         * @private
         * @returns {void}
         */
        function resetPhoneLogin() {
            // Check for china only
            if (
                'cn' ===
                    String(
                        util.dataStore.getDefaultCountryCode
                    ).toLowerCase() &&
                base.comp.phoneLogin &&
                !$body.find(CONST.SELECTORS.lightboxPhoneLogin).length
            ) {
                base.comp.phoneLogin.resetState();
            }
        }

        function passwordRecovery() {
            // User name update in thank you msg content update along with scroll
            const urlPara = util.queryString.get();
            if (
                $passwordRecoveryEle.length &&
                urlPara &&
                urlPara['resetpassword']
            ) {
                try {
                    prUser = urlPara['email'] || urlPara['phone'];
                } catch (e) {
                    prUser = '';
                }

                prIntroText = $passwordRecoveryEle.text();
                prIntroText = prIntroText.replace('{0}', prUser);
                $passwordRecoveryEle
                    .addClass(CONST.CLASSES.prIntroText)
                    .text(prIntroText);
            }
        }

        /**
         * Hover event handler
         * @function formSuccessHandler
         * @memberOf vca.comp.myaccountWrapper
         * @private
         * @param {HTMLFormElement} _form The submitted form
         * @param {Boolean|JSON} data The form submit response
         * @returns {void}
         */
        function formSuccessHandler(_form, data) {
            if (_form && data && $cnPrSuccess.length) {
                $.each($cnPrSuccess, function() {
                    $(this).removeClass(CONST.CLASSES.cnPrSuccess);
                });

                // if form success hide Introductory text
                if ($i18Ele) {
                    $i18Ele.addClass(CONST.CLASSES.hide);
                }
            }
        }

        /**
         * Method to show phone number with introductory text on reset password phone
         * @function updatePhoneNumber
         * @memberOf vca.comp.myaccountWrapper
         * @private
         * @returns {void}
         */
        function updatePhoneNumber() {
            $i18Ele = $comp.closest(CONST.SELECTORS.vcaBody)
                .find(CONST.SELECTORS.vcaResetPass)
                .siblings()
                .find(CONST.SELECTORS.keyText);
            let mobilePhone = util.queryString.get('mobilePhone');
            let str = $i18Ele.text();
            $i18Ele.addClass(CONST.CLASSES.resetpasswordi18);

            if ($i18Ele && str.includes('{0}') && mobilePhone) {
                let decodedStr = util.base64Str.decodeBase64(mobilePhone);
                $i18Ele.text(str.replace(/\{0}/g, decodedStr));
            }
        }

        /**
         * Bind events
         * @function bindEvents
         * @memberOf vca.comp.profile
         * @private
         * @returns {void}
         */
        function bindEvents() {
            // event subscribers
            listeners.push(
                $.subscribe(util.customEvents.LB_OPENED, initPhoneLogin)
            );
            listeners.push(
                $.subscribe(util.customEvents.LB_CLOSED, resetPhoneLogin)
            );
            listeners.push(
                $.subscribe(baseUtil.customEvents.PROFILE_UPDATED, updateUrl)
            );

            listeners.push(
                $.subscribe(
                    baseUtil.customEvents.FORMS_SUCCESS,
                    formSuccessHandler
                )
            );
        }

        /**
         * Unbinds all pre-existing events
         * @function teardown
         * @memberOf vca.comp.profile
         * @private
         * @returns {void}
         */
        function teardown() {
            while (listeners.length) {
                $.unsubscribe(listeners.pop());
            }

            // $comp.off(
            //     util.customEvents.INTERACTION,
            //     CONST.SELECTORS.infoToggleBtn,
            //     infoToggleBtnClickHandler
            // );
        }

        /**
         * Initialize the component
         * @function init
         * @memberOf vca.comp.profile
         * @private
         * @param {HTMLElement} elem The component element
         * @returns {void}
         */
        function init(elem) {
            // increment counter
            _count++;

            cacheVars(elem);
            teardown();
            bindEvents();
            updatePhoneNumber();

            start();
            updateUrl();
        }

        return {
            init: init,
            triggerProfileLink: triggerProfileLink
        };
    })(vca.$, vca.util, base.util);
})(window.vca, window.base);

/**
 * navigation.js
 * functionality for the navigation component
 */
(function(vca, base) {
    'use strict';

    const CONST = {
        SELECTORS: {
            navBurger: '.vca-navigation-burger',
            navLink: '.vca-navigation-main-link',
            navTabContainer: '.vca-navigation-tabs',
            sliderOverlay: '.vca-slider-overlay',
            tabBtn: '.vca-tabs-button',
            subnavAnchor: '.vca-navigation-anchor[data-type="subnav"]',
            sliderCol: '.vca-slider-column',
            sliderHeader: '.vca-slider-header',
            burgerClose: '.vca-navigation-burger-close',
            menuCardLink: '.vca-menu-card-link',
            menuTabsPanel: '.vca-slider-inner .vca-tabs-panel',
            navAnchorLink:
                'a.vca-menu-card-link, .vca-navigation-main-button, .vca-navigation-anchor',
            concierge: '.vca-emaillogin .vca-concierge-details.vca-pdp-contact'
        },
        CLASSES: {
            hide: 'vca-hide',
            active: 'vca-active',
            show: 'vca-show-section'
        },
        DATA: {
            ANCHOR_TYPE: {
                subNav: 'subnav',
                link: 'link'
            }
        }
    };

    /**
     * navigation component
     * @namespace navigation
     * @memberof vca.comp
     */
    vca.comp.navigation = (function($, util, baseUtil) {
        let listeners = [],
            $comp = null,
            $navTabContainer = null,
            $body = $('body'),
            isTabClicked = false,
            $menuCardLink = null,
            $navAnchorLink = null,
            $concierge = null,
            $menuTabsPanel;

        /**
         * Navigation/Burger click handler
         * @function openTab
         * @memberOf vca.comp.navigation
         * @private
         * @returns {void}
         */
        function openTab(e) {
            e.preventDefault();

            let $thisElem = $(e.currentTarget || e.target),
                activeTab = $thisElem.data('activeTab'),
                $activeTab = $comp
                    .find(CONST.SELECTORS.tabBtn)
                    .filter(function(_i, tabBtn) {
                        return $(tabBtn).attr('id') === activeTab;
                    });

            util.slider.openSlider(function() {
                // open tab container
                $navTabContainer.addClass(CONST.CLASSES.active);
                // look for active tab - authored | first - user interacted
                $activeTab.trigger(util.customEvents.INTERACTION);

                $.publish(util.customEvents.NAV_OPENED);
            });
        }

        /**
         * Navigation/Burger click handler
         * @function closeTab
         * @memberOf vca.comp.navigation
         * @private
         * @returns {void}
         */
        function closeTab() {
            util.slider.closeSlider(function() {
                // close any opened child

                $comp
                    .find(CONST.SELECTORS.sliderCol)
                    .removeClass(CONST.CLASSES.active);

                // close tab container
                $navTabContainer.removeClass(CONST.CLASSES.active);
                $menuTabsPanel.removeClass(CONST.CLASSES.show);
                $menuTabsPanel.removeClass(CONST.CLASSES.hide);
                $.publish(util.customEvents.NAV_CLOSED);
            });
            isTabClicked = false;
        }

        /**
         * Navigation slider toggling based on same tab click handler
         * @function navTabClickedHandler
         * @memberOf vca.comp.navigation
         * @private
         * @returns {void}
         */
        function navTabClickedHandler(element) {
            if (!isTabClicked) {
                isTabClicked = true;
                return;
            }

            if (
                element.currentTab.attr('id') === element.previousTab.attr('id')
            ) {
                closeTab();
            }
        }

        /**
         * Navigation submenu anchor click handler
         * @function subnavAnchorHandler
         * @memberOf vca.comp.navigation
         * @private
         * @param {Event} e The event
         * @returns {void}
         */
        function subnavAnchorHandler(e) {
            e.preventDefault();

            let $thisElem = $(e.currentTarget || e.target),
                anchorType = $thisElem.data('type'),
                $sliderCol = $thisElem.siblings(CONST.SELECTORS.sliderCol),
                $sliderButton = $sliderCol
                    .children(CONST.SELECTORS.sliderHeader)
                    .find('button');

            if (anchorType === CONST.DATA.ANCHOR_TYPE.subNav) {
                $sliderCol.addClass(CONST.CLASSES.active);

                // added timeout to sync with css slider animation timing
                setTimeout(function() {
                    $sliderButton.focus();
                }, 100);
            } else {
                return true;
            }
        }

        /**
         * Menu Tracking event
         * @function menuTracking
         * @memberOf vca.comp.navigation
         * @private
         * @param {Event}
         * @returns {void}
         */
        function menuTracking() {
            let trackingEventObj = {},
                firstLevel = $(this).data('first') || 'N/A',
                secondLevel = $(this).data('second') || 'N/A',
                thirdLevel = $(this).data('third') || 'N/A',
                fourthLevel = $(this).data('fourth') || 'N/A';

            // Analytics for mega menus
            trackingEventObj = {
                event: 'menu'
            };
            if (firstLevel) {
                $menuCardLink.attr('data-first', firstLevel);
                Object.assign(trackingEventObj, {
                    first_level: firstLevel
                });
            }
            if (secondLevel) {
                $menuCardLink.attr('data-second', secondLevel);
                Object.assign(trackingEventObj, {
                    second_level: secondLevel
                });
            }
            if (thirdLevel) {
                $menuCardLink.attr('data-third', thirdLevel);
                Object.assign(trackingEventObj, {
                    third_level: thirdLevel
                });
            }
            if (fourthLevel) {
                Object.assign(trackingEventObj, {
                    fourth_level: fourthLevel
                });
            }
            baseUtil.analytics.pushDataToDataLayer(trackingEventObj);
        }

        /**
         * Handle the analytics on click
         * @function initCrcPhoneClick
         * @memberOf vca.comp.navigation
         * @private
         * @returns {void}
         */
        function initCrcPhoneClick() {
            $concierge = $body.find(CONST.SELECTORS.concierge);

            // Handle Concierge analytics while on login/my account popin page.
            if ($concierge) {
                $concierge.on(util.customEvents.INTERACTION, function() {
                    vca.util.crcDataTracking.handleCrcPhoneClick('content');
                });
            }
        }

        /**
         * Bind events
         * @function bindEvents
         * @memberOf vca.comp.navigation
         * @private
         * @returns {void}
         */
        function bindEvents() {
            // event handlers
            $comp.on(
                util.customEvents.INTERACTION,
                CONST.SELECTORS.navLink,
                openTab
            );

            $comp.on(
                util.customEvents.INTERACTION,
                CONST.SELECTORS.navBurger,
                openTab
            );

            $comp.on(
                util.customEvents.INTERACTION,
                CONST.SELECTORS.subnavAnchor,
                subnavAnchorHandler
            );

            $body.on(
                util.customEvents.INTERACTION,
                CONST.SELECTORS.sliderOverlay,
                closeTab
            );

            $comp.on(
                util.customEvents.INTERACTION,
                CONST.SELECTORS.burgerClose,
                closeTab
            );

            $navAnchorLink.on(util.customEvents.INTERACTION, menuTracking);

            listeners.push(
                $.subscribe(util.customEvents.TAB_CLICKED, navTabClickedHandler)
            );

            listeners.push(
                $.subscribe(util.customEvents.LB_OPENED, function() {
                    initCrcPhoneClick();
                })
            );
        }

        /**
         * Unbinds all pre-existing events
         * @function teardown
         * @memberOf vca.comp.navigation
         * @private
         * @returns {void}
         */
        function teardown() {
            while (listeners.length) {
                $.unsubscribe(listeners.pop());
            }

            $comp.off(
                util.customEvents.INTERACTION,
                CONST.SELECTORS.navLink,
                openTab
            );

            $comp.off(
                util.customEvents.INTERACTION,
                CONST.SELECTORS.navBurger,
                openTab
            );

            $comp.off(
                util.customEvents.INTERACTION,
                CONST.SELECTORS.subnavAnchor,
                subnavAnchorHandler
            );

            $body.off(
                util.customEvents.INTERACTION,
                CONST.SELECTORS.sliderOverlay,
                closeTab
            );

            $comp.off(
                util.customEvents.INTERACTION,
                CONST.SELECTORS.burgerClose,
                burgerCloseHandler
            );
        }

        /**
         * Updates variables being used.
         * @function cacheVars
         * @memberOf vca.comp.navigation
         * @private
         * @param {HTMLElement} elem The component element
         * @returns {void}
         */
        function cacheVars(elem) {
            $comp = $(elem);
            $navTabContainer = $comp.find(CONST.SELECTORS.navTabContainer);
            $navAnchorLink = $comp.find(CONST.SELECTORS.navAnchorLink);
            $menuCardLink = $(CONST.SELECTORS.menuCardLink);
            $menuTabsPanel = $(CONST.SELECTORS.menuTabsPanel);
        }

        /**
         * Initialize the component
         * @function init
         * @memberOf vca.comp.navigation
         * @private
         * @param {HTMLElement} elem The component element
         * @returns {void}
         */
        function init(elem) {
            cacheVars(elem);
            bindEvents();
        }

        return {
            init: init,
            teardown: teardown
        };
    })(vca.$, vca.util, base.util);
})(window.vca, window.base);

/**
 * logo.js
 * functionality for the logo component
 */
(function(vca) {
    'use strict';

    var CONST = {
        SELECTORS: {
            logoLink: '.vca-logo-link'
        }
    };

    /**
     * logo component
     * @namespace logo
     * @memberof vca.comp
     */
    vca.comp.logo = (function($, util) {
        var $comp = null,
            listeners = [],
            $logoLink = null,
            isHomePage = null;

        /**
         * Logo click event handler
         * @function logoClickHandler
         * @memberOf vca.comp.logo
         * @private
         * @param {Event} e The click event
         * @returns {void}
         */
        function logoClickHandler(e) {
            if (isHomePage) {
                // if home page, scroll up
                e.preventDefault();
                util.scrollTo.position(0, 100);
            } else {
                // else, proceed with redirection
                return true;
            }
        }

        /**
         * Cache variables being used.
         * @function cacheVars
         * @memberOf vca.comp.logo
         * @private
         * @param {HTMLElement} elem The component element
         * @returns {void}
         */
        function cacheVars(elem) {
            $comp = $(elem);
            $logoLink = $comp.find(CONST.SELECTORS.logoLink);
            isHomePage = $logoLink.data('isHomePage');
        }

        /**
         * Bind events
         * @function bindEvents
         * @memberOf vca.comp.logo
         * @private
         * @returns {void}
         */
        function bindEvents() {
            // event handlers
            $comp.on(util.customEvents.INTERACTION, logoClickHandler);
        }

        /**
         * Unbinds all pre-existing events
         * @function teardown
         * @memberOf vca.comp.logo
         * @private
         * @returns {void}
         */
        function teardown() {
            while (listeners.length) {
                $.unsubscribe(listeners.pop());
            }

            $comp.off(util.customEvents.INTERACTION, logoClickHandler);
        }

        /**
         * Initialize the component
         * @function init
         * @memberOf vca.comp.logo
         * @private
         * @param {HTMLElement} elem The component element
         * @returns {void}
         */
        function init(elem) {
            cacheVars(elem);
            bindEvents();
        }

        return {
            init: init,
            teardown: teardown
        };
    })(vca.$, vca.util);
})(window.vca);

/**
 * Abbreviations:
 * cls - Country Language Selector
 */

/**
 * cls.js
 * functionality for the cls component
 */
(function(vca, base) {
    'use strict';

    var CONST = {
        SELECTORS: {
            comp: '.vca-cls',
            summaryLabel: '.vca-cls-summary',
            saveBtn: '.vca-cls-save-btn',
            optionLink: '.vca-cls-ddl-link',
            csBtn: '.vca-custom-select-button',
            navComp: '.vca-navigation',
            ddlMain: '.vca-custom-select-main',
            mplightbox: '.vca-mplightbox',
            marketPopin: '.vca-market-popin',
            clsCountry: '.vca-cls-country',
            clsLanguage: '.vca-cls-language'
        },
        CLASSES: {
            hide: 'vca-hide'
        },
        COOKIE: {
            clsUrl: 'vcaClsUrl',
            clsData: 'vcaClsData',
            cookieMaxAge: 30,
            cookiePathDTC: '/',
            cookiePathPDG: '/'
        },
        DATA_ATTR: {
            countryName: 'countryName'
        }
    };

    /**
     * cls component
     * @namespace cls
     * @memberof vca.comp
     */
    vca.comp.cls = (function($, util, baseUtil) {
        var $comp = null,
            listeners = [],
            $summaryLabel = null,
            $navComp = null,
            $ddlMain = null,
            $marketPopin = null,
            isCountryCN = util.dataStore.isChina();

        /**
         * Save button click handler
         * @function saveBtnClickHandler
         * @memberOf vca.comp.cls
         * @private
         * @returns {void}
         */
        function saveBtnClickHandler(e) {
            var $thisElem = $(e.currentTarget || e.target),
                $comp = $thisElem.closest(CONST.SELECTORS.comp),
                data = $comp
                    .find(CONST.SELECTORS.csBtn)
                    .filter(function() {
                        return this.dataset.type === 'language';
                    })
                    .find(CONST.SELECTORS.optionLink)
                    .data(),
                data = dataTransformation(data);

            // for clsUrl
            setCookieDtcPdg(CONST.COOKIE.clsUrl, data.cookieLink);

            // for clsData
            setCookieDtcPdg(CONST.COOKIE.clsData, JSON.stringify(data));
            updateAnalyticsTrackingInfo($comp);
            redirectURLHandler($comp, data);
        }

        /**
         * Data Transformation for data object
         * @function dataTransformation
         * @memberOf vca.comp.cls
         * @private
         * @param {string} data The data Object
         * @returns {void}
         */
        function dataTransformation(data) {
            // for ppc is enabled for MY/TH
            if (data.ppcEnable) {
                data.link = data.link + '?priceCountry=' + data.countryCode;
            }
            // for defaulty priceCountry for WW_EN
            if (data.countryCode == 'EN') {
                data.link = data.link + '?priceCountry=US';
            }
            // Updating the currencySymbol for Thailand
            if (data.currencyCode === 'THB') {
                data.currencySymbol = '&#3647';
            }
            return data;
        }

        /**
         * Update Analytics Tracking Information
         * @function updateAnalyticsTrackingInfo
         * @memberOf vca.comp.cls
         * @private
         * @param {string} $comp closest .vca-cls selector
         * @returns {void}
         */
        function updateAnalyticsTrackingInfo($comp) {
            let popinCountry = $comp
                    .find(CONST.SELECTORS.clsCountry)
                    .find(CONST.SELECTORS.optionLink)
                    .data('country-name'),
                popinLanguage = $comp
                    .find(CONST.SELECTORS.clsLanguage)
                    .find(CONST.SELECTORS.optionLink)
                    .data('language-name'),
                trackingEventObj = {
                    event: 'marketSelection',
                    country: popinCountry,
                    language: popinLanguage
                };

            baseUtil.analytics.pushDataToDataLayer(trackingEventObj);
            
            //Analytics sensors data changeCountryPopin event
            if (isCountryCN) {
                const countryName = $comp.data(CONST.DATA_ATTR.countryName);
                baseUtil.analytics.pushToSensorsData('ChangeCountryPopin', {
                    nextlocation: popinCountry,
                    previouslocation: countryName,
                });
            }
        }

        /**
         * Redirect to selected locale
         * @function redirectURLHandler
         * @memberOf vca.comp.cls
         * @private
         * @param {string} $comp closest .vca-cls selector
         * @param {string} data The data Objec
         * @returns {void}
         */
        function redirectURLHandler($comp, data) {
            // redirect to the requested url
            if ($comp.closest(CONST.SELECTORS.mplightbox).length) {
                window.location.href = data.cookieLink;
            } else {
                window.location.href = data.link;
            }
        }

        /**
         * Sets cookie for DTC & PDG domains
         * @function setCookieDtcPdg
         * @memberOf vca.comp.cls
         * @private
         * @param {string} cookieName The cookie name
         * @param {string} cookieValue The cookie value
         * @returns {void}
         */
        function setCookieDtcPdg(cookieName, cookieValue) {
            // for DTC domain
            util.cookieManager.setCookie(
                cookieName,
                cookieValue,
                CONST.COOKIE.cookieMaxAge,
                CONST.COOKIE.cookiePathDTC
            );

            // // TODO: for PDG domain
            // util.cookieManager.setCookie(
            //     cookieName,
            //     cookieValue,
            //     CONST.COOKIE.cookieMaxAge,
            //     CONST.COOKIE.cookiePathPDG
            // );
        }

        /**
         * Handler for country dropdown change
         * @function customSelectUpdateHandler
         * @memberOf vca.comp.cls
         * @private
         * @param {json} subData The object containing subscribed data
         * @returns {void}
         */
        function customSelectUpdateHandler(subData) {
            // process only if country ddl is selected
            if (subData.dataset.type === 'language') {
                return;
            }

            updateCustomSelects(subData.dataset.value, subData);
        }

        /**
         * Method to update/set dropdowns
         * @function updateCustomSelects
         * @memberOf vca.comp.cls
         * @private
         * @param {string} selectedCountry The country dropdown value
         * @returns {void}
         */
        function updateCustomSelects(selectedCountry) {
            if (!$ddlMain.length) {
                $ddlMain = $marketPopin.find(CONST.SELECTORS.ddlMain);
            }
            $.each($ddlMain, function(_i, el) {
                var $main = $(el),
                    customSelectInst = $main.data('customSelectInst');
                if (customSelectInst) {
                    // set country for all country dropdowns
                    if (customSelectInst.type === 'country') {
                        customSelectInst.setOption(selectedCountry);
                    }

                    // enable languages for only this country
                    if (customSelectInst.type === 'language') {
                        // set default text in dropdown
                        customSelectInst.$csButton.text(
                            customSelectInst.$csButton.data('defaultText')
                        );

                        // hiding all options
                        customSelectInst.$csLi.addClass(CONST.CLASSES.hide);

                        var $langLis = customSelectInst.$csLi.filter(
                            function() {
                                var thisCountry = this.dataset.value.split(
                                        '-'
                                    )[0],
                                    selectedCountryVal = selectedCountry.split(
                                        '-'
                                    )[0];

                                return thisCountry === selectedCountryVal;
                            }
                        );

                        // showing relevant options
                        $langLis.removeClass(CONST.CLASSES.hide);
                    }
                }
            });
        }

        /**
         * Method to update desired values for cls
         * @function start
         * @memberOf vca.comp.cls
         * @private
         * @param {HTMLElement} elem The component element
         * @returns {void}
         */
        function start() {
            const cookieVal = util.cookieManager.getCookie(
                CONST.COOKIE.clsData
            );

            // if cookies found - use them, else fallback to default country/language settings from LangLevelConfig
            let data, summaryText;

            try {
                data = JSON.parse(cookieVal) || $comp[0].dataset;
            } catch (e) {
                data = $comp[0].dataset;
            }
            if (data.currencyCode === 'THB') {
                data.currencySymbol = '';
            }
            // create label text
            summaryText = [
                data.countryName,
                '(' + data.currencyCode,
                data.currencySymbol + ')',
                '-',
                data.languageCode
            ]
                .filter(Boolean)
                .join(' ');

            // update label on level 1 navigation
            $summaryLabel.text(summaryText);

            // TODO: refactor this to do it in a better way (1 instead of 2 loops)
            updateCustomSelects(data.countryCode + '-');

            // update country & language
            $.each($ddlMain, function(i) {
                var $main = $ddlMain.eq(i),
                    customSelectInst = $main.data('customSelectInst'),
                    valueToUpdate = null;

                if (Boolean(customSelectInst)) {
                    // set country
                    if (customSelectInst.type === 'country') {
                        valueToUpdate = data.countryCode + '-';
                    }

                    // set language
                    if (customSelectInst.type === 'language') {
                        valueToUpdate =
                            data.countryCode + '-' + data.languageCode;
                    }

                    // set custom dropdown option
                    customSelectInst.setOption(valueToUpdate);
                }
            });
        }

        /**
         * Updates variables being used.
         * @function cacheVars
         * @memberOf vca.comp.cls
         * @private
         * @param {HTMLElement} elem The component element
         * @returns {void}
         */
        function cacheVars(elem) {
            $comp = $(elem);
            $summaryLabel = $comp.find(CONST.SELECTORS.summaryLabel);
            $navComp = $comp.closest(CONST.SELECTORS.navComp);
            $ddlMain = $navComp.find(CONST.SELECTORS.ddlMain);
            $marketPopin = $comp.closest(CONST.SELECTORS.marketPopin);
        }

        /**
         * Bind events
         * @function bindEvents
         * @memberOf vca.comp.cls
         * @private
         * @returns {void}
         */
        function bindEvents() {
            // event subscribers
            listeners.push(
                $.subscribe(
                    util.customEvents.CS_SELECTED,
                    customSelectUpdateHandler
                )
            );

            // event handlers
            $comp.on(
                util.customEvents.INTERACTION,
                CONST.SELECTORS.saveBtn,
                saveBtnClickHandler
            );
        }

        /**
         * Unbinds all pre-existing events
         * @function teardown
         * @memberOf vca.comp.cls
         * @private
         * @returns {void}
         */
        function teardown() {
            while (listeners.length) {
                $.unsubscribe(listeners.pop());
            }

            $comp.off(
                util.customEvents.INTERACTION,
                CONST.SELECTORS.saveBtn,
                saveBtnClickHandler
            );
        }

        /**
         * Initialize the component
         * @function init
         * @memberOf vca.comp.cls
         * @private
         * @param {HTMLElement} elem The component element
         * @returns {void}
         */
        function init(elem) {
            cacheVars(elem);
            teardown();
            bindEvents();

            // start the CLS functionality
            start();
        }

        return {
            init: init
        };
    })(vca.$, vca.util, base.util);
})(window.vca, window.base);

/**
 * header.js
 * functionality for the header component
 */
(function(w, vca) {
    'use strict';
    const CONST = {
        SELECTORS: {
            comp: '.vca-header',
            baseMain: '.base-main, .vca-main',
            firstMajorCover: '.vca-major-feature-cover',
            notificationBar: '.vca-nb',
            item: '.vca-sm-item',
            pdpSticky: '.vca-pdp-shopping-sticky',
            signINLi: '.vca-sm-profile',
            signINLink: '.vca-lightbox-trigger',
            nbMessage: '.vca-nb-notification-link',
            nbMessageAnchor: '.vca-nb-notification-link a',
            desclaimerMessage: '.desclaimer-slider > div',
            currentDesclaimnerMessage: '.desclaimer-slider .vca-show',
            notificationCloseBtn: '.vca-nb-btn',
            stickyCategoryBar: '.vca-srl-sticky-categories',
            pictoCategoryBar: '.base-search-category-result-list',
            skiptoContent: '.vca-skip-content',
            vcaMain: '.vca-main',
            focusableElements:
                'a, input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled])',
            notificationBarContainer: '.vca-notification-bar-container',
            firstMajorShowFoldContent:
                '.vca-feature-cover-content-text .vca-feature-cover-content-wrapper',
            firstMajorCoverContent: '.vca-feature-cover-content-text',
            firstMajorCoverTitle:
                '.vca-feature-cover-content-text .vca-feature-cover-title'
        },
        CLASSES: {
            transitionHeader: 'vca-header-transition',
            transparentHeader: 'vca-header-theme-background-transparent',
            pointerEvent: 'vca-pointer-events-none',
            noHeader: 'no-header',
            themeColorBlack: 'vca-header-theme-color-black',
            themeBackgroundWhite: 'vca-header-theme-background-white',
            showDesclaimerMessage: 'vca-show',
            bodyNotificationSelector: 'vca-nb-active',
            hide: 'vca-hide',
            notificationBarVisible: 'vca-nb-visible',
            notificationBarEnabled: 'vca-nb-active',
            animateMajorCover: 'vca-major-feature-cover-active'
        },
        DATA_ATTRIBUTE: {
            headerHeight: 'data-headerHeight',
            currencyCode: 'currencyCode',
            pageHeaderColorClass: 'pageHeaderColorClass',
            url: 'url',
            mobileFoldingCover: 'mobileFoldingCover'
        },
        stickyCategoryBarStr: 'bottomStickyCategoryBar',
        hideNotificationCookie: 'hideNotification',
        textBottomAlignedAboveFold: 'textBottomAlignedAboveFold',
        textTopAlignedAboveFold: 'textTopAlignedAboveFold',
        default: 'default'
    };

    /**
     * header component
     * @namespace header
     * @memberof vca.comp
     */
    vca.comp.header = (function($, util) {
        let $comp = null,
            $main = null,
            $notificationBar = null,
            $nbMessage = null,
            $nbMessageAnchor = null,
            $firstMajorCover = null,
            $firstMajorCoverData = null,
            $firstMajorShowFoldContent = null,
            $firstMajorShowFoldContentHeight = null,
            $firstMajorCoverContentHeight = null,
            $firstMajorCoverContent = null,
            $firstMajorCoverTitle = null,
            $firstMajorCoverTitleHeight = null,
            $updatedHeaderHeight = null,
            $transformValue = null,
            $intialTransformValue = null,
            $stickyCategoryBar = null,
            notificationBarheight = 0,
            nbComponentName = null,
            nbVisibleHeight = 0,
            isNotificationBarVisible = false,
            listeners = [],
            headerHeight = null,
            isHeaderTransparent = null,
            prevScrollpos = null,
            $pdpSticky = null,
            whiteBgClasses = '',
            transparentBgClasses = '',
            headerColorClass = '',
            $skiptoContent = null,
            pictoCategoryBar = true,
            maxAge = null,
            cookiePath = null,
            $closeBtn = null,
            $nBDiv = null,
            $nBPath = '',
            $body = $('body'),
            $scrollChange = null;

        /**
         * To remove the pointer events on page load
         * @function smLoaded
         * @memberOf vca.comp.header
         * @private
         * @returns {void}
         */
        function smLoaded() {
            // while loading header set the currency code in session storage to use it anywhere in the comp
            let currencyCode = $comp.data(CONST.DATA_ATTRIBUTE.currencyCode);
            util.webStorage.set('currency', currencyCode);

            // while loading header then remove vca-pointer-event-none class
            $comp
                .find(CONST.SELECTORS.item)
                .removeClass(CONST.CLASSES.pointerEvent);
        }

        /**
         * Scroll event handler for header
         * @function scrollHandler
         * @memberOf vca.comp.header
         * @private
         * @returns {void}
         */
        function scrollHandler() {
            let currentScrollPos = window.pageYOffset,
                newTop = null,
                searchCategoryPosition = null;
            const element =
                    document.scrollingElement || document.documentElement,
                scrolledPosition = element.scrollTop;
            $comp.removeClass(CONST.CLASSES.transitionHeader);
            if (
                scrolledPosition <= getHeaderHeight() &&
                isNotificationBarVisible
            ) {
                // 1 - when scroll position is less then header height and notification bar visible (scrolling b/w header)
                newTop = notificationBarheight - scrolledPosition + 'px';
                $comp.addClass(CONST.CLASSES.transitionHeader);
            } else if (
                scrolledPosition <= getHeaderHeight() &&
                !isNotificationBarVisible
            ) {
                // 2 - header sticky, but scrolling page
                // when scroll position is less then header height and notification bar is not visible
                if (currentScrollPos === 0 && notificationBarheight > 0) {
                    // 2.1 - reached at top && notification present
                    newTop = notificationBarheight + 'px';
                    $comp[0].style.top = newTop;
                }
                toggleTransparentHeaderBg(false);
                if ($stickyCategoryBar && pictoCategoryBar) {
                    searchCategoryPosition = -getHeaderHeight() + 'px';
                    toggleSearchCategoryStickyBar(true, searchCategoryPosition);
                }
                return;
            } else {
                // when scroll position is greater then header height
                if (
                    prevScrollpos > currentScrollPos ||
                    currentScrollPos === 0
                ) {
                    // 3 - when scrolling upside and scroll position is greater then header height (did not reach the header/top yet)

                    newTop = '0';
                    if (isNotificationBarVisible) {
                        newTop = nbVisibleHeight + 'px';
                    }
                    // check if the user has scrolled to the top then add the notificationBarheight as
                    // the top for header for smoother experience
                    if (currentScrollPos === 0) {
                        newTop = notificationBarheight + 'px';
                    }
                    toggleTransparentHeaderBg(true);
                    if ($stickyCategoryBar && pictoCategoryBar) {
                        searchCategoryPosition = 0;
                        toggleSearchCategoryStickyBar(
                            true,
                            searchCategoryPosition
                        );
                    }
                } else {
                    // 4 - when scrolling down and scroll position is greater then header height (crossed the header)
                    newTop = '-' + headerHeight - notificationBarheight + 'px';
                    $comp[0].style.top = newTop;
                    toggleTransparentHeaderBg(false);
                    if ($stickyCategoryBar && pictoCategoryBar) {
                        searchCategoryPosition = 0 + 'px';
                        toggleSearchCategoryStickyBar(
                            true,
                            searchCategoryPosition
                        );
                    }
                }
            }
            $comp[0].style.top = newTop;
            newTop !== '0'
                ? $pdpSticky.addClass(CONST.CLASSES.noHeader)
                : $pdpSticky.removeClass(CONST.CLASSES.noHeader);
            prevScrollpos = currentScrollPos;
        }

        /**
         * Toggle visibility of search result category sticky bar
         * @function toggleSearchCategoryStickyBar
         * @memberOf vca.comp.header
         * @private
         * @returns {void}
         */
        function toggleSearchCategoryStickyBar(state, position) {
            pictoCategoryBar = state;
            vca.comp.searchResultListing.toggleStickyBar(state);
            if (state) {
                $stickyCategoryBar[0].style.top = position;
            } else {
                $stickyCategoryBar[0].style = '';
            }
        }

        /**
         * Toggle header background color when header is transparent and on scroll add background functionality handler
         * @function toggleTransparentHeaderBg
         * @memberOf vca.comp.header
         * @private
         * @returns {void}
         */
        function toggleTransparentHeaderBg(transition) {
            if (!isHeaderTransparent) {
                return;
            }

            if (transition) {
                $comp
                    .addClass(whiteBgClasses)
                    .removeClass(transparentBgClasses);
            } else {
                $comp
                    .addClass(transparentBgClasses)
                    .removeClass(whiteBgClasses);
            }
        }

        /**
         * Resize event handler
         * @function resizeHandler
         * @memberOf vca.comp.header
         * @private
         * @returns {void}
         */
        function resizeHandler() {
            // we just need to update the variables, rest would be handled by scrollHandler
            cacheVars($comp[0]);
        }
        /**
         * Returning header height for sticky right block on product.js
         * @function getHeaderHeight
         * @memberOf vca.comp.header
         * @private
         * @returns {number} Returns header height
         */
        function getHeaderHeight() {
            return headerHeight;
        }

        /**
         * executing fade in/out effect on the disclaimer section
         * @function disclaimerShow
         * @memberOf vca.comp.header
         * @private
         * @returns {number} Returns fade in/out effect for the desclaimers in header
         */

        function showDisclaimer() {
            $(CONST.SELECTORS.desclaimerMessage)
                .first()
                .addClass(CONST.CLASSES.showDesclaimerMessage)
                .fadeIn();
            if (
                $body.hasClass(CONST.CLASSES.bodyNotificationSelector) &&
                $(CONST.SELECTORS.desclaimerMessage).length > 1
            ) {
                let maxHeight = 0;
                $(CONST.SELECTORS.desclaimerMessage).each(function() {
                    if ($(this).height() > maxHeight) {
                        maxHeight = $(this).height();
                    }
                });
                $(CONST.SELECTORS.desclaimerMessage)
                    .parent()
                    .height(maxHeight);
                $(CONST.SELECTORS.desclaimerMessage).hide();
                function displayDisclaimer() {
                    let current = $(CONST.SELECTORS.currentDesclaimnerMessage);
                    let next = current.next().length
                        ? current.next()
                        : current.siblings().first();
                    //*** Repeat function every 4 seconds ***//
                    let desclaimerTimer = setTimeout(displayDisclaimer, 4000);
                    //*** Swap out the items and class ***//
                    current
                        .removeClass(CONST.CLASSES.showDesclaimerMessage)
                        .fadeOut(500);
                    next.delay(500)
                        .addClass(CONST.CLASSES.showDesclaimerMessage)
                        .fadeIn(650);
                    $(CONST.SELECTORS.notificationCloseBtn).on(
                        util.customEvents.INTERACTION,
                        function() {
                            clearTimeout(desclaimerTimer);
                        }
                    );
                }
                displayDisclaimer();
            }
        }

        /**
         * Open the sign in panel if url have my-account param
         * @function checkMyaccount
         * @memberOf vca.comp.header
         * @private
         * @returns {void}
         */
        function checkMyaccount() {
            let url = window.location.search;

            if (url.includes('my-account')) {
                $comp
                    .find(CONST.SELECTORS.signINLi)
                    .find(CONST.SELECTORS.signINLink)
                    .trigger(util.customEvents.INTERACTION);
            }
        }

        /**
         * Updates variables being used.
         * @function cacheVars
         * @memberOf vca.comp.header
         * @private
         * @returns {void}
         */
        function cacheVars() {
            $notificationBar = $(CONST.SELECTORS.notificationBar);
            maxAge =
                $notificationBar.length > 0
                    ? $notificationBar[0].dataset.maxage
                    : null;
            cookiePath =
                $notificationBar.length > 0
                    ? $notificationBar[0].dataset.cookiePath
                    : null;
            $closeBtn = $notificationBar.find(
                CONST.SELECTORS.notificationCloseBtn
            );

            $comp = $(CONST.SELECTORS.comp);
            $main = $(CONST.SELECTORS.baseMain);
            $pdpSticky = $main.find(CONST.SELECTORS.pdpSticky);
            $notificationBar = $(CONST.SELECTORS.notificationBar);
            $nBDiv = $(CONST.SELECTORS.notificationBarContainer);
            $nBPath = $nBDiv.length
                ? $nBDiv.data(CONST.DATA_ATTRIBUTE.url)
                : '';
            $nbMessage = $(CONST.SELECTORS.nbMessage);
            $nbMessageAnchor = $(CONST.SELECTORS.nbMessageAnchor);
            $skiptoContent = $(CONST.SELECTORS.skiptoContent);
            headerColorClass = $comp.data(
                CONST.DATA_ATTRIBUTE.pageHeaderColorClass
            );
            whiteBgClasses = [
                CONST.CLASSES.themeColorBlack,
                CONST.CLASSES.themeBackgroundWhite
            ].join(' ');
            transparentBgClasses = [
                headerColorClass,
                CONST.CLASSES.transparentHeader
            ].join(' ');
            $firstMajorCover = $main
                .find(CONST.SELECTORS.firstMajorCover)
                .eq(0);
            $firstMajorCoverData = $firstMajorCover.data(
                CONST.DATA_ATTRIBUTE.mobileFoldingCover
            );
            $firstMajorShowFoldContent = $firstMajorCover.find(
                CONST.SELECTORS.firstMajorShowFoldContent
            );
            $firstMajorShowFoldContentHeight = $firstMajorShowFoldContent.height();
            $firstMajorCoverContent = $firstMajorCover.find(
                CONST.SELECTORS.firstMajorCoverContent
            );
            $firstMajorCoverContentHeight = $firstMajorCoverContent.height();
            $firstMajorCoverTitle = $firstMajorCover.find(
                CONST.SELECTORS.firstMajorCoverTitle
            );
            $firstMajorCoverTitleHeight = $firstMajorCoverTitle.outerHeight(
                true
            );
            // Check if notification bar is present, if so cache it and its height
            updateHeaderHeight();
            isHeaderTransparent = $comp.hasClass(
                CONST.CLASSES.transparentHeader
            );
            $stickyCategoryBar = $(CONST.SELECTORS.stickyCategoryBar).length
                ? $(CONST.SELECTORS.stickyCategoryBar)
                : null;
            // respective padding move to less, handle on transpartent header
            if (!util.wcmmode.isAuthor && isHeaderTransparent) {
                let newHeaderHeight = $notificationBar.length
                    ? nbVisibleHeight + 'px'
                    : '0px';

                $main[0].style.paddingTop = newHeaderHeight;
                $main[0].style.setProperty('--header-height', newHeaderHeight);

                $firstMajorCover.addClass(CONST.CLASSES.transparentHeader);
            }

            prevScrollpos = w.pageYOffset;
            $updatedHeaderHeight = $main.attr(
                CONST.DATA_ATTRIBUTE.headerHeight
            );
        }

        /**
         * Notification bar click handler
         * @function nbClickEvent
         * @memberOf vca.comp.header
         * @private
         * @returns {void}
         */
        function nbClickEvent() {
            let hrefAttrVal = $(this).attr('data-href'),
                targetAttrVal = $(this).attr('data-target');
            window.open(hrefAttrVal, targetAttrVal);
        }

        /**
         * Function to dismiss the notification bar on click action of the button.
         * @function closeNotification
         * @memberOf vca.comp.header
         * @private
         * @returns {void}
         */
        function closeNotification() {
            // explicitly remove class display flex from container for the
            // generic class vca-hide to have an effect on it.
            $notificationBar
                .addClass(CONST.CLASSES.hide)
                .removeClass(CONST.CLASSES.notificationBarVisible);

            util.cookieManager.setCookie(
                CONST.hideNotificationCookie,
                'true',
                maxAge,
                cookiePath
            );
            updateNotificationBodyClass();
            $.publish(util.customEvents.NB_HIDDEN);
        }

        /**
         * Add and remove nb active class on body tag
         * @function updateNotificationBodyClass
         * @memberOf vca.comp.header
         * @private
         * @returns {void}
         */
        function updateNotificationBodyClass(status) {
            if (status) {
                $body.hasClass(CONST.CLASSES.notificationBarEnabled)
                    ? ''
                    : $body.addClass(CONST.CLASSES.notificationBarEnabled);
                return;
            } else {
                $body.removeClass(CONST.CLASSES.notificationBarEnabled);
            }
        }

        /**
         * Notification bar anchor click handler
         * @function nbMsgAchorClick
         * @memberOf vca.comp.header
         * @private
         * @returns {void}
         */
        function nbMsgAchorClick(e) {
            e.stopPropagation();
        }

        /**
         * animate content for major feature cover on home page
         * @function animateMajorFeatureCover
         * @memberOf vca.comp.header
         * @private
         * @returns {void}
         */
        function animateMajorFeatureCover() {
            let scroll = $(window).scrollTop();

            if (scroll >= $scrollChange) {
                $body.addClass(CONST.CLASSES.animateMajorCover);

                $firstMajorCoverContent.css('transform', 'translateY(0px)');
            } else {
                $body.removeClass(CONST.CLASSES.animateMajorCover);

                $firstMajorCoverContent.css(
                    'transform',
                    'translateY(' + $intialTransformValue + 'px)'
                );
            }
        }

        /**
         * initial animate content values for major feature cover on home page
         * @function initAnimateMajorFeatureCover
         * @memberOf vca.comp.header
         * @private
         * @returns {void}
         */
        function initAnimateMajorFeatureCover() {
            $scrollChange = headerHeight;

            $main[0].style.setProperty(
                '--animate-title-height',
                $firstMajorCoverTitleHeight + 'px'
            );

            // calculating transform value according to content height and header height
            if (!util.wcmmode.isAuthor && isHeaderTransparent) {
                $transformValue =
                    $firstMajorShowFoldContentHeight -
                    parseInt($updatedHeaderHeight);
            } else {
                $transformValue =
                    $firstMajorShowFoldContentHeight -
                    parseInt($updatedHeaderHeight) -
                    parseInt($updatedHeaderHeight);
            }

            // adding attribute --animate-header-height for box-shadow in header with title for top align above fold before scroll, this we can use in css
            if ($firstMajorCoverData == CONST.textTopAlignedAboveFold) {
                $main[0].style.setProperty(
                    '--animate-header-height',
                    headerHeight + $firstMajorCoverTitleHeight + 'px'
                );
            } else {
                $main[0].style.setProperty(
                    '--animate-header-height',
                    headerHeight + 'px'
                );
            }
            $intialTransformValue =
                $firstMajorCoverData == CONST.textBottomAlignedAboveFold
                    ? $transformValue
                    : $firstMajorCoverContentHeight;

            // adding initial transform value on content
            $firstMajorCoverContent.css(
                'transform',
                'translateY(' + $intialTransformValue + 'px)'
            );
        }

        /**
         * Bind events
         * @function bindEvents
         * @memberOf vca.comp.header
         * @private
         * @returns {void}
         */
        function bindEvents() {
            $closeBtn.on(util.customEvents.INTERACTION, closeNotification);

            // event subscribers
            listeners.push(
                $.subscribe(util.customEvents.RESIZED, resizeHandler),
                $.subscribe(util.customEvents.NB_HIDDEN, resizeHandler)
            );
            // event handlers
            if (!util.wcmmode.isAuthor) {
                $(w).on(util.customEvents.SCROLL, scrollHandler);
            }
            if ($notificationBar.length) {
                util.io.observer.observe($notificationBar[0]);
                listeners.push(
                    $.subscribe(
                        util.customEvents.IO_IN + ':' + nbComponentName,
                        function(args) {
                            nbVisibleHeight = Math.abs(
                                notificationBarheight + args.y
                            );
                            isNotificationBarVisible = true;
                        }
                    )
                );
                listeners.push(
                    $.subscribe(
                        util.customEvents.IO_OUT + ':' + nbComponentName,
                        function(args) {
                            nbVisibleHeight = args.y;
                            isNotificationBarVisible = false;
                        }
                    )
                );
            }

            $nbMessage.on(util.customEvents.INTERACTION, nbClickEvent);
            $nbMessageAnchor.on(util.customEvents.INTERACTION, nbMsgAchorClick);
            $skiptoContent.on(util.customEvents.INTERACTION, focusFirstElement);

            // add animation and box shadow for major feature cover except default in mobile view
            if (vca.util.matchmedia.narrow.matches) {
                if ($firstMajorCoverData != CONST.default) {
                    initAnimateMajorFeatureCover();
                    window.addEventListener(
                        util.customEvents.SCROLL,
                        animateMajorFeatureCover
                    );
                }
            }
        }
        /**
         * Unbinds all pre-existing events
         * @function teardown
         * @memberOf vca.comp.header
         * @private
         * @returns {void}
         */
        function teardown() {
            while (listeners.length) {
                $.unsubscribe(listeners.pop());
            }
            // intensionally commented to enable further scroll event usages by other modules/components
            // $(w).off(util.customEvents.SCROLL);
            $nbMessage.off(util.customEvents.INTERACTION, nbClickEvent);
            $nbMessageAnchor.off(
                util.customEvents.INTERACTION,
                nbMsgAchorClick
            );
        }

        /**
         * focus first element when click skip to main content
         * @function focusFirstElement
         * @memberOf vca.comp.header
         * @private
         * @returns {void}
         */
        function focusFirstElement(event) {
            event.preventDefault();
            let focusable = $(CONST.SELECTORS.vcaMain).find(
                CONST.SELECTORS.focusableElements
            );
            let firstFocusable = focusable[0];
            firstFocusable.focus();
        }

        /**
         * Get notification bar fragment from path with XHR
         * @function getNotificationBar
         * @memberOf vca.comp.header
         * @private
         * @returns {void}
         */
        const getNotificationBar = async () => {
            try {
                let result = await vca.util.request.get($nBPath);

                const doc = new DOMParser().parseFromString(
                    result,
                    'text/html'
                );
                if (doc.body)
                    result = doc.querySelector(CONST.SELECTORS.notificationBar);

                if (result) {
                    $nBDiv.html(result);
                    cacheVars();
                }
            } catch (e) {
                console.log('Exception in getting the notification bar', e);
            }
        };

        /**
         * Update header height on the basis of cookie set
         * @function updateHeaderHeight
         * @memberOf vca.comp.header
         * @private
         * @returns {void}
         */
        const updateHeaderHeight = () => {
            if (util.cookieManager.getCookie(CONST.hideNotificationCookie)) {
                $notificationBar
                    .addClass(CONST.CLASSES.hide)
                    .removeClass(CONST.CLASSES.notificationBarVisible);
                updateNotificationBodyClass();
            } else {
                $notificationBar
                    .addClass(CONST.CLASSES.notificationBarVisible)
                    .removeClass(CONST.CLASSES.hide);
                updateNotificationBodyClass(true);
            }

            if ($notificationBar.length) {
                nbVisibleHeight = $notificationBar[0].clientHeight;
                nbComponentName = $notificationBar[0].dataset.componentName;
                notificationBarheight = nbVisibleHeight;
                isNotificationBarVisible = nbVisibleHeight > 0;
                $comp.addClass(CONST.CLASSES.transitionHeader);
            }
            headerHeight = $comp[0].clientHeight + nbVisibleHeight;
            $comp[0].style.top = nbVisibleHeight + 'px';
            /* Add total header height, including the notification bar's height in the data tag on main dom element */
            if (!isHeaderTransparent) {
                $main.attr(CONST.DATA_ATTRIBUTE.headerHeight, headerHeight);
                $main[0].style.paddingTop = headerHeight + 'px';
                $main[0].style.setProperty(
                    '--header-height',
                    headerHeight + 'px'
                );
            }
        };

        /**
         * Initialize the component
         * @function init
         * @memberOf vca.comp.header
         * @private
         * @returns {void}
         */
        async function init() {
            cacheVars();
            if ($nBDiv.length && $nBPath.length) {
                await getNotificationBar();
                showDisclaimer();
            }
            teardown();
            bindEvents();
            smLoaded();
            checkMyaccount();
            updateHeaderHeight();
        }
        return {
            init: init,
            getHeaderHeight: getHeaderHeight,
            toggleTransparentHeaderBg: toggleTransparentHeaderBg,
            toggleSearchCategoryStickyBar: toggleSearchCategoryStickyBar
        };
    })(vca.$, vca.util);
})(window, window.vca);

/**
 * guestOrderInquiry.js
 * functionality for the guestOrderInquiry component
 */
(function(vca) {
    'use strict';

    const CONST = {
        SELECTORS: {
            submitResponse: '.base-forms-response',
            guestOrderInquiryForm: '.vca-goif-form',
            guestOrderInquiryFormDescription: '.vca-goif-description',
            guestOrderInquiryFormSuccess: '.vca-goif-confirm'
        },
        CLASS: {
            hide: 'vca-hide'
        },
        formId: 'vca-guest-order-detail-inquiry-form'
    };

    /**
     * guestOrderInquiry component
     * @namespace guestOrderInquiry
     * @memberof vca.comp
     */
    vca.comp.guestOrderInquiry = (function($) {
        /**
         * guestOrderInquiry form success functionality handler
         * @function successFormHandler
         * @memberOf vca.comp.guestOrderInquiry
         * @private
         * @returns {void}
         */
        function successFormHandler(response) {
            let resultId = 'result_' + CONST.formId,
                data = $(response)
                    .find(CONST.SELECTORS.submitResponse)
                    .html();
            if (data) {
                data = $.parseJSON(data) || {};
                if (data[resultId].success) {
                    // show confirmation message and hide form and form description
                    $(CONST.SELECTORS.guestOrderInquiryForm).addClass(
                        CONST.CLASS.hide
                    );
                    $(
                        CONST.SELECTORS.guestOrderInquiryFormDescription
                    ).addClass(CONST.CLASS.hide);
                    $(CONST.SELECTORS.guestOrderInquiryFormSuccess).removeClass(
                        CONST.CLASS.hide
                    );
                }
            }
        }

        /**
         * Bind events
         * @function bindEvents
         * @memberOf vca.comp.guestOrderInquiry
         * @private
         * @returns {void}
         */
        function bindEvents() {
            $.subscribe('base:forms:success', successFormHandler);
        }

        /**
         * Initialize the component
         * @function init
         * @memberOf vca.comp.guestOrderInquiry
         * @private
         * @param {HTMLElement}
         * @returns {void}
         */
        function init() {
            bindEvents();
        }

        return {
            init: init
        };
    })(vca.$, vca.util);
})(window.vca);

/* consent.js */
/**
 * functionality for consent
 */
'use strict';

(function() {
    /**
     * Consent
     * @namespace consent
     */
    vca.comp.consent = (function($, util) {
        let $comp = null,
            $consentLink;

        const selectors = {
                consentLink: '.vca-consent-btn',
                consentContent: '.vca-consent-content',
                consentButtonTitle:
                    '.vca-consent-btn-title, .vca-consent-show-less'
            },
            cssClass = {
                vcaShow: 'vca-show',
                vcaHide: 'vca-hide'
            };

        /**
         * Toggle Content function
         * @memberOf vca.comp.consent
         * @private
         */
        const toggleContent = function toggleContent(currentEle) {
            currentEle.nextAll(selectors.consentContent).slideToggle('normal');
            currentEle.toggleClass(cssClass.vcaHide);
            currentEle.find(selectors.consentButtonTitle).toggle();
        };

        /**
         * Bind events
         * @memberOf vca.comp.consent
         * @private
         */
        const bindEvents = function bindEvents() {
            $consentLink.on(util.customEvents.INTERACTION, function(e) {
                const currentEle = $(e.currentTarget);
                toggleContent(currentEle);
            });
        };

        /**
         * Cache variables being used.
         * @function cacheVars
         * @memberOf vca.comp.consent
         * @private
         * @param {HTMLElement} elem The component element
         * @returns {void}
         */

        function cacheVars(comp) {
            $comp = $(comp);
            $consentLink = $comp.find(selectors.consentLink);
        }
        /**
         * Initialise Consent
         * @function init
         * @param {HTMLElement} comp current section
         * @private
         */
        const init = function init(elem) {
            cacheVars(elem);
            bindEvents();
        };

        return {
            init: init
        };
    })(vca.$, vca.util);
})();

/**
 * cardsContainer.js
 * functionality for the cards container component
 */

/**
 * account.js
 * functionality for the account component
 */
(function(vca, base) {
    'use strict';

    const CONST = {
        SELECTORS: {
            overlay: '.vca-lightbox-wrapper',
            content: '.base-lightbox-content',
            tabLinks: '.vca-tab-links',
            tabCont: '.vca-acc-tab-cont',
            imptxt: '.vca-contact-us-imptxt',
            loginHead: '.loginHeading',
            regHead: '.regHeading',
            lightboxHeader: '.vca-lb-header',
            accTabBtn: '.vca-acc-tabs .vca-tab-links',
            accInfo: '.vca-acc-intro',
            accountConfirmText: '.vca-acc-conf-text',
            accountConfirm: '.vca-acc-conf',
            resendBtn: '.vca-acc-resend-btn',
            backBtn: '.vca-acc-back-btn',
            activeForm: '.base-lightbox-content .vca-acc-tab-cont.vca-active',
            forgotPasswordForm: 'forgot-password-form',
            instructionText: '.system_form_password .base-forms-instruction',
            fpIntroText: '.vca-fp-introtext',
            baseConfimationContainer: '.base-forms-confirmation',
            baseLoginAjaxFormContainer: '.login-ajax',
            baseRecaptchaV2: '.base-recaptchav2'
        },
        CLASSES: {
            bapPage: 'vca-template-boutique-appointment-page',
            active: 'vca-active',
            hide: 'vca-hide',
            selected: 'vca-selected',
            basehide: 'base-hidden'
        },
        DATA_ATTR: {
            formName: 'formName',
            trackingFormName: 'trackingFormName',
            countryCode: 'countryCode',
            languageCode: 'languageCode',
            pgtype: 'pgtype',
            pgtypemsn: 'pgtypemsn',
            currency: 'currencyCode'
        }
    };

    /**
     * account component
     * @namespace account
     * @memberof vca.comp
     */
    vca.comp.account = (function($, util, baseUtil) {
        let $comp = null,
            listeners = [],
            scrollToTop = 0,
            $loginHead = null,
            $imptxt = null,
            $regHead = null,
            $lightboxHeader = null,
            $accInfo = null,
            $accountConfirm = null,
            bapPage = false,
            $form,
            formId,
            $body = $('body'),
            emailId = '',
            accountConfirmText = null,
            $accountConfirmEle = null,
            $baseRecaptchaV2 = null,
            isCountryCN = util.dataStore.isChina();

        /**
         * Account tab handler
         * @function tabClickHandler
         * @memberOf account
         * @private
         * @param {HTMLElement} elem The component element
         * @returns {void}
         */
        function tabClickHandler(event) {
            let formName = '',
                trackingFormName = '',
                $tabClicked = null,
                trackingEventObj = {},
                countryCode = $comp.data(CONST.DATA_ATTR.countryCode),
                languageCode = $comp.data(CONST.DATA_ATTR.languageCode),
                currencyCode = $comp.data(CONST.DATA_ATTR.currency),
                pagePath,
                pgtype = $comp.data(CONST.DATA_ATTR.pgtype) || 'N/A',
                profileManager = base.util.profileManager,
                profileStoreData = profileManager.getProfileStoreData(),
                userId = profileStoreData.userId || 'N/A';
            if (!$(event.target).hasClass(CONST.SELECTORS.tabLinks)) {
                $tabClicked = $(event.target).closest(CONST.SELECTORS.tabLinks);
            } else {
                $tabClicked = $(event.target);
            }
            // To identify form resource for its tab content
            formName = $tabClicked.data(CONST.DATA_ATTR.formName);

            // For tracking only
            trackingFormName = $tabClicked.data(
                CONST.DATA_ATTR.trackingFormName
            );
            pagePath =
                '/' +
                countryCode +
                '/' +
                languageCode +
                '/pop-in/account/' +
                trackingFormName;

            $(CONST.SELECTORS.tabLinks)
                .removeClass(CONST.CLASSES.selected)
                .attr('aria-selected', 'false');
            $tabClicked
                .addClass(CONST.CLASSES.selected)
                .attr('aria-selected', 'true');

            $(CONST.SELECTORS.tabCont)
                .removeClass(CONST.CLASSES.active)
                .addClass(CONST.CLASSES.hide);

            if (trackingFormName === 'sign-in') {
                $lightboxHeader.html($loginHead.val());
            } else {
                $lightboxHeader.html($regHead.val());

                if (
                    $baseRecaptchaV2.length > 0 &&
                    !$baseRecaptchaV2.find('iframe').length
                ) {
                    base.comp.captcha.recaptchav2.init($baseRecaptchaV2);
                }
            }
            $('.' + formName)
                .removeClass(CONST.CLASSES.hide)
                .addClass(CONST.CLASSES.active);

            // Analytics for login and register
            trackingEventObj = {
                event: 'page_view',
                page: pagePath,
                user_status: 'not logged',
                user_id: userId,
                ecommerce_buyer: 'No',
                ecommerce_client_type: 'N/A',
                pg_type: pgtype,
                pg_country: countryCode,
                pg_language: languageCode,
                user_email: 'N/A',
                currency: currencyCode || 'N/A'
            };

            baseUtil.analytics.pushDataToDataLayer(trackingEventObj);
        }

        /**
         * showConfirmation
         * @function showConfirmation
         * @private
         * @memberof vca.comp.account
         */
        function showConfirmation() {
            $accInfo.addClass(CONST.CLASSES.hide);
            $imptxt.addClass(CONST.CLASSES.hide);
            $(CONST.SELECTORS.baseConfimationContainer).css('display', 'none');

            // Show account creating dinamic confirmation
            accountConfirmText = $accountConfirmEle.text();
            accountConfirmText = accountConfirmText.replace('{0}', emailId);
            $accountConfirmEle.text(accountConfirmText);
            $accountConfirm.removeClass(CONST.CLASSES.hide);
            $form = $body.find(CONST.SELECTORS.activeForm);

            if (
                String(util.dataStore.getDefaultCountryCode).toLowerCase() ===
                'cn'
            ) {
                $form.find('form').addClass(CONST.CLASSES.basehide);
            }

            if ($(CONST.SELECTORS.fpIntroText).length) {
                $(CONST.SELECTORS.fpIntroText).addClass(CONST.CLASSES.hide);
                $(CONST.SELECTORS.baseConfimationContainer).addClass(
                    CONST.SELECTORS.basehide
                );
            }
        }

        /**
         * accountCreation form success Tracking call
         * @function successanalyticsCall
         * @memberOf vca.comp.account
         * @private
         */
        function successanalyticsCall(emailId) {
            let trackingEventObj = {};
            util.crypto.encryptToSHA256(emailId).then(function(hashedEmail) {
                // Analytics for form success
                trackingEventObj = {
                    event: 'sign_up',
                    user_email: hashedEmail
                };

                baseUtil.analytics.pushDataToDataLayer(trackingEventObj);

                if (isCountryCN) {
                    baseUtil.analytics.pushToSensorsData('sign_up', {
                        user_email: hashedEmail
                    });
                }
            });
        }

        /**
         * Form reinit
         * @function formInitHandler
         * @private
         * @param {Object} form Form element
         * @param {boolean} success Response true/false
         * @param {String}  message Response message
         * @param {Object} data Response Object
         * @memberOf vca.comp.account
         */
        function formInitHandler(form, success) {
            if (success) {
                emailId = $(CONST.SELECTORS.baseConfimationContainer).text();
                showConfirmation();
                successanalyticsCall(emailId);
                $(CONST.SELECTORS.content).scrollTop(scrollToTop);
            } else {
                $body
                    .find(CONST.SELECTORS.content)
                    .animate({ scrollTop: 0 }, 500);
                base.comp.forms.init($(form));
            }
        }

        /**
         * Method to track when the user logged in
         * @function executeLoginTracking
         * @memberof vca.comp.account
         * @private
         * @param {String} loginStatus true means the user is logged in
         */
        function executeLoginTracking() {
            const loginStatus = base.util.profileManager.isLoggedIn();
            if (loginStatus === true) {
                const userId = base.util.profileManager.getProfileStoreData()
                    .userId;
                baseUtil.analytics.pushDataToDataLayer({
                    event: 'login',
                    user_email: userId
                });
            }
        }

        /**
         * User login success handler
         * @function loginSuccessHandler
         * @memberOf vca.comp.account
         * @private
         * @returns {void} - redirect user to my account page/newsletter page.
         */
        function loginSuccessHandler() {
            if (!bapPage) {
                if (!util.webStorage.get('nlExistingAccountsLoginFlag')) {
                    window.onunload = executeLoginTracking();
                    $(location).attr('href', $form.data('posturl'));
                } else {
                    $(location).attr(
                        'href',
                        util.webStorage.get('nlExistingAccountsLoginFlag')
                    );
                    removeNlEaaLoginFlag();
                }
            } else {
                bapPage = false;
            }
            vca.util.lightbox.closeLightbox();
        }

        /**
         * Remove newsletter existing accounts login flag
         * @function removeNlEaaLoginFlag
         * @memberOf vca.comp.account
         * @private
         * @returns {void}
         */
        function removeNlEaaLoginFlag() {
            util.webStorage.remove('nlExistingAccountsLoginFlag');
        }
        /**
         * Form success handler
         * @function formSuccessHandler
         * @memberOf vca.comp.account
         * @private
         * @param {Object} data Response Object
         * @returns {void}
         */
        function formSuccessHandler(data) {
            if (!data) {
                return;
            } else {
                $comp
                    .find(CONST.SELECTORS.baseLoginAjaxFormContainer)
                    .css('min-height', '370px');
            }
        }

        /**
         * Resend btn click handler
         * @function resendBtnHandler
         * @memberOf vca.comp.account
         * @private
         * @returns {void}
         */
        function resendBtnHandler(e) {
            let $thisEl = $(e.target),
                pagePath = $thisEl.data('pagePath').replace('.html', ''),
                servletUrl = '.resend-confirmation.json?email=',
                email = $thisEl
                    .closest(CONST.SELECTORS.tabCont)
                    .find('[name="email_address"]')
                    .val(),
                requestUrl = [
                    pagePath,
                    servletUrl,
                    encodeURIComponent(email) // encodeURIComponent('hello+69@akqa.com') -> "hello%2B69%40akqa.com"
                ].join('');

            if (email)
                util.request
                    .post(requestUrl)
                    .done(function(data, status) {
                        console.log('Success', data, status);
                    })
                    .fail(function(data, status) {
                        console.error('Error', data, status);
                    });
        }

        /**
         * Back btn click handler
         * @function backBtnHandler
         * @memberOf vca.comp.account
         * @private
         * @returns {void}
         */
        function backBtnHandler() {
            $accInfo.removeClass(CONST.CLASSES.hide);
            $accountConfirm.addClass(CONST.CLASSES.hide);
            $form = $body.find(CONST.SELECTORS.activeForm);
            $form.find('form').removeClass(CONST.CLASSES.basehide);
            $form.find('form')[0].reset();
            grecaptcha.reset();
        }

        /**
         * Forgot password Form Submit handler
         * @function forgotPasswordSubmitHandler
         * @memberOf vca.comp.account
         * @private
         * @returns {void}
         */
        function forgotPasswordSubmitHandler() {
            $(CONST.SELECTORS.baseConfimationContainer).css('display', 'block');
        }

        /**
         * Start basic executions
         * @function start
         * @memberOf vca.comp.account
         * @private
         * @returns {void}
         */
        function start() {
            $lightboxHeader.html($loginHead.val());
            $.subscribe(
                baseUtil.customEvents.FORMS_SUCCESS +
                    ':' +
                    CONST.SELECTORS.forgotPasswordForm,
                forgotPasswordSubmitHandler
            );

            // Initializing concierge detail js
            util.conciergeDetail.init();
        }

        /**
         * Bind events
         * @function bindEvents
         * @memberOf vca.comp.account
         * @private
         * @returns {void}
         */
        function bindEvents() {
            // event subscribers
            listeners.push(
                $.subscribe(
                    baseUtil.customEvents.FORMS_SUCCESS,
                    formInitHandler
                )
            );

            listeners.push(
                $.subscribe(
                    baseUtil.customEvents.LOGIN_SUCCESS + ':' + formId,
                    loginSuccessHandler
                )
            );

            listeners.push(
                $.subscribe(
                    baseUtil.customEvents.FORMS_SUCCESS + ':' + formId,
                    formSuccessHandler
                )
            );

            // event handlers
            $comp.on(
                util.customEvents.INTERACTION,
                CONST.SELECTORS.accTabBtn,
                tabClickHandler
            );

            $comp.on(
                util.customEvents.INTERACTION,
                CONST.SELECTORS.resendBtn,
                resendBtnHandler
            );

            $comp.on(
                util.customEvents.INTERACTION,
                CONST.SELECTORS.backBtn,
                backBtnHandler
            );
        }

        /**
         * Unbinds all pre-existing events
         * @function teardown
         * @memberOf vca.comp.account
         * @private
         * @returns {void}
         */
        function teardown() {
            while (listeners.length) {
                $.unsubscribe(listeners.pop());
            }

            $comp.off(
                util.customEvents.INTERACTION,
                CONST.SELECTORS.accTabBtn,
                tabClickHandler
            );

            $comp.off(
                util.customEvents.INTERACTION,
                CONST.SELECTORS.resendBtn,
                resendBtnHandler
            );

            $comp.off(
                util.customEvents.INTERACTION,
                CONST.SELECTORS.backBtn,
                backBtnHandler
            );
        }

        /**
         * Cache variables being used.
         * @function cacheVars
         * @memberOf vca.comp.account
         * @private
         * @param {HTMLElement} elem The component element
         * @returns {void}
         */
        function cacheVars(elem) {
            // TODO: refactor these to have/use minimal global variables
            $comp = $(elem);
            $imptxt = $comp.find(CONST.SELECTORS.imptxt);
            $loginHead = $comp.find(CONST.SELECTORS.loginHead);
            $regHead = $comp.find(CONST.SELECTORS.regHead);
            $accInfo = $comp.find(CONST.SELECTORS.accInfo);
            $lightboxHeader = $body.find(CONST.SELECTORS.lightboxHeader);
            $accountConfirm = $body.find(CONST.SELECTORS.accountConfirm);
            $form = $body.find(CONST.SELECTORS.activeForm);
            formId = $form.find('form').attr('id');
            bapPage = $body.hasClass(CONST.CLASSES.bapPage);
            $accountConfirmEle = $body.find(CONST.SELECTORS.accountConfirmText);
            $baseRecaptchaV2 = $comp.find(CONST.SELECTORS.baseRecaptchaV2);
        }

        /**
         * Initialize the component
         * @function init
         * @memberOf vca.comp.account
         * @private
         * @param {HTMLElement} elem The component element
         * @returns {void}
         */
        function init(elem) {
            cacheVars(elem);
            teardown();
            bindEvents();
            start();
        }

        return {
            init: init,
            removeNlEaaLoginFlag: removeNlEaaLoginFlag
        };
    })(vca.$, vca.util, base.util);
})(window.vca, window.base);

/**
 * searchResultListing.js
 * functionality for the searchResultListing component
 */
(function(vca, base) {
    'use strict';

    const CONST = {
        SELECTORS: {
            resetAllFacetsButton: '.action-button.reset-action',
            searchCatHeading: '.base-search-category-heading',
            searchFilterWrapper: '.vca-srl-filter-wrapper',
            searchFilterBtn: '.vca-srl-filter-btn',
            toggleViewBtn: '.vca-srl-toggle-list',
            scrollTopBtn: '.vca-srl-scroll-top',
            resultList: '.results-list',
            applyAllBtn: '#apply-filters-aria-label',
            noResultComp: '.vca-no-search-result',
            searchEngine: '.search-engine',
            noResultWord: '.vca-no-result-word',
            noResultKeyword: '.vca-no-result-keyword',
            noResultError: '.vca-nr-error',
            noResultServerError: '.vca-nr-server-error',
            baseSearchForm: '.base-search-form',
            baseSearchInput: '.base-search-input',
            searchCloseBtn: '.vca-sb-btn-close',
            searchFacetItem: '.vca-srl-facet-item',
            subList: '.sub-list',
            flexRow: '.flex-row',
            searchToggleViewBtnWrapper: '.vca-srl-toggle-view',
            stickyCategoryBar: '.vca-srl-sticky-categories',
            pictoCategoryBar: '.base-search-category-result-list',
            searchResultCategory: '.search-result-category',
            categoryTab: '.vca-category-tab',
            categoryTabLink: '.vca-category-tab-link',
            filterSelector: '.vca-srl-facet-tracking',
            resultsContainer: '.results-main-container',
            categoryTabLinkTracking: '.vca-category-tab-link-tracking',
            availablityCheckbox: '.vca-srl-availablity-check',
            searchCreationCountWrapper: '.vca-srl-creation-count',
            avaiblityFilterCheckbox: '.vca-srl-availablity-input-checkbox',
            srlSortTypeSelect: '.vca-srl-sort-type',
            srlSortTypeSelectCustom: '.vca-custom-select-li-sort',
            srlAvailablityTooltip: '.vca-srl-availablity-checkbox-tooltip',
            srlAvailablityTooltipText:
                '.vca-srl-availablity-checkbox-tooltiptext',
            searchFilterFacetsActionButtons:
                '.vca-srl-filter-container .action-button',
            searchFilterFacetsIconButtons:
                '.vca-srl-filter-container .icon-button',
            searchFilterFacetsInputs:
                '.vca-srl-filter-container .vca-srl-facet-input',
            searchFilterFacetsFieldsets:
                '.vca-srl-filter-container .vca-srl-facet-fieldset'
        },
        CSSCLASS: {
            searchFilterActive: 'vca-srl-filter-active',
            searchFilterOpened: 'vca-srl-filter-opened',
            listSingleGrid: 'vca-srl-single-column',
            zoomOut: 'vca-icn-zoom-out-arrow-circle',
            zoomIn: 'vca-icn-zoom-in-arrow-circle',
            showBtn: 'vca-show-btn',
            applyButton: 'apply_action',
            hide: 'vca-hide',
            zeroResultFacet: 'vca-zero-result-facet',
            restrictScrolling: 'vca-restrict-scrolling',
            articlesResultListing: 'vca-srl-articles',
            stickyCategoryBarActive: 'vca-srl-sc-active',
            categoryTabLink: 'vca-category-tab-link',
            linkActive: 'vca-link-active',
            visibilityHidden: 'vca-visibility-hidden'
        },
        ATTRIBUTES: {
            dataPpcEnable: 'data-enable-price-per-country',
            facetCategorySticky: 'sticky facets',
            facetCategoryFilter: 'facets before filters',
            facetAriaHidden: 'aria-hidden',
            facetTabindex: 'tabindex'
        },
        stickyCategoryBarStr: 'bottomStickyCategoryBar',
        enablePriceDisplay: 'enablePriceDisplay',
        enablePriceDisplayKey: 'enablePriceDisplay',
        enablePpcDisplayKey: 'enablePpcDisplay',
        enablePpcDisplay: 'enablePpcDisplay',
        timeOutCount: 300,
        CLS_DATA: 'vcaClsData',
        defaultPpcValue: 'false'
    };

    /**
     * searchResultListing component
     * @namespace searchResultListing
     * @memberof vca.comp
     */
    vca.comp.searchResultListing = (function($, util, baseUtil) {
        let $comp = null,
            listeners = [],
            $body = $('body'),
            $html = $('html'),
            $htmlBody = $('html,body'),
            $searchForm = null,
            $searchInput = null,
            $stickyCategoryBar = null,
            $pictoCategoryBar = null,
            $jqPictoCategoryBar = null,
            isStickyBarAvailable = false,
            $resultsContainer = null,
            $searchEngine = null,
            $categoryTabLinkTracking = null,
            clsData = JSON.parse(util.cookieManager.getCookie(CONST.CLS_DATA)),
            isAvailablilityLinkClicked = false,
            isCountryCN = util.dataStore.isChina();

        /**
         * Updates variables being used.
         * @function cacheVars
         * @memberOf vca.comp.searchResultListing
         * @private
         * @param {HTMLElement} elem The component element
         * @returns {void}
         */
        function cacheVars(elem) {
            $comp = $(elem);
            $searchForm = $comp.find(CONST.SELECTORS.baseSearchForm);
            $searchInput = $comp.find(CONST.SELECTORS.baseSearchInput);
            $stickyCategoryBar = $comp.find(CONST.SELECTORS.stickyCategoryBar);
            $pictoCategoryBar = document.querySelector(
                CONST.SELECTORS.pictoCategoryBar
            );
            $jqPictoCategoryBar = $comp.find(CONST.SELECTORS.pictoCategoryBar);
            isStickyBarAvailable =
                $stickyCategoryBar.find(CONST.SELECTORS.searchResultCategory)
                    .length > 0
                    ? true
                    : false;
            $resultsContainer = $(CONST.SELECTORS.resultsContainer);
            $searchEngine = $(CONST.SELECTORS.searchEngine);
            $categoryTabLinkTracking = $(
                CONST.SELECTORS.categoryTabLinkTracking
            );
        }

        /**
         * Remove category count and replace text with category name
         * @function removeCategoryCountText
         * @memberOf vca.comp.searchResultListing
         * @private
         * @returns {void}
         */
        function removeCategoryCountText() {
            $comp
                .find(CONST.SELECTORS.searchCatHeading)
                .each(function(index, val) {
                    $(val).text(
                        $(val)
                            .text()
                            .split('(')[0]
                    );
                });
        }

        /**
         * Prevent reading of the filter facet's hidden content by screen reader.
         * @function handleFilterFacetsAccessibility
         * @memberOf vca.comp.searchResultListing
         * @private
         * @returns {void}
         */
        function handleFilterFacetsAccessibility() {
            let facetsImplicitAccessibleElements = $comp.find(
                `${CONST.SELECTORS.searchFilterFacetsActionButtons} ,${CONST.SELECTORS.searchFilterFacetsIconButtons} , ${CONST.SELECTORS.searchFilterFacetsInputs},${CONST.SELECTORS.searchFilterFacetsFieldsets}, ${CONST.SELECTORS.availablityCheckbox}`
            );
            let facetsFilterWrapper = $(CONST.SELECTORS.searchFilterWrapper);

            let facetsFilterWrapperStatus =
                facetsFilterWrapper &&
                facetsFilterWrapper.hasClass(CONST.CSSCLASS.searchFilterActive);
            facetsImplicitAccessibleElements.length &&
                facetsImplicitAccessibleElements.each((index, element) => {
                    if (facetsFilterWrapperStatus) {
                        $(element).attr(
                            CONST.ATTRIBUTES.facetAriaHidden,
                            false
                        );
                        $(element).attr(CONST.ATTRIBUTES.facetTabindex, 0);
                    } else {
                        $(element).attr(CONST.ATTRIBUTES.facetAriaHidden, true);
                        $(element).attr(CONST.ATTRIBUTES.facetTabindex, -1);
                    }
                });
        }
        /**
         * Handle filter button click functionality
         * @function handleFilterFacets
         * @memberOf vca.comp.searchResultListing
         * @private
         * @returns {void}
         */
        function handleFilterFacets() {
            $(CONST.SELECTORS.searchFilterWrapper).addClass(
                CONST.CSSCLASS.searchFilterActive
            );
            $body.addClass(CONST.CSSCLASS.searchFilterOpened);
            $html.addClass(CONST.CSSCLASS.restrictScrolling);
            handleFilterFacetsAccessibility();

            $(CONST.SELECTORS.resetAllFacetsButton).on(
                util.customEvents.INTERACTION,
                resetAvailablityCheckbox
            );
        }

        /**
         * Handle events to close opened fliter wrapper
         * @function handleFilterWrapperToggle
         * @memberOf vca.comp.searchResultListing
         * @private
         * @returns {void}
         */
        function handleFilterWrapperToggle(event) {
            if (
                (!$(event.target).parents(CONST.SELECTORS.searchFilterWrapper)
                    .length ||
                    $(event.target).hasClass(CONST.CSSCLASS.applyButton) ||
                    $(event.target).is(CONST.SELECTORS.applyAllBtn)) &&
                !$(event.target).is(':disabled') &&
                !$(event.target)
                    .parent()
                    .is(':disabled')
            ) {
                $(CONST.SELECTORS.searchFilterWrapper).removeClass(
                    CONST.CSSCLASS.searchFilterActive
                );
                $body.removeClass(CONST.CSSCLASS.searchFilterOpened);
                $html.removeClass(CONST.CSSCLASS.restrictScrolling);
                //event.stopPropagation();
                handleFilterFacetsAccessibility();
            }
        }

        /**
         * It update the search result with either no-result found or server error screen
         * @function noResultsFoundHandler
         * @memberOf vca.comp.searchResultListing
         * @private
         * @param - isServerSideError{Boolen} - true is called from server error event
         * @desc - It update the search result with either no-result found or server error screen.
         * @returns {void}
         */
        function noResultsFoundHandler(isServerSideError) {
            $(CONST.SELECTORS.noResultComp).removeClass(CONST.CSSCLASS.hide);
            $(CONST.SELECTORS.searchEngine).addClass(CONST.CSSCLASS.hide);

            if (!isServerSideError) {
                util.throttle(function() {
                    $(CONST.SELECTORS.noResultWord).text(
                        $(CONST.SELECTORS.noResultKeyword).text()
                    );
                }, 0)();
                $(CONST.SELECTORS.noResultError).removeClass(
                    CONST.CSSCLASS.hide
                );
                $body.removeClass(CONST.CSSCLASS.searchFilterOpened);
            } else {
                $(CONST.SELECTORS.noResultServerError).removeClass(
                    CONST.CSSCLASS.hide
                );
            }
        }

        /**
         * It will handle the visibility of search floating action button
         * @function searchFloatingActionBtnHandler
         * @memberOf vca.comp.searchResultListing
         * @private
         * @desc - It will show/hide all the search floating action button
         * @returns {void}
         */
        function searchFloatingActionBtnHandler(visibility) {
            if (visibility) {
                $(CONST.SELECTORS.searchToggleViewBtnWrapper).removeClass(
                    CONST.CSSCLASS.hide
                );
                return;
            }
            $(CONST.SELECTORS.searchToggleViewBtnWrapper).addClass(
                CONST.CSSCLASS.hide
            );
        }

        /**
         * It will hide all the facet items having zero item in it
         * @function zeroItemFacetUpdateHandler
         * @memberOf vca.comp.searchResultListing
         * @private
         * @desc - It will hide all the facet items having zero item in it.
         * @returns {void}
         */
        function zeroItemFacetUpdateHandler() {
            $(CONST.SELECTORS.searchFacetItem).removeClass(
                CONST.CSSCLASS.zeroResultFacet
            );

            util.throttle(function() {
                $(CONST.SELECTORS.subList).each(function(index, item) {
                    if ($(item).find(CONST.SELECTORS.flexRow).length < 1) {
                        $(item)
                            .parents(CONST.SELECTORS.searchFacetItem)
                            .addClass(CONST.CSSCLASS.zeroResultFacet);
                    }
                });
            })();
        }

        /**
         * Search box close button click handler
         * @function closeBtnClickHandler
         * @memberOf vca.comp.searchResultListing
         * @private
         * @desc - It clear search input.
         * @returns {void}
         */
        function closeBtnClickHandler() {
            if ($searchInput.val()) {
                $searchInput.val('');
                // remove query params and reload page
                window.location = window.location.href.split('?')[0];
                return;
            }
        }

        /**
         * Initial task exectution
         * @function start
         * @memberOf vca.comp.searchResultListing
         * @private
         * @returns {void}
         */
        function start() {
            let isEnablePriceDisplay = $comp.data(CONST.enablePriceDisplay);
            let isEnablePpcDisplay =
                clsData && clsData.ppcEnable ? clsData.ppcEnable : null;

            if (
                typeof isEnablePpcDisplay == 'undefined' ||
                typeof isEnablePpcDisplay == null
            ) {
                isEnablePpcDisplay = CONST.defaultPpcValue;
            }

            removeCategoryCountText();
            if (isStickyBarAvailable) {
                searchFloatingActionBtnHandler(false);
            }
            util.webStorage.set(
                CONST.enablePriceDisplayKey,
                String(isEnablePriceDisplay)
            );
            util.webStorage.set(
                CONST.enablePpcDisplayKey,
                String(isEnablePpcDisplay)
            );
        }

        /**
         * toggle caategory sticky bar in bottom
         * @function toggleStickyBar
         * @memberOf vca.comp.searchResultListing
         * @private
         * @returns {void}
         */
        function toggleStickyBar(state) {
            $stickyCategoryBar.toggleClass(
                CONST.CSSCLASS.stickyCategoryBarActive,
                state
            );
        }

        /**
         * sticky bar link click handler
         * @function stickyBarInteractionHandler
         * @memberOf vca.comp.searchResultListing
         * @private
         * @returns {boolen} false
         */
        function stickyBarInteractionHandler(event) {
            if (
                $(event.target).hasClass(CONST.CSSCLASS.categoryTabLink) ||
                $(event.target).closest(CONST.SELECTORS.categoryTabLink).length
            ) {
                $htmlBody.animate(
                    {
                        scrollTop: $jqPictoCategoryBar.offset().top - 100
                    },
                    100
                );
            }
            return false;
        }

        /**
         * scroll top button click handler
         * @function toggleScrollToTop
         * @memberOf vca.comp.searchResultListing
         * @private
         * @returns {void}
         */
        function toggleScrollToTop() {
            $(CONST.SELECTORS.scrollTopBtn).toggleClass(
                CONST.CSSCLASS.showBtn,
                window.pageYOffset > window.innerHeight
            );
            if (
                !$(CONST.SELECTORS.resultList).hasClass(
                    CONST.CSSCLASS.articlesResultListing
                )
            ) {
                $(CONST.SELECTORS.toggleViewBtn).toggleClass(
                    CONST.CSSCLASS.showBtn,
                    window.pageYOffset > window.innerHeight
                );
            }
        }

        /**
         * toggle result listing view
         * @function toggleResultListView
         * @memberOf vca.comp.searchResultListing
         * @private
         * @returns {void}
         */
        function toggleResultListView(event) {
            $(CONST.SELECTORS.resultList).toggleClass(
                CONST.CSSCLASS.listSingleGrid
            );

            $(event.target)
                .toggleClass(CONST.CSSCLASS.zoomOut)
                .toggleClass(CONST.CSSCLASS.zoomIn);
        }

        /**
         * scroll view to top handler
         * @function scrollToTopHandler
         * @memberOf vca.comp.searchResultListing
         * @private
         * @returns {void}
         */
        function scrollToTopHandler() {
            $htmlBody.animate({ scrollTop: 0 }, 500);
            return false;
        }

        /**
         * Method to push the tracking data into datalayer
         * @function linkDataTracking
         * @memberOf vca.comp.searchResultListing
         * @private
         * @returns {void}
         */
        function linkDataTracking() {
            let $this = $(this),
                categorySelected = $this.data('categoryId'),
                facetCategory =
                    $this.closest(CONST.SELECTORS.stickyCategoryBar).length !==
                    0
                        ? CONST.ATTRIBUTES.facetCategorySticky
                        : CONST.ATTRIBUTES.facetCategoryFilter,
                trackingEventObj = {};

            // Analytics for slider category
            trackingEventObj = {
                event: 'slider_tracking',
                facet_category: facetCategory,
                category_selected: categorySelected
            };

            baseUtil.analytics.pushDataToDataLayer(trackingEventObj);
        }

        /**
         * Method to push the tracking data into datalayer
         * @function filterTracking
         * @memberOf vca.comp.searchResultListing
         * @private
         * @returns {void}
         */
        function filterTracking() {
            let trackingEventObj = {},
                filter = $(this).data('filter'),
                subfilter = $(this).data('subfilter');

            // Analytics for login and register
            trackingEventObj = {
                event: 'filter_tracking',
                filter: filter,
                sub_filter: subfilter
            };
            baseUtil.analytics.pushDataToDataLayer(trackingEventObj);

            // Check for china only
            if (isCountryCN) {
                // Code for sensor data on Filters Tracking
                baseUtil.analytics.pushToSensorsData('FiltersTracking', {
                    filter: filter,
                    subfilter: subfilter
                });
            }
        }

        /**
         * Callback handler to be called after search result updated
         * @function onResultUpdateHandler
         * @memberOf vca.comp.searchResultListing
         * @private
         * @returns {void}
         */
        function onResultUpdateHandler() {
            util.throttle(function() {
                util.addToWishlist.syncProds();
                // Hide availablity buttons if not authored.
                if ($(CONST.SELECTORS.availablityCheckbox).length < 1) {
                    $(CONST.SELECTORS.searchCreationCountWrapper).addClass(
                        CONST.CSSCLASS.hide
                    );
                } else {
                    $(CONST.SELECTORS.searchCreationCountWrapper).removeClass(
                        CONST.CSSCLASS.hide
                    );
                }
            }, CONST.timeOutCount)();

            if (isAvailablilityLinkClicked) {
                // util.loader.hide();
                isAvailablilityLinkClicked = false;
            }
        }

        /**
         * initialize custom dropdown
         * @function initializeCustomDropdown
         * @memberOf vca.comp.searchResultListing
         * @private
         * @returns {void}
         */
        function initializeCustomDropdown() {
            util.throttle(function() {
                util.customSelect.init();
            })();
        }

        /**
         * bind component events
         * @function bindEvents
         * @memberOf vca.comp.searchResultListing
         * @private
         * @returns {void}
         */
        function bindEvents() {
            $(CONST.SELECTORS.searchFilterWrapper).on(
                util.customEvents.INTERACTION,
                handleFilterWrapperToggle
            );

            $(CONST.SELECTORS.searchFilterBtn).on(
                util.customEvents.INTERACTION,
                handleFilterFacets
            );

            $(CONST.SELECTORS.stickyCategoryBar).on(
                util.customEvents.INTERACTION,
                stickyBarInteractionHandler
            );

            $(CONST.SELECTORS.toggleViewBtn).on(
                util.customEvents.INTERACTION,
                toggleResultListView
            );

            $(CONST.SELECTORS.scrollTopBtn).on(
                util.customEvents.INTERACTION,
                scrollToTopHandler
            );

            listeners.push(
                $.subscribe(util.customEvents.SCROLLED, toggleScrollToTop),
                $.subscribe(
                    util.customEvents.IO_ELEM_IN +
                        ':' +
                        CONST.stickyCategoryBarStr,
                    function() {
                        vca.comp.header.toggleSearchCategoryStickyBar(false);
                    }
                ),
                $.subscribe(
                    util.customEvents.IO_ELEM_OUT +
                        ':' +
                        CONST.stickyCategoryBarStr,
                    function() {
                        vca.comp.header.toggleSearchCategoryStickyBar(true);
                    }
                )
            );
            // web search related event handling
            // on search server side error
            window.addEventListener(
                util.customEvents.SR_WS_onSearchServerError,
                function() {
                    noResultsFoundHandler(true);
                    searchFloatingActionBtnHandler(false);
                }
            );

            // on no result found event
            window.addEventListener(
                util.customEvents.SR_WS_noResultsFound,
                function() {
                    noResultsFoundHandler(false);
                    searchFloatingActionBtnHandler(false);
                }
            );

            // SR-WS on onEndResultsLoading event
            window.addEventListener(
                util.customEvents.SR_WS_onEndResultsLoading,
                () => {
                    zeroItemFacetUpdateHandler();
                    initializeCustomDropdown();
                }
            );

            // SR-WS on SR_WS_updateResults event
            window.addEventListener(
                util.customEvents.SR_WS_updateResults,
                onResultUpdateHandler
            );

            // SR-WS on SR_WS_onUpdateResultCategory event
            window.addEventListener(
                util.customEvents.SR_WS_onUpdateResultCategory,
                onResultUpdateHandler
            );

            /* Submit form on enter press */
            $searchForm.on('keyup', function(event) {
                if (event.keyCode === 13) {
                    $searchForm.submit();
                }
            });

            // empty search input on close btn click
            $(CONST.SELECTORS.searchCloseBtn).on(
                util.customEvents.INTERACTION,
                closeBtnClickHandler
            );

            if (isStickyBarAvailable && $pictoCategoryBar) {
                util.io.isElementInView(
                    CONST.stickyCategoryBarStr,
                    $pictoCategoryBar
                );
            }

            $resultsContainer.on(
                util.customEvents.INTERACTION,
                CONST.SELECTORS.filterSelector,
                filterTracking
            );

            $searchEngine.on(
                util.customEvents.INTERACTION,
                CONST.SELECTORS.categoryTab,
                linkDataTracking
            );

            $categoryTabLinkTracking.on(
                util.customEvents.INTERACTION,
                linkDataTracking
            );

            $stickyCategoryBar.on(
                util.customEvents.INTERACTION,
                CONST.SELECTORS.categoryTabLinkTracking,
                linkDataTracking
            );

            $resultsContainer.on(
                util.customEvents.CHANGE,
                CONST.SELECTORS.avaiblityFilterCheckbox,
                availibilityFilterHandler
            );

            $resultsContainer.on(
                util.customEvents.CHANGE,
                CONST.SELECTORS.srlSortTypeSelect,
                sortFilterHandler
            );

            $resultsContainer.on(
                util.customEvents.INTERACTION,
                CONST.SELECTORS.srlSortTypeSelectCustom,
                sortFilterHandler
            );

            if (
                util.matchmedia.narrow.matches ||
                util.matchmedia.tablet.matches
            ) {
                $resultsContainer.on(
                    util.customEvents.INTERACTION,
                    CONST.SELECTORS.srlAvailablityTooltip,
                    tooltipToggle
                );
            }
        }

        /**
         * creation availablity filter buttons click handler
         * @function availibilityFilterHandler
         * @memberOf vca.comp.searchResultListing
         * @private
         * @returns {void}
         */
        function availibilityFilterHandler() {
            let isOnlineAvailableChecked = $(
                    CONST.SELECTORS.availablityCheckbox
                ).is(':checked')
                    ? true
                    : false,
                isSrlAvailablityChecked = $(
                    CONST.SELECTORS.avaiblityFilterCheckbox
                ).is(':checked');
            if (
                (isSrlAvailablityChecked && !isOnlineAvailableChecked) ||
                (!isSrlAvailablityChecked && isOnlineAvailableChecked)
            ) {
                $(CONST.SELECTORS.availablityCheckbox).trigger(
                    util.customEvents.INTERACTION
                );

                isAvailablilityLinkClicked = true;
                // util.loader.show();
            }
        }

        /**
         * reset availablity checkbox button on reset filter click handler
         * @function resetAvailablityCheckbox
         * @memberOf vca.comp.searchResultListing
         * @private
         * @returns {void}
         */
        function resetAvailablityCheckbox() {
            let isOnlineAvailableChecked = $(
                    CONST.SELECTORS.availablityCheckbox
                ).is(':checked')
                    ? true
                    : false,
                isSrlAvailablityChecked = $(
                    CONST.SELECTORS.avaiblityFilterCheckbox
                ).is(':checked');
            if (isSrlAvailablityChecked || isOnlineAvailableChecked) {
                $(CONST.SELECTORS.avaiblityFilterCheckbox).prop(
                    'checked',
                    false
                );
            }
        }

        /**
         * creation sort filter click handler
         * @function sortFilterHandler
         * @memberOf vca.comp.searchResultListing
         * @private
         * @returns {void}
         */
        function sortFilterHandler(e) {
            let targetElem,
                $thisElemVal,
                $thisElem = $(e.currentTarget || e.target);
            if (
                util.matchmedia.narrow.matches ||
                util.matchmedia.tablet.matches
            ) {
                $thisElemVal = $thisElem.val();
            } else {
                $thisElemVal = $thisElem.data('value');
            }
            targetElem = $body.find('#' + $thisElemVal);
            targetElem.trigger(util.customEvents.INTERACTION);
        }

        /**
         * tooltip toogle handler
         * @function tooltipToggle
         * @memberOf vca.comp.searchResultListing
         * @private
         * @returns {void}
         */
        function tooltipToggle() {
            $(CONST.SELECTORS.srlAvailablityTooltipText).toggleClass(
                CONST.CSSCLASS.visibilityHidden
            );
        }

        /**
         * Unbinds all pre-existing events
         * @function teardown
         * @memberOf vca.comp.searchResultListing
         * @private
         * @returns {void}
         */
        function teardown() {
            while (listeners.length) {
                $.unsubscribe(listeners.pop());
            }

            $(CONST.SELECTORS.searchFilterWrapper).off(
                util.customEvents.INTERACTION,
                handleFilterWrapperToggle
            );

            $(CONST.SELECTORS.searchFilterBtn).off(
                util.customEvents.INTERACTION,
                handleFilterFacets
            );

            $(CONST.SELECTORS.toggleViewBtn).off(
                util.customEvents.INTERACTION,
                toggleResultListView
            );

            $(CONST.SELECTORS.scrollTopBtn).off(
                util.customEvents.INTERACTION,
                scrollToTopHandler
            );

            window.removeEventListener(
                util.customEvents.SR_WS_onSearchServerError,
                function() {
                    noResultsFoundHandler(true);
                    searchFloatingActionBtnHandler(false);
                }
            );

            window.removeEventListener(
                util.customEvents.SR_WS_noResultsFound,
                function() {
                    noResultsFoundHandler(false);
                    searchFloatingActionBtnHandler(false);
                }
            );

            window.removeEventListener(
                util.customEvents.SR_WS_onEndResultsLoading,
                zeroItemFacetUpdateHandler
            );

            $searchForm.off('keyup');

            $(CONST.SELECTORS.searchCloseBtn).off(
                util.customEvents.INTERACTION,
                closeBtnClickHandler
            );
        }

        /**
         * Initialize the component
         * @function init
         * @memberOf vca.comp.searchResultListing
         * @private
         * @param {HTMLElement} elem The component element
         * @returns {void}
         */
        function init(elem) {
            util.webStorage.set(
                CONST.enablePpcDisplayKey,
                String(CONST.defaultPpcValue)
            );
            cacheVars(elem);
            teardown();
            bindEvents();
            start();
        }

        return {
            init: init,
            toggleStickyBar: toggleStickyBar
        };
    })(vca.$, vca.util, base.util);
})(window.vca, window.base);

/**
 * editorialHighlightWrapper.js
 * functionality for the editorialHighlightWrapper component
 * abbrivation  -
 * EH - Editorial Highlight
 */
(function(w, vca, base) {
    'use strict';

    const SELECTORS = {
            expFragment: '.xf-content-height',
            searchResultContainer: '.vca-srl',
            resultList: '.results-list',
            productTile: '.vca-srl-product-tile',
            preEditorialHighlightItem: '.vca-srl-next-eh',
            experienceFragments: '.xf-content-height',
            editorialHighlightCard: '.vca-srl-editorial-card'
        },
        CSS_CLASSES = {
            editorialHighlightPrevItem: 'vca-srl-next-eh',
            productHighlightedTile:'vca-srl-product-highlighted-tile',
            hide: 'vca-hide'
        },
        THROTTLE_TIMEOUT = 100;

    /**
     * notification bar component
     * @namespace editorialHighlightWrapper
     * @memberof vca.comp
     */
    vca.comp.editorialHighlightWrapper = (function($, util, baseUtil) {
        let $comp = null,
            listeners = [],
            allEditorialHighlights = null,
            $carousel = null;

        /**
         * updated product list with editorial highlights
         * @function updatedListWithEditorialHighlight
         * @memberOf vca.comp.editorialHighlightWrapper
         * @private
         * @returns {void}
         */
        function updatedListWithEditorialHighlight() {
            let $allEditorialHighlightCard = $(
                SELECTORS.editorialHighlightCard
            );
            $allEditorialHighlightCard.each(function(index, elem) {
                if (allEditorialHighlights[index]) {
                    $(elem).html(allEditorialHighlights[index]);
                } else {
                    $(elem).addClass(CSS_CLASSES.hide);
                    $(elem).prev().removeClass(CSS_CLASSES.productHighlightedTile);
                    $(elem).next().removeClass(CSS_CLASSES.productHighlightedTile);
                }
            });

            // initialize components in experience fragment.
            util.throttle(function() {
                baseUtil.initialise($allEditorialHighlightCard);
                vca.util.initialise($allEditorialHighlightCard);
                $carousel = $allEditorialHighlightCard.find(
                    '[data-vca-carousel]'
                );
                vca.util.carousel.contextualInit($carousel);
                normaliseNonEHProductView();
            }, 100)();
        }

        /**
         * update reesult list with editorial highlight attached to collection
         * @function resultUpdateHandler
         * @memberOf vca.comp.editorialHighlightWrapper
         * @private
         * @returns {void}
         */
        function resultUpdateHandler() {
            let $searchResultContainer = $(SELECTORS.searchResultContainer),
                $searchResultList = $searchResultContainer.find(
                    SELECTORS.resultList
                );

            if (allEditorialHighlights.length) {
                updatedListWithEditorialHighlight($searchResultList);
            } else {
                $searchResultList.find(SELECTORS.productTile).removeClass(CSS_CLASSES.productHighlightedTile);
                return;
            }
        }

        /**
         * normalise the list view based on EH availability
         * @function normaliseNonEHProductView
         * @memberOf vca.comp.editorialHighlightWrapper
         * @private
         */
        function normaliseNonEHProductView() {
            let $allEditorialHighlightCard = $(
                SELECTORS.editorialHighlightCard
            );
            $allEditorialHighlightCard.each(function(index, elem) {
                if ($(elem).is(':empty')) {
                    $(elem).addClass(CSS_CLASSES.hide);
                    $(elem).prev().removeClass(CSS_CLASSES.productHighlightedTile);
                    $(elem).next().removeClass(CSS_CLASSES.productHighlightedTile);
                }
            });
        }

        /**
         * reeturn all editorial highlights
         * @function getAllEditorialHighlights
         * @memberOf vca.comp.editorialHighlightWrapper
         * @private
         * @returns {Array} list of all attached editorial highlights
         */
        function getAllEditorialHighlights() {
            return $comp.find(SELECTORS.experienceFragments).toArray();
        }

        /**
         * execute result update handler with throttle
         * @function throttleResultUpdateHandler
         * @memberOf vca.comp.editorialHighlightWrapper
         * @private
         * @returns {void}
         */
        function throttleResultUpdateHandler() {
            util.throttle(resultUpdateHandler, THROTTLE_TIMEOUT)();
        }

        /**
         * This handler will observe result list updation and based on that it will normalise EH view
         * @function observeResultListUpdationHandler
         * @memberOf vca.comp.editorialHighlightWrapper
         * @private
         * @returns {void}
         */
        function observeResultListUpdationHandler() {
        // The node to be monitored
            const target = document.getElementById('results');
            const throttledNormaliseNonEHProductView = util.throttle(normaliseNonEHProductView, THROTTLE_TIMEOUT);
            // Create an observer instance
            let observer = new MutationObserver(function( mutations ) {
                mutations.forEach(function( mutation ) {
                    var newNodes = mutation.addedNodes; // DOM NodeList
                    if ( newNodes !== null ) {
                        // If there are new nodes added
                        throttledNormaliseNonEHProductView();
                    }
                });
            });

            // Configuration of the observer:
            const config = {
                childList: true
            };

            // Pass in the target node, as well as the observer options
            if (target) observer.observe(target, config);
        }

        /**
         * initial execution
         * @function start
         * @memberOf vca.comp.editorialHighlightWrapper
         * @private
         * @returns {void}
         */
        function start() {
            allEditorialHighlights = getAllEditorialHighlights();
        }

        /**
         * Cache variables being used.
         * @function cacheVars
         * @memberOf vca.comp.editorialHighlightWrapper
         * @private
         * @param {HTMLElement} elem The component element
         * @returns {void}
         */
        function cacheVars(elem) {
            $comp = $(elem);
        }

        /**
         * Bind events
         * @function bindEvents
         * @memberOf vca.comp.editorialHighlightWrapper
         * @private
         * @returns {void}
         */
        function bindEvents() {
            // event subscribers
            window.addEventListener(
                util.customEvents.SR_WS_updateResults,
                throttleResultUpdateHandler
            );

            window.addEventListener(
                util.customEvents.SR_WS_onUpdateResultCategory,
                throttleResultUpdateHandler
            );

            window.addEventListener(
                util.customEvents.LOAD_EDITORIAL_HIGHLIGHT,
                throttleResultUpdateHandler
            );

            observeResultListUpdationHandler();
        }

        /**
         * Unbinds all pre-existing events
         * @function teardown
         * @memberOf vca.comp.editorialHighlightWrapper
         * @private
         * @returns {void}
         */
        function teardown() {
            while (listeners.length) {
                $.unsubscribe(listeners.pop());
            }
        }

        /**
         * Initialize the component
         * @function init
         * @memberOf vca.comp.editorialHighlightWrapper
         * @private
         * @param {HTMLElement} elem The component element
         * @returns {void}
         */
        function init(elem) {
            cacheVars(elem);
            teardown();
            bindEvents();
            start();
        }

        return {
            init: init
        };
    })(vca.$, vca.util, base.util);
})(window, window.vca, window.base);


/**
 * editorialSequence.js
 * functionality for the editorial Sequence component
 */
(function(vca) {
    'use strict';

    const CONST = {
        SELECTORS: {
            draggable: '.draggable',
        },
        CLASS: {
            grabbing: 'grabbing'
        },
        EVENT: {
            START: 'touchstart mousedown pointerDown',
            END: 'touchend mouseup mouseleave pointerUp'
        }
    };

    /**
     * Editorial Sequence component
     * @namespace editorialSequence
     * @memberOf vca.comp
     */
    vca.comp.editorialSequence = (function($) {
        var $comp = null,
            $draggableContainer = null;

        /**
         * Handler for drag start event
         * @function dragStartEventHandler
         * @memberOf vca.comp.editorialSequence
         * @private
         */
        function dragStartEventHandler() {
            $draggableContainer.addClass(CONST.CLASS.grabbing);
        }

        /**
         * Handler for drag end event
         * @function dragEndEventHandler
         * @memberOf vca.comp.editorialSequence
         * @private
         */
        function dragEndEventHandler() {
            $draggableContainer.removeClass(CONST.CLASS.grabbing);
        }

        /**
         * Bind events
         * @function bindEvents
         * @memberOf vca.comp.editorialSequence
         * @private
         */
        function bindEvents() {
            $comp.on(
                CONST.EVENT.START,
                dragStartEventHandler
            );

            $comp.on(
                CONST.EVENT.END,
                dragEndEventHandler
            );
        }

        /**
         * Cache variables
         * @function cacheVars
         * @memberOf vca.comp.editorialSequence
         * @private
         */
        function cacheVars(elem) {
            $comp = $(elem);
            $draggableContainer = $comp.find(CONST.SELECTORS.draggable);
        }

        /**
         * Initialise editorialSequence
         * @function init
         * @memberOf vca.comp.editorialSequence
         * @private
         */
        function init(elem) {
            cacheVars(elem);
            bindEvents();
        }

        return {
            init: init
        };
    })(vca.$, vca.util);

})(window.vca);

/**
 * editorialCard.js
 * functionality for the editorial card component
 */
(function(vca, $, base) {
    'use strict';

    const CONST = {
        SELECTORS: {
            editorialCard: '.vca-editorial-card',
            editorialCardBtn: '.vca-ec-btn',
            primary: '.vca-ec-primary',
            secondary: '.vca-ec-secondary',
            videoTag: '.vca-video-tag'
        },
        CLASS: {
            pressAndHold: 'vca-press-hold'
        },
        EVENT: {
            START: 'touchstart mousedown pointerDown',
            END: 'touchend mouseup mouseleave pointerUp',
            TOUCHSTART: 'touchstart',
            TOUCHEND: 'touchend',
            MOUSEDOWN: 'mousedown',
            MOUSEUP: 'mouseup',
            MOUSELEAVE: 'mouseleave',
            PRESSHOLD: 'pressHold'
        },
        isTouchDevice: 'ontouchstart' in document.documentElement,
        taskExecutionTimeout: 100,
        pressHoldDuration: 10 // Value to adjust how long one should keep pressing down before the pressHold event fires
    };

    const HANDLERS = {
        TODO: {
            interactiveVideoBoomerang: function() {
                let video = this.$primary.find(CONST.SELECTORS.videoTag)[0];
                if (video.paused) {
                    video.reverse_stop = true;
                    video.playbackRate = 1.0;
                    video.play();
                }
            }
        },
        UNDO: {
            interactiveVideoBoomerang: function() {
                // ref - http://nicbell.net/blog/playing-html5-video-backwards/
                // - https://stackoverflow.com/a/51900030/1957498

                let video = this.$primary.find(CONST.SELECTORS.videoTag)[0],
                    fps = base.util.deviceDetection.isAndroid() ? 4 : 30,
                    fpsInterval = 1000 / fps,
                    startReverse = function() {
                        video.playbackRate = 0;
                        video.reverse_stop = false;
                        video.then = Date.now();
                        animateReverse();
                    },
                    animateReverse = function() {
                        // stop playing in reverse
                        if (video.reverse_stop) {
                            video.pause();
                            return;
                        }
                        // request another frame
                        requestAnimationFrame(function() {
                            animateReverse(video);
                        });
                        // calculate elapsed time since last loop
                        let now = Date.now(),
                            elapsed = now - video.then;

                        // if enough time has elapsed, draw the next frame
                        if (elapsed > fpsInterval) {
                            video.then = now - (elapsed % fpsInterval);

                            // if we reach the beginning, stop playing in reverse.
                            // otherwise, move backward.
                            if (video.currentTime <= 0) {
                                video.reverse_stop = true;
                                video.pause();
                            } else {
                                video.currentTime -= 1 / fps;
                            }
                        }
                    };

                startReverse();
            }
        }
    };

    /**
     * Constructor for EditorialCard
     * @memberof vca.comp.editorialCard
     * @private
     * @constructor
     * @param {HTMLElement} elem Editorial Card element
     */
    function EditorialCard(elem) {
        this.$card = $(elem);
        this.cardType = this.$card.data('cardType');
        this.$controlBtn = null;
        this.$primary = null;
        this.$secondary = null;

        this.init.apply(this);
    }

    EditorialCard.prototype = {
        /**
         * Do a task during press
         * @function doTask
         * @memberOf vca.comp.editorialCard.EditorialCard#
         * @private
         */
        doTask: function() {
            if (typeof HANDLERS.TODO[this.cardType] === 'function') {
                HANDLERS.TODO[this.cardType].call(this);
            }
        },

        /**
         * Undo a task after press release
         * @function undoTask
         * @memberOf vca.comp.editorialCard.EditorialCard#
         * @private
         */
        undoTask: function() {
            if (typeof HANDLERS.UNDO[this.cardType] === 'function') {
                HANDLERS.UNDO[this.cardType].call(this);
            }
        },

        /**
         * Handler for pressing Down
         * @function pressStartHandler
         * @memberOf vca.comp.editorialCard.EditorialCard#
         * @private
         * @param {object} event The event object
         */
        pressStartHandler: function(event) {
            event.preventDefault();

            this.$card.addClass(CONST.CLASS.pressAndHold);
            this.doTask.call(this);
        },

        /**
         * Handler for not Pressing Down, reset counter and timer.
         * @function pressEndHandler
         * @memberOf vca.comp.editorialCard.EditorialCard#
         * @private
         * @param {object} event The event object
         */
        pressEndHandler: function(event) {
            event.preventDefault();

            this.$card.removeClass(CONST.CLASS.pressAndHold);
            this.undoTask.call(this);
        },

        /**
         * Bind events
         * @function bindEvents
         * @memberOf vca.comp.editorialCard.EditorialCard#
         * @private
         */
        bindEvents: function() {
            this.$controlBtn.on(
                CONST.EVENT.START,
                this.pressStartHandler.bind(this)
            );

            this.$controlBtn.on(
                CONST.EVENT.END,
                this.pressEndHandler.bind(this)
            );
        },

        /**
         * Cache variables
         * @function cacheVars
         * @memberOf vca.comp.editorialCard.EditorialCard#
         * @private
         */
        cacheVars: function() {
            this.$controlBtn = this.$card.find(
                CONST.SELECTORS.editorialCardBtn
            );

            this.$primary = this.$card.find(CONST.SELECTORS.primary);
            this.$secondary = this.$card.find(CONST.SELECTORS.secondary);
        },

        /**
         * Initialise EditorialCard
         * @function init
         * @memberOf vca.comp.editorialCard.EditorialCard#
         * @private
         */
        init: function() {
            this.cacheVars();

            this.bindEvents();
        }
    };

    /**
     * Editorial card component
     * @namespace editorialCard
     * @memberOf vca.comp
     */
    vca.comp.editorialCard = (function() {
        /**
         * Initializes the editorial card, and returns the instance
         * @function init
         * @memberOf vca.comp.editorialCard
         * @private
         * @param {HTMLElement} elem
         * @returns {Object} an instance of EditorialCard
         */
        function init(elem) {
            return new EditorialCard(elem);
        }

        return {
            init: init
        };
    })();
})(window.vca, window.vca.$, window.base);

/**
 * collectionCarousel.js
 * functionality for the collectionCarousel component
 */
(function(vca) {
    'use strict';

    /**
     * collectionCarousel component
     * @namespace collectionCarousel
     * @memberof vca.comp
     */
    vca.comp.collectionCarousel = (function($, util) {
        var CONST = {
            SELECTORS: {
                carousel: '.vca-coll-carousel',
                carouselChildren: '.vca-cc-card:not(.slick-cloned)'
            },
            CSS_CLASSES: {
                slickActive: 'slick-initialized',
                nonSlick: 'vca-collection-carousel-unslick'
            },
            DEFAULT_SLICK_SETTINGS: {
                arrows: false,
                dots: true,
                centerMode: true,
                adaptiveHeight: false,
                infinite: true,
                slidesToShow: 1,
                slidesToScroll: 1,
                variableWidth: true
            }
        };

        var $comp = null,
            $carousel = null,
            $carouselChildren = null;

        /**
         * Carousel reinit
         * @function slickHandler
         * @private
         * @memberOf vca.comp.collectionCarousel
         */
        function slickUslickCarousel() {
            var child = $carouselChildren.length;

            if (!util.matchmedia.narrow.matches && child <= 2) {
                if ($carousel.hasClass(CONST.CSS_CLASSES.slickActive)) {
                    $carousel.slick('unslick');
                }
            } else {
                if (!$carousel.hasClass(CONST.CSS_CLASSES.slickActive)) {
                    vca.util.carousel.contextualInit(
                        CONST.DEFAULT_SLICK_SETTINGS
                    );
                }
            }
        }

        /**
         * Cache variables being used.
         * @function cacheVars
         * @memberOf vca.comp.collectionCarousel
         * @private
         * @param {HTMLElement} elem The component element
         * @returns {void}
         */
        function cacheVars(elem) {
            $comp = $(elem);
            $carousel = $comp.find(CONST.SELECTORS.carousel);
            $carouselChildren = $comp.find(CONST.SELECTORS.carouselChildren);
        }

        /**
         * Initialize the component
         * @function init
         * @memberOf vca.comp.collectionCarousel
         * @private
         * @param {HTMLElement} elem The component element
         * @returns {void}
         */
        function init(elem) {
            cacheVars(elem);
            if (!util.wcmmode.isEditMode) {
                slickUslickCarousel();
            }
        }

        return {
            init: init
        };
    })(vca.$, vca.util);
})(window.vca);

/* global vca */

// initialisation file for vca
(function($, util, base) {
    'use strict';

    let $html = $('html');
    const CSSCLASS = {
        iosDevice: 'vca-ios-device'
    };

    function initializeUtils() {
        // initializes request utility
        util.request.init();

        // initializes slider utility
        util.loader.init();

        // initializes slider utility
        util.slider.init();

        // initializes tabs utility
        util.tabs.init();

        // initializes tabs utility
        util.accordion.init();

        // initializes customSelect utility
        util.customSelect.init();

        // initialise carousel
        util.carousel.init();

        // initialise lightboxes
        util.lightbox.init();
        util.threesixty.init();
        // // initialise add to wishlist functionality
        util.addToWishlist.init();

        // initialise add to conciergeDetail functionality
        util.conciergeDetail.init();

        // initialize content list load more btn feature
        util.loadMoreBtn.init();

        // initialize video utility
        util.videoPlayer.init();

        // initialize toaster utility
        util.toaster.init();

        // initialize leaf utility
        util.leaf.init();

        // initialize toaster utility
        util.pageTransition.init();

        // initialize content card - product utility
        util.ccProduct.init();

        // initialize productList tracking
        util.productListTracking.init();

        // initialize market popin utility
        util.marketPopin.init();

        // initialize grab utility
        util.grab.init();

        // initialize care advisor link utility
        util.careAdvisorLink.init();

        // initialize bem video popup utility
        util.ccBemVideo.init();
    }

    /**
     * It will do generic page level task
     * @function initializePage
     * @private
     */
    function initializePage() {
        if (base.util.deviceDetection.isIOS()) {
            $html.addClass(CSSCLASS.iosDevice);
        }
    }

    /**
     * It will do generic jquery extend initialisation
     * @function initializeJqueryExtends
     * @private
     */
    function initializeJqueryExtends() {
        // check if current element has parent element 'elem'
        $.fn.hasParent = function(elem) {
            return Boolean($(this).closest(elem).length);
        };
    }

    $(function() {
        // initialize page specific generic functionality
        initializePage();

        // initialize jquery Extends
        initializeJqueryExtends();

        // initialize specific utilities
        initializeUtils();

        // initialise components
        util.initialise(document);
    });
})(vca.$, vca.util, base);

